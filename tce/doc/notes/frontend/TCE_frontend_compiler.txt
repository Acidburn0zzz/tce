
NOTE: In this document I call the third-party compilation system that should
produce unscheduled TTA code "frontend compiler". This is, in most cases,
just a complete compilation system, which includes frontend, backend,
assembler and perhaps even linker. So, the "frontend compiler" should not be
confused with the "compiler frontend", which is just a piece of a compiler!


Purpose
-------

The purpose of this document is to provide enough background information to
begin the porting work that will give a frontend compiler to the TCE
toolset. With the information contained in this document, it should be
possible to carry out the porting job almost independently.


Overview
--------

We brutally rip the Move gcc frontend compiler.  The TCE-gcc v1.0 will be
derived from gcc-move and will support only C language, and does not
implement "longjumps" (see below).

The work necessary to adapt gcc-move so as to produce TTA sequential code
for TCE consists of 4 main tasks:

1. Rewrite the syscall layer to conform to trap mechanism of TTA-TCE.

2. Streamlining of the base operation set.

3. Enlarge the register sets of the TTA architecture.

4. Disabling all code "optimisations" even slightly dependent on the target
machine. In particular, disable all but the most bulletproof strength
reductions.

Tasks 1,2 are essential to obtain suitable TTA-TCE unscheduled code.

Task 3 is almost as essential; task 4 is not essential, but it's necessary
before serious code transformations and effective backend can be implemented
in the TCE toolset.

The following sections describe each task in more detail.

Syscall layer rewrite
---------------------

System calls appear in the static libraries that are linked with TTA
program.  These are the C library and the compiler support library (gcclib).

One of the major discrepancies between TTA-Move and TTA-TCE "universal"
sequential architectures lies in the SW exception support:

TTA-Move defines a "trap" operation that receives as sole input an interrupt
code. Trap behaviour is undefined (whether it's a call or what), but it is
implied that any additional parameters required for a syscall are passed as
if the trap were a function call (that is, in dedicated registers r3-r6).

    CHECK: syscalls/traps in Move have a restriction whereby parameters
    can't be passed on stack?

TTA-TCE defines a "sys" operation (syscall) that receives two input
operands: the address of the exception handler (or, more likely, of the
exception handler vector) and the interrupt code. Operation "sys" expects
any additional parameters required for a specific syscall in the same
registers that would be used for a normal function call.

Example

Move:
       ARG1 -> r1  // if needed
       ARG2 -> r2  // if needed
       ...
       ARG8 -> f4  // if needed
       TRAP_CODE -> trap.t

TCE:

       ARG1 -> r1  // if needed
       ARG2 -> r2  // if needed
       ...
       ARG8 -> f4  // if needed
       TRAP_CODE -> sys.o
       TRAP_HANDLER -> sys.t


The implementation of the syscall layer at source code level will look like
this (example with write() system call):

  #include <sys/syscall.h>

  write() {
      __trap__(SYS_write);
  }

Which will be expanded to something like this:

  #define __trap__(n) { \
     asm("%0 -> sys.o        "\
         ##SYSCALL_HANDLER#" -> sys.t"\
        :: "i" (n));\
     }

The assembly code pattern "injected" into the compiler is highly dependent
on the frontend compiler. The example shown refers to a possible gcc version
of the frontend compiler.

This requires a customised set of source files for each frontend
compilers. It is a minor problem, which can be overcome in two ways:
. automatically generate the custom source code (Move solution)
. provide once and for all the syscall layer as TTA assembly or TPEF


By convention, every syscall handler address that is not legal in the target
memory system implies that the TTA simulator takes charge of system
emulation.  By further convention, a syscall handler address pattern "all
1's" is used to imply a emulation of system calls. For example, in case the
memory target address is 32 bits, the following syscall handler address
should be used: 0xFFFFFFFF.  (In practice, even if the address space is
smaller than 32 bits, which is usual, the address is illegal, so things work
independent of the size of the address space.)


Streamlining of base operation set
----------------------------------

The "base" operation set is the set of operations (no matter how costly to
implement in hardware!) that can be generated directly by all (but the most
stupid) frontend compilers directly from high level source language. For
example, an integer multiply is a base operation and is generated directly
by frontend compiler when a C "*" operator is encountered.

The base operations are not necessarily "simple" from the point of view of
hardware implementation. They are just easy to map from source code of
typical high-level languages (especially C).

One of the most annoying aspects of gcc-move is that the base operation set
includes a lot of optional operations that can be disabled or enabled with a
command line switch to the compiler driver.  Some of these operations (e.g.,
insb) have no reason but to make it possible to replace other optional
operations with emulation code.

Use of optional operations and command line switches in Move was motivated
by the fact that gcc can do a better job at optimising the code if
unavailable (disabled) operations are replaced early in the compilation
process (before all the code analysis phases).

The drawback of optional operations is that for every static library of TTA
code that is to be linked with users' application there must be a compiled
version for every possible base operation set.  Given N command line
switches to enable or disable an operation subset, the number of possible
combinations is 2^N for each library.

The approach chosen for TTA-TCE operation set is different. Ideally, there
should be only one base operation set, no optional operations.  The code
generated by the frontend compiler may use any base operation, even those,
such as integer-divide or load-byte, that can be unsupported by the target
machine. This means that, for any static library that may be linked to user
application, there is only one compiled version.

Those base operations that are not supported by the target architecture are
replaced with equivalent sequences of operations in the TCE backend,
inrrespective whether they come from a linked library or from user program.

For example, a bit-wise "not" operation (reverse all bits):

  r5 -> not.t
  not.r -> r6

can be trivially emulated by an exclusive or:

  r5 -> xor.o
  0xffffffff -> xor.t // all 1's pattern, whatever the bitwidth
  xor.r -> r6

Notice that some replacements (like this) can be done properly only when
detailed machine knowledge (such as, bitwidth of registers) is known.

This is the ideal, but some operations are problematic: they are so complex
to emulate, that they need a whole function. The function call replacement
itself is not that difficult.  The problematic bit is to select and link the
function with the emulation code. This can be done by invoking the TPEF
linker "invisibly", inside the application that does all these replacements
(let's call them "operation set trimming").

Base operations are divided into three (rather arbitrary) groups:
1. base and vital: can't run unrestricted programs without
2. base and easy to emulate: can be emulated by simple instruction pattern
3. base and emulated with functions: can be emulated by a function

In parenthesis, the original name in Move repertoire (if different)

Base, vital operations:

add  - integer add
sub  - integer subtract
ldw  - store (natural) word (ld)
stw  - store (natural) word (st)
eq   - compare equal
gt   - compare greater
gtu  - compare greated, unsigned
shl  - bit shift left
shr  - bit shift right, unsigned (logical)
shru - bit shift right, signed (arithmetic)
and  - bitwise and
ior  - inclusive bitwise or
xor  - exclusive bitwise or
int  - software interrupt (trap)
jump - absolute jump
call - absolute call

Base operations, easy to emulate:

min  - integer minimum
max  - integer maximum
minu - integer minimum, unsigned
maxu - integer maximum, unsigned
ldq  - load a quarter of word (ldb)
ldh  - load half word
ldd  - load double word
stq  - store a quarter of word (stb)
sth  - store half word
std  - store double word
sxqw - sign extend from quarter to word (sxbw)
sxhw - sign extend from half to word
neg  - arithmetic negation

Base operations, emulated by functions:

mul  - integer multiply
div  - integer divide
divu - integer divide, unsigned

addf - floating-point add
subf - floating-point subtract
mulf - floating-point multiply
divf - floating-point divide
eqf  - floating-point compare equal
gtf  - floating-point compare greater
cfi  - convert floating-point to integer (f2i)
cif  - convert integer to floating-point (i2f)

NOTE(1): Following Move operations must be removed from the operation
repertoire:

sxbh, insb, insh, extb, exth, lds, sts, mod, modu

NOTE(2): Some operations, although "easy to emulate", require rather long
instruction patterns: stq, sth, min, max, minu, maxu.

NOTE(3): There is a deep difference between Move load-store operations and
TCE load-store operations. In Move, the data type of the operation matters.
For example, ldd is only floating-point double words, and lds is load single
floating-point word, althogh it is identical to Move ld operation. In TCE,
however, the only thing that matters is the bitwidth of the data word loaded
or stored. Fractions and multiples of 2 are allowed, and there is no
difference between, for example, ldw used for single-precision floating
point and ldw used for integer words.

NOTE(4): In TCE, the following operations have 2 results.  The second
result, traditionally ignored, is described next:

mul   - upper part of integer multiplication
div   - reminder (modulo operation)
divu  - reminder, unsigned
add   - carry (1 if set, 0 if not set)
sub   - borrow (1 if set, 0 if not set)

In addition to operation set streamlining, some parts of the gcc-move code
generation specific file (move.c) should be changed. For example, we do not
support the switch that disables save-restore code around function calls,
nor code that manages frame pointer. This code is already disabled and
should be cleaned up.

NOTE(5): There could be other operations that are not directly supported by
the frontend compiler (thus, are not "base" operations), but still are
provided by the distribution because so common and useful. Some of these
operations could even be recognised by the TCE backend tools (code
transformations, scheduler) and replace other operations to make programs
more efficient. Examples:

jumpr - jump pc-relative
callr - call pc-relative
jumpp - jump, page-relative
callp - call, page relative
ror   - bit rotate right
rol   - bit rotate left
...


Enlarge register sets
---------------------

Gcc-move uses only 128 integer and 128 FP registers.  This should be
increased to, for example, 1024 registers (for each). Investigate if, in gcc
2.70, it's possible at all to define infinite register sets for the target
machine.

Disabling machine-dependent code "optimisations" 
------------------------------------------------

Most code optimisations (optimising transformations) are to some degree
dependent on the target machine.  The same "optimisation" can improve or
worsen the program performance depending on the characteristics of the
targetarchitecture.  However, the frontend compiler does not have a precise
idea of the target architecture (it assumes an "ideal" 1-bus TTA machine, as
described in TPEF specifications, wich is quite far from most real
machines).  For this reason, it is a very bad idea to let a third-party
compiler try any optimisation that is not totally machine independent.

Even an innocent-looking optimisation like constant folding could actually
worsen the code:

original:

  0x14 -> shl.t  // take 0x14
  8 -> shl.o     // multiply by 2^8 = 256
  shl.r -> r5    // store in r5

"optimised":

  0x1400 -> r5

Why? Because the target machine may have restricted/inefficient support for
long immediates but plenty of free move busses to perform the shl operation
well ahead. In best cases, such "optimisation" will not do much.

Most gcc optimisations (at least, in version 2.7 or gcc-move) can be
disabled by setting the options in local.h macro definitions. Vlado should
know more about this.

Strength reductions replace "expensive" operations with supposedly cheaper
operations. Like constant folding (even more so), strength reductions are
"gambles" based on unfounded assumptions about the target machine.

In gcc-move, there should be a file(?) or a set of macro definitions
specific for move (in local.h) that define the cost of operations relative
to some base unit. This "cost" is used by gcc to decide what to
strength-reduce.  In theory, if all costs are made equal, strength
reductions are disabled.

NOTE: It's not that strength reduction is a bad idea. Not at all! It's just
that it should be done later in the TCE backend (before or during
scheduling), when the tools have precise knowledge of the target
architecture (before) of even of its current state (during).


Support for "longjumps"
-----------------------

Longjumps are not going to be supported in TCE-gcc v1.0. It's not worth the
effort. Move doesn't support them either, although it provides the "stubs"
for a possible emulation in the simulator.

The point of longjumps is that they are relatively easy to emulate in
simulator code (just emulate saving and restoring of all machine state), but
require target-specific, complex software implementations if actually
simulated with real code of the target machine.

When we will start to work on it, someone could investigate how assembly of
a workstation (better sparc than IA32) looks like when longjumps are used.

Vlado has pointed out that longjumps might be used to implement exceptions
in C++. Therefore, (and for simplicity) we decided to drop support for C++
in the first frontend version.


Other details
-------------

There are a few more obscure details of the TTA-TCE architecture ABI
(Application Binary Interface) that should be done differently (= better)
than in Move "sequential" architecture.

- Passing/returning structs.

- Passing/returning small (<= 1 word) structs.

- Handling of varargs [NOTE FOR MYSELF: check again SUIF implementation]

These issues are documented in gcc porting manual, and the alternative I'm
talking about (which is not the one of Move) is often described as the
better alternative or the "more modern" alternative.

There may be other details like these that I don't remember now.  Some
details could be "discovered" by sifting through the configuration file
"local.h" of gcc-move "move" directory.

Because they affect the ABI, until all these "obscure" details are dealt
with, the sequential code will not be compatible with the exact
specifications (which are not yet written! this is a sort of draft thereof)
of the "sequential" TTA ABI.

This is not so serious.  It means that it can be expected for a while that
the code generated by gcc-tce revision of 12.8, for example, can't run
anymore linked with code generated with revision 15.7.


