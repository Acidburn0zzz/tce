\documentclass[a4paper,twoside]{tce}

\usepackage{pslatex}

\begin{document}
\author{Lasse Laasonen}
\title{TTA Processor Generator}
\ver{0.6.1}
\firstday{06.09.2004}
\lastday{27.04.2006}
% id number in S- sequence
\docnum{018}
% draft/complete/committed
\state{draft}

\maketitle

\chapter*{Document History}

\begin{HistoryTable}

 0.1    & 06.09.2004 & L. Laasonen &
 First incomplete draft. \\

 0.2    & 17.09.2004 & L. Laasonen &
 Added a lot of specifications and corrections. \\

 0.3    & 21.10.2004 & L. Laasonen &
 Minor changes. \\

 0.4    & 29.11.2004 & L. Laasonen &
 Changes in module communication and tasks. \\

 0.5    & 08.02.2005 & A. Cilio &
 Major revision. Added bibliography.\\

 0.6    & 10.02.2005 & A. Cilio &
 Changed module communication (L.\ Laasonen's remark).\\

 0.6.1  & 27.04.2006 & A. Cilio &
 Minor fixes.\\

\end{HistoryTable}

% Table of contents
\tableofcontents

% Document text
\chapter{INTRODUCTION}

\section{Purpose and Scope}

This document describes the software architecture of the TTA processor
generator (ProGe) of the TCE toolset. The focus of this document is on
the high-level design of the ProGe: its modular structure and the
functional specification of each module. For each module, dependencies
and communication with other modules are described.

\section{Acronyms and Abbreviations}

\begin{center}
\begin{tabular}{p{0.15\textwidth}p{0.85\textwidth}}
ADF  & Architecture Definition File \\
API  & Application Programming Interface \\
BEM  & Binary Encoding Map \\
FU   & Function Unit \\
GCU  & Global Control Unit \\
HDL  & Hardware Description Language \\
IC   & InterConnection network \\
IU   & Immediate Unit\\
MOM  & Machine Object Model \\
ProGe & TTA Processor Generator \\
RF   & Register File \\
UI   & User Interface\\
TCE  & TTA Codesign Environment \\
TTA  & Transport Triggered Architecture \\
\end{tabular}
\end{center}


\chapter{SYSTEM OVERVIEW}

The Processor Generator (ProGe) is a stand-alone application separated in
two main parts: a user interface (UI) that drives a top-level controller
module and the processor generator core.

The core functionality of ProGe is thus clearly separated from the user
interface. This approach follows a general guideline of the TCE project, and
is meant to simplify the replacement of the user interface and maximises the
amount of reusable code.

The high level architecture of ProGe is depicted in
Figure~\ref{fig:overview}. The core module accepts input data from external
source (see Section~\ref{sec:external-modules}) and generates a number of
HDL files that form a complete, synthesisable hardware description of a
processor that is compatible with the given target architecture.

The output of processor generator consists of a number of

\begin{figure}[tb]
\centerline{\psfig{figure=eps/Overview.eps,width=0.60\textwidth}}
\caption{Main modules of processor generator application.}
\label{fig:overview}
\end{figure}

The software architecture of the processor generator core consists of three
main modules:
\begin{enumerate}
\item%
  The netlist generator.
\item%
  The top-level HDL block generator.
\item%
  The HDL interconnection network and control path generator.
\end{enumerate}

\begin{figure}[tb]
\centerline{\psfig{figure=eps/Modules.eps,width=0.60\textwidth}}
\caption{Dependencies between modules of ProGe core.}
\label{fig:module-dependencies}
\end{figure}

The netlist generator creates an abstract representation of the target
processor. This representation consists of interfaces of building blocks
connected with each other. The netlist does not describe the contents of
each block, but contains information sufficient to retrieve or generate a
complete definition of the hardware block.

The HDL generator modules produce HDL files that, combined together, form a
complete hardware description of the target processor. The input data set of
the HDL generators is the netlist.

ProGe obtains all input data required from domain modules that create object
models out of external data sources. The models are the Implementation
Description, the Machine Object Model (MOM) and the Binary Encoding Map
(BEM).

Internally, all modules are directed by the controller and interact with
each other via a class interface.  For more detailed description of the
modules, see Chapter~\ref{ch:internal-modules}.

\section{External Modules}
\label{sec:external-modules}

% Overview of module from an external perspective:
% - dependencies with external modules-subsystems
% - IFs of external modules that are used
% - external (file) data formats used

Like nearly any other part of TCE, ProGe modules depend on the toolkit
library.
%
\note{ProGe should also need a specialised MachineTester \cite{} to verify
  that the given target architecture is synthesisable and complete}

Indirectly, ProGe depends on four external input data sets:
\begin{enumerate}
\item%
  ADF: Definition of the target architecture.
\item%
  IDF: Additional, implementation-specific data describing the building
  blocks that make up the target processor.
\item%
  BEM: Specification of the mapping between TTA instruction and the words
  that form the memory image of the program.
\item%
  HBL: Library of hardware descriptions of pre-designed processor building
  blocks.
\end{enumerate}

These dependencies are not directly visible to the core modules of
ProGe. Instead, ProGe depends on domain modules to translate the external
data files into domain object hierarchies.

The Machine Object Model is the main source data set for netlist
generator. The given MOM must be synthesizable.

The Implementation Description is another object hierarchy needed by the
netlist generator. This hierarchy specifies details of the processor
building blocks that cannot be found in MOM (non-architectural
information). The Implementation Description makes it possible to select one
of many alternative but architecturally equivalent implementations of the
same building block.

The Binary Encoding Map is an external object hierarchy needed by the module
that generates a hardware description of the interconnection network and the
control path of the target processor. This hierarchy defines how TTA
instructions are mapped into bit vectors, and how the bit vectors are
subdivided into fields, each dedicated to a different class of hardware
components.


\chapter{Internal Modules}
\label{ch:internal-modules}

\section{User Interface}

the User Interface module reads the arguments given by the user and sets up
the controller module. The UI module does not perform any activity actually
related to processor generator proper, but prepares the data structures and,
via the controller module, the ``work plan'' for core modules of the
processor generator. The UI module is a middleman between user and
the controller module.
%
\begin{quote}
  The first version of ProGe application will have a user interface based on
  command line.
\end{quote}

\section{Controller Module}

Controller module is the top-level entity that controls the core
functionality of ProGe to produce a processor description.  The Controller
module just calls the core modules of ProGe with appropriate parameters.
First of all, the Controller module builds the required object models that
provide the input data for the core modules: MOM, BEM and implementation
description.

It then initialises netlist generator, TTA top-level generator and the
IC/GCU generator with the appropriate parameters, including above mentioned
object models.  For example, it passes the netlist to the HDL generators.

\section{Netlist Generator}
\label{sec:netlist-generator}

The netlist generator produces the initial version of a netlist object, an
abstract, high-level representation of the target processor described in
Section~\ref{sec:netlist}. The netlist contains one block for each unit of
the target architecture.

The netlist generator does not create the interconnection network that
connects the blocks together. The interconnection network is added later by
IC/GCU generator. The netlist generator does not have all the information
necessary to create complete blocks for immediate units. It needs to obtain
some (non architectural) information from the IC/GCU generator.

The main data source of the netlist generator is MOM. For each unit defined
in MOM, the netlist generator searches a matching building block in the
Hardware Block Library. A new block corresponding to the block thus found is
added to the netlist. The ports of the netlist block that are not defined in
MOM (are not part of the visible architecture of the target processor) are
generated based on the metadata that describes each hardware blocks in HBL.
%
All names of nonprogrammable ports in a netlist block must match with the
real names of the corresponding block in HBL.

A HBL may contain several functionally equivalent (thus identical, from the
architecture standpoint) hardware description blocks with different hardware
architecture. In this case, the netlist generator needs additional
information to select one of the hardware architectures. The implementation
description module provides the information necessary in order to pick up
the appropriate implementation of hardware blocks from the HBL. Different
hardware architectures (or ``implementations'') of the same building block
are identified by a name string. The string must match in the three main
data bases that use it: the Cost Database~\cite{EstimatorSpecs}, the IDF and
the metadata in HBL~\cite{ProGeSpecs}.

\section{IC/GCU Generator}

IC/GCU generators produce a hardware description of the interconnection
network and the control path of the target processor.
%
By selecting alternative IC/GCU generators, the user is able try different
hardware architectures of the interconnection network and the control path
without recompiling the Processor Generator. To enable configurability at
run time, IC/GCU generators are implemented as plugin modules.

A IC/GCU generator performs three tasks:
%
\begin{enumerate}
\item%
  Complete the netlist representation of the target architecture.
\item%
  Generate HDL source code for the interconnection network.
\item%
  Generate HDL source code for the control unit and the control path of the
  target processor.
\end{enumerate}

Since the control ports of GCU and IC are highly dependent on the hardware
architecture of the interconnection network and the control path, which are
configurable at run time, the netlist generator has not enough information
to create the complete interface of GCU and IC netlist blocks. The GCU/IC
generator must add this information and complete the netlist.
%
For the same reason, the connections from GCU to IC, from GCU to units
and from IC to units must be added to the netlist by IC/GCU generator.

The decoding of long immediates is highly dependent on the implementation of
the control block. The IC/GCU generator must provide some information
necessary for the netlist generator to select the appropriate HBL entry for
each immediate unit.

The hardware description of the interconnection network is generated using
the data stored in MOM and BEM. The data path of the network, consisting of
connections between sockets, buses and bridges, are taken from MOM. BEM
makes it possible to generate the control path of the network. In addition,
the data stored in BEM is needed to generate a working GCU.

The output of a IC/GCU generator consists of one or more synthesizable HDL
files. The number of files depends on the module used. For example, GCU and
IC may be in defined in different files or in the same file. In turn, the
implementation of the interconnection network may be subdivided into several
files.

It is recommended that the designers of a IC/GCU generator separate
generation of IC and GCU into different, cooperating classes. This
separation promotes code reuse when the same GCU or IC generation process is
later used in another IC/GCU plugin module.

\section{Netlist}
\label{sec:netlist}

\begin{figure}[tb]
\centerline{\psfig{figure=eps/netlist.eps,width=0.60\textwidth}}
\caption{High-level structure of netlist.}
\label{fig:netlist}
\end{figure}

The netlist is the central, intermediate data structure of the processor
generator. It is an object model of the target processor in terms of
interconnected macro-blocks and their interfaces.
%
The interface of each block consists of input and output ports. Ports enable
one block to communicate with other blocks or with the off-core
components. The interface includes programmable ports as well as
implementation-dependent or nonprogrammable ports. For example, each unit
has ports for incoming clock and load signals, which are not directly
programmable.

The ProGe netlist of a processor includes all the units (RF's, FU's, IU's)
of the processor as well as the interconnection network, which is modelled
as a separate netlist block).
%
The netlist defines the connections between ports, too.

The ports of a netlist block are described and identified by the following
properties:
\begin{enumerate}
\item name
\item bit width
\item direction (input, output, bidirectional)
\end{enumerate}

The block in the netlist are clearly identified by the name of the hardware
declaration block and the name of the instance. The name of units are equal
to the names found in ADF. Each netlist block that represents a unit
contains a link to the file in HBL that describes the hardware
implementation of the block.

\section{Top-Level Generator}

The top-level generator takes the netlist produced by the netlist generator
and completed by the IC/GCU generator as source data. It converts the
interconnection of ports represented in the netlist to the target hardware
description language. The output of the module is written to a file called
`toplevel.vhdl'.
%
The top-level generator generates a hardware description of the connections
from GCU to other units, from IC to units and from GCU to IC. It also also
copies the needed HDL files from HBL to the output directory and renames the
hardware declaration blocks if necessary to avoid name clashes.

The top-level generator does not generate a hardware description of the
interconnection network; this is the task of the IC/GCU generator.

\section{Hardware Block Library}

The Hardware Block Library contains synthesizable definitions of hardware
blocks in a target HDL. It provides an API to search for, add and remove HDL
files.  HBL is a collection of HDL files organized in a well-defined
directory structure, described in~\cite{ProGeSpecs}, and a main module that
provides the API to access and modify the library.

\chapter{PENDING ISSUES}


% ------------------------------------------------------------------------

%  References are generated with BibTeX from a bibtex file.
\bibliographystyle{alpha}\cleardoublepage
%% Equivalent to a chapter in the table of contents
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}


\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
