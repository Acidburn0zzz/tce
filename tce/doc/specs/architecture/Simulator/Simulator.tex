\documentclass[a4paper,twoside]{tce}

\usepackage{pslatex}

\begin{document}
\author{Andrea Cilio}
\title{TTA Processor Simulator}
\ver{0.10.2}
\firstday{17.12.2003}
\lastday{27.07.2005}
% id number in S- sequence
\docnum{012}
% draft/complete/committed
\state{draft}

\maketitle


\chapter*{Document History}

\begin{HistoryTable}

 0.1    & 17.12.2003 & A. Cilio   &
 First incomplete draft. 1,2.1,3.1,4.\\

 0.2    & 03.02.2004 & A. Cilio   &
 Reorganised document structure, 2. Added 5 (empty), 2.3, 3.3.1.\\

 0.3    & 06.02.2004 & A. Cilio   &
 Tracing system, 5 (incomplete). Core module interfaces, 3.2.  Reorganised
 and expanded chapter 4.\\

 0.4    & 02.03.2004 & A. Cilio   &
 Module architecture, 2.1, 2.2, 2.4.  Simulator Controller, 3.1, 3.2, 3.3.
 Replaced tracing system with event handling system, chapter 5. Solved old
 pending issues.\\

 0.5    & 09.03.2004 & A. Cilio   &
 Renamed event handling system to simulation tracing system.\\

 0.6    & 10.03.2004 & A. Cilio   &
 Rewritten chapter 4, API moved to design document.\\

 0.7    & 10.03.2004 & A. Cilio   &
 API description and implementation issues to design document.  Added\ 
 (empty) Simulator Frontend chapter.\\

 0.8    & 03.07.2004 & A. Cilio   &
 Complete revision.  Solved design issue concerning memory tracking, 10.
 Added chapter on Machine State Model.\\

 0.9    & 07.10.2004 & A. Cilio   &
 Revision of Memory Module requirements.\\

 0.9.1  & 16.11.2004 & A. Cilio   &
 Clarified pending issues and Frontend responsibilities.\\

 0.10   & 12.01.2005 & P. J‰‰skel‰inen &
 Complete revision. Added missing modules. Removed information that is too 
 low level  for this document. \\

 0.10.1  & 05.07.2005 & A. Cilio  &
 Minor text and reference corrections.\\

 0.10.2  & 27.07.2005 & A. Cilio  &
 Reorganisation and revision of memory chapter.\\
\end{HistoryTable}

\tableofcontents



\chapter{INTRODUCTION}

\section{Purpose and Scope}

This document describes the software architecture of the TTA processor
simulator of the TCE toolset (Simulator).  The focus of this document is on
the high-level design of the Simulator: its modular structure and the
functional specifications of each module.  For each module, dependencies and
communication with other modules are described.


\section{Definitions}

\begin{description}
\item[Simulator]%
  The target architecture simulator of the TTA templated architecture.
\item[Memory Module]%
  Implementation of the Memory Model API provided together with the TCE
  toolset.
\item[Move]%
  Programmed data transport on a transport triggered architecture.
\item[Result Move]%
  Move that reads the result of an operation from a port of a function unit.
\item[Trigger Move]%
  Move that writes a port of a function unit and thereby initiates a new
  operation on that unit.
\end{description}


\section{Acronyms and Abbreviations}

\begin{table}[htb]
\begin{center}
\begin{tabular}{p{0.15\textwidth}p{0.85\textwidth}}
API   & Application Programming Interface.\\
CLI   & Command Line Interface.\\
GUI   & Graphical User Interface.\\
MAU   & Minimum Addressable Unit (of a memory address space).\\
MOM   & Machine Object Model.\\
MSM   & Machine State Model.\\
OSAL  & Operation Set Abstraction Layer.\\
TCE   & TTA Codesign Environment.\\
TPEF  & TTA Program Exchange Format.\\
TTA   & Transport Triggered Architectures.\\
UI    & User Interface.\\
\end{tabular}
\end{center}
\end{table}



\chapter{SYSTEM OVERVIEW}

\section{``Philosophy of Design''}

The Simulator is not a monolithic program.  Rather, it consists of a group of
cooperating but independent modules:

\begin{enumerate}
\item%
  Simulator Controller: controls the simulation of the TTA processor core.
\item%
  Machine State Model: the ``heart'' of the simulation; maintains the state
  of the TTA processor under simulation.
\item%
  Memory Model: simulate behavior of memory, allows experimenting with
  different types of memories.
\item%
  Tracking System: handles the saving and managing of tracking and profiling
  data produced in simulation.
\item%
  Debugging System: provides services for debugging the simulated programs.
\item%
  Simulator Frontend: hides the complexity of the simulator engine from user
  interfaces.
\item%
  Simulator User Interfaces: different user interfaces used to control the
  simulation, includes command line based and graphical user interfaces.
\end{enumerate}

\begin{figure}[htb]
    \centerline{\psfig{figure=eps/ModuleAPIs-module.eps,width=0.60\textwidth}}
    \caption{Dependencies between modules of the Simulator and external
    modules when the Simulator Controller module is integrated in a
    system-level simulator.}
  \label{fig:module-APIs}
\end{figure}

All modules are linked together and communicate via a C or C++ function call
API.  For more information on module communication, see
Section~\ref{sec:mod-comm}.

\paragraph{TTA Controller as SystemC module.}
External modules are clients of the Simulator Controller module.  A SystemC
model of a complete system on chip (possibly including the memory model, as
shown in Figure~\ref{fig:module-APIs}) can simulate a TTA processor core (or
even several working in parallel) by linking with the Simulator Controller
and wrapping its API with SystemC ports.\note{%
  pending issue \ref{sec:system-core-if}: simulator boundary with
  system-level simulators}

\paragraph{SystemC modules as external models of operations}
At a finer grain, a the SystemC system-level simulator can provide modules
that model the behaviour of certain operations.  In this case, the Simulator
Core invokes (indirectly) the external behaviour model of operations
implemented as module of the system-level simulator.  See~\cite{OSAL-specs}
for details.

\section{External Modules}

Like nearly any other part of TCE, the Simulator modules depend on the
toolkit library and various other TCE domain library modules.

\begin{enumerate}
\item %
  The Simulator Controller depends on following modules of the domain
  library:
  \begin{enumerate}
  \item Machine Object Model;
  \item Program Object Model;
  \item Memory Model
  \end{enumerate}

  These modules are used when preprocessing the simulated program to be
  executed in simulation.

\item %
  The Frontend is a client of Program and Machine object models, because it
  must set up these object hierarchies for the Simulator Controller when
  initializing simulation. Program is loaded from file system using TPEF
  Handling Module. Additionally, Frontend accesses the Memory models owned
  by Simulator Controller to provide means for user interfaces to examine
  memory data.

\item %
  Depending on the user interface implemented, a User Interface module of
  the Simulator may need additional libraries or modules. For example:
  \begin{enumerate}
  \item %
    a graphical UI also depends on the graphical library of TCE;
  \item %
    a command-line UI depends on an interpreter library.
  \end{enumerate}

\item %
  Machine State Model uses Operation Set Abstraction Layer to simulate
  behavior of operations.

\end{enumerate}


\section{Architecture of Databases}

The Simulator produces the following data bases:

\begin{enumerate}
\item Simulation profile.
\item Simulation trace.
\item Machine State snapshot.
\end{enumerate}

For the information contents of above databases, the reader is referred
to~\cite{SimulatorSpecs}, Chapter~5 ``Databases''.

\subsection{Simulation Profile Data Base}

The persistent format in which a simulation profile is stored is a TPEF
auxiliary section called \emph{Profile Section} (see TPEF specification
document~\cite{TPEF-specs} and TPEF Handling Module design
document~\cite{TPEF-design}). A simulation profile section consists of two
vectors. The elements of the first vector are procedure execution counts;
each element, in turn, consists of one or more execution counts. The
elements of the second vector are basic block execution counts.

The \emph{Profile} class contains the execution counts of a given TTA
program and consists of an ordered aggregate of execution counts. There are
two types of execution counts to the Profile class: \emph{basic block
  counts} and \emph{procedure counts}.

Profiling information is completely transparent to the program object
model~\cite{POM-design}; there exists no dependency between the program
object model and the simulation profile functionality.

\subsection{Execution Trace Database}

Simulation traces are structured as relational databases, and can be
accessed and manipulated by standard SQL queries (see~\cite{SimulatorSpecs}
for details on the accepted SQL standard and the external library
dependencies). Execution Trace Database stores information of simulation
events like executed instructions, stall cycles, bus activity, and memory
activity.

\subsection{Machine State Snapshot}
\label{ssec:state-snapshot}

The complete state of the target architecture at a given cycle during
execution of a program can be stored in a file.  This state is sufficient to 
resume simulation of program execution from the cycle following the 
snapshot as if simulation had started again from cycle zero.

A machine state snapshot consists of two parts:
\begin{enumerate}
\item %
  The machine state data proper.  The machine state, in this context, is the
  set of all storage elements of the target processor whose value can affect
  the processor behaviour, or that are otherwise visible (can be read by a
  program and thus potentially affect its execution flow).
\item %
  Auxiliary simulation data.  This data is strictly speaking not part of the
  machine state, but it is very convenient for a simulator client.  It
  includes but is not limited to:
  \begin{enumerate}
  \item total count of executed cycles;
  \item function call nesting level;
  \item date stamp at which the machine state snapshot was taken.
  \end{enumerate}
\end{enumerate}

\section{Module Communication}
\label{sec:mod-comm}

\begin{figure}[htb]
    \centerline{\psfig{figure=eps/ModuleCommunication.eps,width=0.50\textwidth}}
    \caption{Dependencies between modules of the Simulator.}
  \label{fig:module-comm}
\end{figure}

Figure~\ref{fig:module-comm} depicts the dependencies and the interaction
between the main modules that make up the standalone Simulator application
and other domain modules.  Other organisations, like the Simulator embedded
in a system model illustrated in Figure~\ref{fig:module-APIs}, are possible.

The Simulator modules communicate with their clients as follows:
\begin{enumerate}
\item %
  The Simulator Controller provides a function-based API to allow it to be
  driven by Simulator Frontend and external modules.  This API is described
  in Section~\ref{sec:core-api}.
\item %
  The memory module provides an API to access and modify memory as result of
  operations of the target architecture; this API is only accessible by
  operations (which are implemented in the OSAL module~\cite{OSAL-specs}).
  In addition, the memory module provides a ``service'' API. This API is
  used by external modules and Simulator Frontends for initialisation and
  memory modifications that appear invisible to the processor core (and are
  not traced). The memory interface is described in
  Section~\ref{sec:mem-api}.
\item %
  The Simulator Frontend is a layer between the Simulation Controller and
  the User Interface modules.  The purpose of the Frontend is to provide
  API for shared functionality:
  \begin{enumerate}
  \item %
    Initialisation of simulation environment.
  \item %
    Infrastructure for simulation tracking.
  \item %
    Access to processor state and memory state during simulation.
  \end{enumerate}
\item %
  The Command Line User Interface module recognises a set of command line
  options for configuring the simulation environment, described
  in~\cite{SimulatorSpecs}.
\item %
  The Graphical User Interface module configures the simulation environment
  from an external configuration file, described in ~\cite{SimulatorSpecs}.
\end{enumerate}


\chapter{SIMULATOR CONTROLLER}

The Simulator Controller module implements the simulation loop. It models
the fetch, decode and execute of TTA instructions.

\section{Overview}

The Simulator Controller has the following capabilities:
\begin{enumerate}
\item Cycle-by-cycle simulation of program execution on the target processor.
\item Notification of simulation events to external handlers.
\item External lock.
\item Access to global control state (global lock).
\end{enumerate}

The Simulator Controller builds, owns and controls the Machine State Model
(see Chapter~\ref{ch:msm}).

In addition, the Simulator Controller uses important object models
which it receives completely initialised and ready to use:
\begin{enumerate}
\item Machine Object Model.
\item Program Object Model.
\item Memory Model.
\end{enumerate}
%
The Controller uses only the read-only API of these object modules when
initializing its internal structures that access Machine State Model. It does not
modify them.

\section{Interfaces}
\label{sec:core-api}

The Simulator Controller presents a class interface for external clients.
This interface is used by the Simulator Frontend and by (external)
system-level simulators for which the interface provided by the Simulator 
Frontend is not sufficient.
%
Wrapping this interface around an adaptor layer (for example, to simulate
the ``ports'' of a hardware modelling language) may be required.

\subsection{Simulation Control}

From outside, the Simulator Controller is a ``black box'' that receives a
clock signal to advance execution of one or more clock cycles.

Clock advancing, step by step, is the typical method for controlling the
simulation process, but the Simulator Controller provides also a convenience
method to advance the simulation for an undefinite number of cycles.

Usually, a condition for stopping simulation becomes active in the middle of
the simulation process.  When this occurs, the Simulator Controller proceeds
until the current clock cycle is completely simulated.  Only then, the
Simulation Controller returns control to the invoking client and simulation
effectively stops.  In order to stop simulation, the Simulator Controller
provides also a method that ``books'' simulation stopping at the end of
current cycle.

\subsection{Locking}

In addition to ``normal'' processor condition, whereby instruction fetch,
decode and execution takes place in each cycle, the Simulator Controller may
simulate the condition whereby the processor is \emph{globally locked}. A
global lock halts fetch and decode activity: the program counter does not
proceed, the function unit pipelines are frozen and no data moves across the
transport busses.

A locked processor is not completely idle, however.  Those function units
that have direct connections with external modules (for example, the
load-store unit, which communicates with the memory) may receive results
from outside the core, and must update their pipeline state accordingly.
For this reason, the Simulator Controller must notify the clock cycle
advancement to function units even if the processor is locked.

The core processor may be locked by \emph{internal} or by \emph{external}
cause.  In the first case, the lock condition is raised by one of the
function units (for example, because the result of a load operation is not
available in time for the \emph{result move} to be completed.  In the second
case, the lock request comes from a core port that connects the processor
with the rest of the system.  An external lock may occur, for example,
because a module has not yet consumed the data produced by the processor and
stored in a buffer.

The external lock is the bare minimum support we can think of for
core-system communication.  A more flexible hardware mechanism is a
multi-bit port for message passing.  This type of ports, however, can be
implemented using user-defined operations, and defining a standard would
probably be too restrictive.



\chapter{MACHINE STATE MODEL}
\label{ch:msm}

\section{Overview}

In order to simulate the target TTA processor, the Simulator needs a model
of the machine state.  Unlike MOM, which is just a model of the static
properties of the target processor, the Machine State Model captures the
state of the target processor at any given cycle of simulation (see
Section~\ref{ssec:state-snapshot}, for a definition of ``machine state'').

The main client of MSM is the Simulation Controller.  MSM is not a purely
passive data structure.  It implements elementary aspects of the processor
behaviour, especially at the scale of single components.  For example,
pipeline advancing and triggering of a new operation as a result of writing
a function unit port are two elementary mechanisms that are modeled by MSM.
The simulation of operation behaviour, that is, the actual computation of the 
results of a given operation, is delegated to the Operation Set Abstraction 
Layer~\cite{OSAL-specs}. 

Conversely, the Simulator Controller models the higher level control of the
TTA processor.  For example, instruction fetch and decode.

In summary, MSM, Simulator Controller and Operation Set Abstraction Layer
cooperate to implement a complete dynamic model of the target TTA processor.



\chapter{MEMORY MODEL}
\label{ch:memory-model}

Even though \emph{Memory Model} is an independent domain library module, its
requirements are described here briefly, because Simulator is its main
client.

\section{Overview}

The Memory Model defines a very simple, general and flexible API to simulate
the behaviour and access the state of the memory system of target TTA
processors. ``General'' means that the interface will work whatever the size
of the ``natural'' word of the target processor architecture.  This API
lets clients inspect and modify the memory contents and emulate memory
accesses, nothing more. No accessor is provided for static properties of the
memory such as byte order (endianess) and MAU size.

The byte order and the MAU size are not necessarily the same for the host
computing system running the TCE toolset and the target TTA processor being
modelled by the toolset. The Memory Model must be aware of the byte-order of
the host computing system and adjust the MAU layout accordingly.

The TCE toolset distribution includes an implementation of the Memory Model
API, in this document simply referred to as Memory Module.  Any other
implementation that conforms to Memory Model API is a suitable replacement
of the Memory Module.

For the detailed design of the Memory Module and a description of all
non-trivial issues related to its implementation, see the Detailed Design
Document~\cite{MemoryModuleDesign}.

\section{Interface}
\label{sec:mem-api}

The Memory Model provides an API to request the following services:
\begin{enumerate}
\item %
  Load and store memory accesses.
\item %
  Transparent read and write of data blocks, needed for clients that modify
  or inspect the memory contents without affecting (or being affected by)
  the current memory state (lock condition, resource conflicts, etc).
\item %
  Test the memory control state.  The ``not available'' state indicates that
  a given memory access request cannot proceed because the memory is busy.
  A client can inspect the lock state of the memory, for example, to
  determine whether the processor core should lock.
\end{enumerate}

The Memory Model API is adequate to implement off-chip memory models with
complex behaviour and access latencies that depend on details that are out
of the scope of a TTA processor simulator (see pending issue
in~\cite{SimulatorSpecs}).

The Memory Module, however, does not model off-chip memories with complex
behaviour.  When such a model is needed, the Memory Module must be replaced
by an external implementation of the Memory Model.

\subsection{Architectural Interface}
\label{ssec:mem-apiarch}

The Memory Model provides a basic interface for loading and storing data as
result of operations of the target architecture.  In certain specialised
implementations of the Memory Model, these activities can be fully traced.
Any memory activity caused by operations of the target architecture are
sensitive to every condition that affects the hardware model (lock signals,
memory not being ready, port conflict).

Store operations are initiated by requesting a store access.  The data
passed with the request is not necessarily stored immediately.  The Memory
Model does not provide any method to establish if a store request has been
completed.

Load operations are split in two phases: request initiation and reading of
the data word coming from memory.  Reading attempts must be repeated until
the result of the load request is produced.

\paragraph{Request acknoledgment.}
The Memory Model, when available for new access requests, always accepts all
requests received in the current clock cycle. Even if some of the requests
given in a cycle cannot be initiated and cause the memory to become
unavailable, the requests are accepted and ``remembered'' by the Memory
Model.  A client never needs to repeat an access request to an available
Memory Model, even if the request is not immediately initiated by the
memory. Conversely, a request to a Memory Model that is not available is
completely ignored (it should not even be given).

\paragraph{Support for real-time cycle accuracy.}
To support cycle-accurate models, the API of the Memory Model provides also
a method to signal clock cycles.  This makes it possible, for memory model
implementations that need it, to precisely simulate stall cycles.

\paragraph{External Implementation.}
In case the Memory Model is implemented by an external memory module (that
is, not part of the TCE domain library, but modelled with an external
language, such as SystemC), the class that implements the memory model as
``seen'' by the TCE system would be just an ``adapter''. The communication
between the TCE system can be bidirectional, because the channel of
communication (modelling hardware ports at different levels of abstraction)
may trigger method invocation on both sides of the channel.

\subsection{Locking}

A memory module may be in a state whereby it cannot statisfy or even accept
new requests.  There are two types of denied requests:
\begin{enumerate}
\item%
  Denied initiation request: a \emph{trigger move} cannot be executed
  because the module cannot accept a new request.  There are two types of
  denied initiation requests: store request and load request.
\item%
  Result not ready.  The memory module has not yet delivered the requested
  data word.
\end{enumerate}

The implementation of the Memory Model is responsible for deciding whether
an initiation request can be accepted or not. Accurate modelling of this
aspect of the memory system is not critical if precise simulation of the
stall cycles is not needed.

The result-ready condition is managed by clients of Memory Model and not by
memory itself.  This condition indicates that the result of given memory
read access is available.

For example, the pipeline model of a function unit could be responsible for
keeping enough state to tell when the result of an operation is invalid
(incomplete).  When reading of an incomplete value is attempted, the global
lock signal should be raised.  Conversely, when the result value of a memory
read access is available, reading it will not cause the processor to lock.

Note that there is no general method for knowing in advance the number of
stall cycles caused by a memory access request. The stall condition is
determined and signalled by the memory model on each cycle of simulation
based on overall system state. The general system state depends on
conditions such as, for example, execution of operations that perform
input/output and external modules trying to access the same memory, that
cannot be anticipated.

\subsection{Service Interface for Data Transfers}
\label{ssec:mem-apiservice}

The memory module provides an interface for transferring data to and from
the memory in a way that is ``transparent'' (that is, undetected) to the
processor core.

These transfers take place immediately and do not affect the lock state of
the memory. These transfers should not trigger any additional bookkeeping
activity of the simulation process (tracing, profiling).

The data transfer service interface can be used by any client.  Below are
listed two typical uses.
\begin{enumerate}
\item%
  Bring the memory to a state suitable for starting or continuing simulation
  without having to precisely simulate all the activity that brings the
  memory to such state.
\item%
  Inspect and alter the contents of the memory without affecting the state
  of the system being simulated.
\end{enumerate}

An example of the first case is the initialisation of the stack data area
dedicated to the environment.  In this case, the activity emulated is that
of a host controlling processor or that of an operating system.

An example of the second use is the request for a machine state snapshot
coming from the Simulator Frontend, which requires to read the entire
memory (or at least the part that has been affected by the TTA program
execution).

\section{Error Handling}

Possible error conditions occur when:
\begin{enumerate}
\item %
  An unlock request is sent to a memory that is not locked.
\item %
  An access request is sent to a memory in a locked state.
\end{enumerate}

The Memory Module Design Notes~\cite{MemoryModuleDesign} discuss how these
error conditions are handled.


\chapter{TRACKING SYSTEM}
\label{ch:tracking}

The Tracking System implements tracking of simulation activity by
means of event notifications.  The level of simulation tracking is
configurable.

The Tracking System consists of independent tracker objects that
handle simulation events and store the information of them to permantent
storage.

The Simulator Frontend is the responsible for creating and initializing the
tracker objects when a tracking functionality is enabled. 

The Simulator Controller and Memory Modules are the producers of
the simulation events caught by the Tracking System tracker objects.
The following events are generated by them:
\begin{enumerate}
\item %
  Clock cycle update.
\item %
  Program Counter register update (data transport).
\item %
  Memory access by means of operations of the architecture operation set
  (see Section~\ref{ssec:mem-apiarch}).
\end{enumerate}
%
The first 2 events are generated by the Simulator Controller, the last event
is generated by tracked memory modules.


\chapter{DEBUGGING SYSTEM}

\emph{Debugging System} provides services for implementing basic program
debugging functionality. The main service of it is managing of breakpoints.
Breakpoints are implemented by using the same event notification system as
\emph{Tracking System} does. When a condition for stopping the simulation
because of a breakpoint occurs, \emph{Simulator Controller} is told to stop
after finishing simulation of the current instruction.

\chapter{SIMULATOR FRONTEND}

A ``faÁade'' class that hides the complexity of the Simulator engine.
Provides an interface sufficient for user interfaces to initialize and
control the simulation.

\chapter{SIMULATOR USER INTERFACES}

User interfaces use \emph{Simulator Frontend} to control the simulation. For
starters, two user interfaces are provided. One purely textual,
interpreter-based, and one graphical.

\section{Simulator Control Language Interpreter}

This module is used to provide the interpreter functionality for the
Simulator Control Language, as described in~\cite{SimulatorSpecs}.

It is used both by the Command Line Interface and the Graphical User
Interface. In the latter, it's used to provide a ``console window'' which is
essentially a command line interface inside the graphical interface.

\section{Simulator Command Line Interface}

Textual, interpreter-based user interface to the simulator. Using this
interface, simulation can be controlled purely using only command line
parameters, or in ``interactive mode'' which provides scripting and
debugging support.

Uses \emph{Simulator Control Language Interpreter} to provide the scripting
support.

\section{Simulator Graphical User Interface}

Graphical user interface is provided for ease of use and visuality. It
should be noted that \emph{Simulator GUI} uses also the \emph{Simulator
  Control Language Interpreter} to provide the same scripting support and
command log provided by the command line interface.


\chapter{REJECTED ALTERNATIVES}

% Rejected alternatives for (parts of) the design should be listed here with
% the reasoning and date the alternative was dumped. For future reference.

\begin{description}
\item[02.03.2004 --- Singleton \emph{HandlerManager}] %
  The \emph{HandlerManager} class is not a Singleton, even if it is unlikely
  that more than one object will be needed by a Simulator.  Simply, there is
  nothing to be gained in this case from a Singleton, and maybe later it
  could be convenient to be able to have multiple instances.  For example,
  it could be useful to implement a very efficient way to disable all event
  handlers by replacing the current \emph{HandlerManager} with an empty one.

\item[02.03.2004 --- Atomic State on Lock Condition] %
  To ensure that a processor is never in a state whereby part of the data
  trasport of current cycle are completed and part (due to an intervening
  lock) are not, the Simulator Controller must perform a preliminary check
  for potential lock conditions on all operations (both reading from a
  source and writing to a destination) before initiating the actual
  simulation.

  The advantage of this is that the state is predictable and completion of
  the instruction, when lock condition expires, is easy.  The main problem
  is that simulation may be a lot slower due to the preliminary lock test on
  each transport.

  Model accuracy is not an issue here.  Architectural models cannot be
  realistic.  In real processors, transports occur in parallel, and the
  signal on a transport bus when a lock occurs depends on physical
  characteristics of the implementation.

\item[05.07.2004 --- Client That Directly Notify Memory Access Events] %
  The problem with notifying memory accesses is that the client (OSAL)
  should not be aware of low level details such as the memory tracking
  system.  For example, a ``smart'' memory system may accept multiple load
  requests to the same address in the same cycle and merge the requests into
  one actual access.  In this case, precise tracking requires that the
  access event be one only, but the OSAL client cannot know details like
  these about the memory system, nor whether another event notification for
  the same address has already occurred in the same cycle.

\item[07.10.2004 --- Use ``service'' API to model external write accesses]%
  Any client of the Memory Model should use the architecture-visible methods
  to model actual accesses. Thus, even activity due to off-chip modules
  should be fully modeled and tracked.  For example, emulation of activity
  due to an external DMA module should be modelled by means of
  architecture-visible read and write request methods.

  The ``service'' API should be reserved only to transparent memory accesses
  due to, for example, debugging functionality provided via user interface.
\end{description}

\chapter{IDEAS FOR FURTHER DEVELOPMENT}

% Ideas that are not part of the design yet but that might be added in the
% future are listed here. This is to have ideas written down somewhere.
% This list should contain the date of addition, the idea described briefly
% and the inventor of the idea.

% Example:
%
% 18.11.2003 . . . -P.J‰‰skel‰inen

\chapter{PENDING ISSUES}

% Pending issues concerning this design, a sort of TODO list.
% This chapter should be empty when implementation of this module/subsystem
% is completed.

\section{Interface Between TTA Processor Simulator and System Model}
\label{sec:system-core-if}

Either the Simulator Frontend module or the Simulator Controller alone may
be linked with an external system-level model for simulation of a complete
system. Which of the two is the right choice?


%\chapter{MAINTENANCE}

% This chapter treats the problem of extending the design with new
% capabilities that fit in a predefined framework.

% For example, in case of the TPEF module, this chapter could describe the
% steps that must be taken in order to add a new Section subclass and/or a
% SectionReader subclass.

% Remove this chapter no obvious and standardised way to extend the design
% with new capabilities exists.


% ------------------------------------------------------------------------

%% Remove this part if there are no references.  Usually there will be at
%% least a reference to the functional specifications of the same module.

%  References are generated with BibTeX from a bibtex file.
\bibliographystyle{alpha}\cleardoublepage
%% Equivalent to a chapter in the table of contents
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}


\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
