\documentclass[a4paper,twoside]{tce}
\usepackage{pslatex}

\begin{document}

%  cover page
\author{Atte Oksman}
\title{Machine Object Model}
\ver{0.5}
\firstday{10.05.2004}
\lastday{03.08.2005}
\docnum{025} % id number in S-sequence
\state{draft} % draft/complete/committed

\maketitle


%  Document History
\chapter*{Document History}

\begin{HistoryTable}

 0.0    & 10.05.2004 & A. Oksman &
 Initial version.\\
 0.1    & 21.05.2004 & A. Oksman &
 First version with some actual information.\\
 0.2    & 28.05.2004 & A. Cilio  &
 Revision of the entire document. Removed ``Maintenance'', ``Rejected
 Alternatives'' and ``Pending Issues'' chapters.\\
 0.2.1  & 03.06.2004 & A. Oksman &
 Added some information to ``Implementation'' and refactored
 ``Interfaces''.\\
 0.3    & 09.06.2004 & A. Oksman &
 Added information to ``Interfaces'' and ``Implementation''. Minor
 refactoring elsewhere.\\
 0.3.1  & 12.06.2004 & A. Oksman &
 Added pictures.\\
 0.3.2  & 14.06.2004 & A. Cilio  &
 Minor revision of the text.\\
 0.3.3  & 16.06.2004 & A. Oksman &
 Updated according to Andrea's advice.\\
 0.4  & 15.09.2004 & A. Cilio  &
 Major revision of the text. Reintroduced description of component
 registration. Changes to document structure. \\
 0.4.1 & 21.10.2004 & L. Laasonen &
 Changed name of MDF to ADF. \\
 0.4.2 & 02.02.2005 & M. Lepistö &
 Fixed some method parameters. \\
 0.4.3 & 10.07.2005 & A. Cilio &
 Assigned document number. \\
 0.5   & 03.08.2005 & A. Cilio &
 Reorganised document. Added \emph{HWOperation} latency.\\

\end{HistoryTable}


%  Table of contents
\tableofcontents


%  Introduction
\chapter{INTRODUCTION}

\section{Purpose and Scope}

This document describes the Machine Object Model (MOM) of TTA Codesign
Environment (TCE). The document describes how the Machine Object Model
is designed and the reasons behind the design.

The document is meant to be a reference to developers and maintainers who
need information on how the Machine Object Model is designed or how to use
it. After reading the document, the reader should know what are the main
components and their responsibilities.

This document is not the primary source of information for developers of
client applications using MOM. Developers may obtain a useful overview of
the object model from this document, but the bulk of the interface
documentation is found in the API reference hypertext manual.

\section{Definitions}

\begin{description}
\item[Machine] %
  A target TTA processor in the TCE environment. A machine can be
  represented in an XML file or as objects in the program itself.
\end{description}

\section{Acronyms and Abbreviations}

\begin{table}[htb]
\begin{center}
\begin{tabular}{p{0.15\textwidth}p{0.85\textwidth}}
  ADF   & Architecture Definition File\\
  ADFF  & Architecture Definition File Format\\
  API   & Application Programming Interface\\
  DOM   & Document Object Model\\
  MOM   & Machine Object Model\\
  ProDe & Processor Designer\\
  TCE   & TTA Codesign Environment\\
  TTA   & Transport Triggered Architecture\\
  XML   & eXtensible Markup Language\\
\end{tabular}
\end{center}
\end{table}


%  Model Architecture
\chapter{MODEL ARCHITECTURE}

\section{Motivation and Philosophy of Design}

The TTA Codesign Environment needs a convenient representation of the target
TTA processors involved in the codesign process. The Machine Object Model
was designed to represent target TTA processors in terms of objects of the
toolset implementation language. This object model consists of a collection
of tightly related, yet partly independent objects. These objects represent
(sub)components of the target TTA processor and present a specialised public
API. \emph{Machine} is the root object of the model and offers the
highest-level API to access the target processor properties. The most
important clients of MOM are the Simulator~\cite{SimulatorSpecs},
~\cite{SimulatorModDesign}, the Processor Estimator \cite{EstimatorSpecs}
and the Processor Designer (ProDe), described in~\cite{ProDeDes}.

\subsection{Independence of Processor Components}

The object model is designed so that even partial or incomplete target
processors can be represented and handled. This requires that the objects
that represent processor parts should be as independent as possible, and
a missing part should not affect the rest of the machine significantly.

\subsection{Support for Permanent Storage Format}

A machine can be read from and written to an XML file. A mechanism for
transforming the data contained in an XML file into an object hierarchy and
vice versa was needed. The \emph{Serializer} design
pattern~\cite{SerializerPattern} was chosen.

\subsection{Object Model Consistency}

A major aspect of the machine object model design is the concept of a
\emph{permanent consistent state}.  A permanent and consistent state means
that the objects that make up the target processor model and their relations
are kept in a state that represents a valid (but possibly incomplete) target
processor.

Due to the complexity of the processor model and the practical constraints
of real-world processor architectures, the processor model can be, at some
points, an incomplete and meaningless target configuration in many ways.

For example, a function unit without any supported operations is clearly
useless, but it is valid as intermediate, incomplete machine component, so
it is allowed. On the other hand, a chain of busses connected by bridges
must form a linear sequence, that is, there cannot be several busses
``branching off'' a given bus. The latter constraint is permanently
enforced, and bus chains with branches are never allowed, not even as
temporary configurations of a machine object model being edited.

\section{External Modules}


\subsection{Architecture Definition Input Ouput Module}

Architecture Definition File is the external form of the Machine Object
Model suitable for permanent storage (see Section~\ref{sec:mom-adf}).  Most
of ADF input output functionality is integrated within MOM, as Serializer
specialisations: \emph{ADFSerialiser} and \emph{Serializable} refinements.
There are no external modules for ADF input output; MOM's only required
external service for completing the ADF input output functionality is
toolkit's \emph{XMLSerializer}.

\subsection{Xerces C++ Parser}

Xerces C++ Parser~\cite{Xerces} is used to read and write XML files
describing the target processor.

The Xerces library is used to parse the XML file and create a Document
Object Model (DOM,~\cite{DOM}) from it. DOM is basically an object model of
XML documents, a tree structure with the elements of the XML file as nodes.
The Xerces library can also perform the opposite process: convert a DOM into
an XML file.

Individual components and subcomponents of the machine object model that
ultimately must read their information contents from a permanent support
implement the \emph{Serializable} interface.  Serializable objects are
responsible for converting (in both directions) between their information
contents an \emph{ObjectState}~\cite{ToolkitDesign} tree.  Thus, a
\emph{Serializable} implementation can update its state with the data in an
\emph{ObjectState} tree, or can create an \emph{ObjectState} tree that
exactly represents is current state.

Any \emph{ObjectState} tree created by a \emph{Serializable} can be easily
converted into a DOM tree (or vice versa, a DOM tree can be converted to an
\emph{ObjectState} tree) by a \emph{Serializer}.

\section{Architecture of Databases}
\label{sec:mom-adf}

The definition of a target processor architecture can exist in two forms:
either as text data in an XML file or as an instance of the Machine Object
Model.

The XML file describing architecture of a machine, called Architecture
Definition File (ADF), must conform to a precise format, which is
described in the document Architecture Definition File Format for a New TTA
Design Framework (S-003)~\cite{ADF-specs}.

Figure~\ref{fig:TargetModel} shows the classes that make up the target
processor object model and their main relations.

\begin{figure}[htb]
\centerline{\psfig{figure=eps/TargetModel.eps,width=1.2\textwidth}}
\caption{Class diagram of the target processor architecture model.}
\label{fig:TargetModel}
\end{figure}


% Model design
\chapter{MODEL DESIGN}

\section{Overview}

The machine object model has a root class called \emph{Machine}. A
\emph{Machine} instance represents a transport triggered processor
architecture in its entirety and provides the main public interface to
access its components. A machine consists of machine parts (aptly
represented by the class \emph{MachinePart}) that are divided into two
categories, \emph{Component} and \emph{Subcomponent}.
Figure~\ref{fig:MachineParts} shows the inheritance diagram of machine
parts.

Components are independent pieces of the machine. Some of them can exist on
their own, without begin registered and controlled by a \emph{Machine}. A
subcomponent, on the other hand, always belongs to one component, and cannot
exist on its own (see subcomponent registration, in
Section~\ref{ssec:sec:machine-imp}). Subcomponents are bigger parts of a
component that can be represented as individual objects. There can be
multiple instances of most component types in a given machine.  Similarly,
for almost every type of subcomponent there can exist multiple instances
that are owned by one component.  Subcomponents are therefore usually kept
in variable-sized containers.

\begin{figure}[htb]
\centerline{\psfig{figure=eps/MachineParts.eps,width=1.0\textwidth}}
\caption{Inheritance of Machine Parts.}
\label{fig:MachineParts}
\end{figure}

\section{Interfaces}

\subsection{Machine}

The public interface of \emph{Machine} class is the main interface provided
to clients of the machine object model.

The interface includes functions to set, unset and access the global control
unit of the machine.  \emph{Machine} implements the \emph{Serializable}
interface, so it provides methods for saving its data contents to an
\emph{ObjectState} tree, or for loading it from an \emph{ObjectState} tree.


\subsubsection{Component Identification}

Machine components are identified by a unique name string. Components of
different types are always treated as different objects, regardless whether
their name is different or not. For example, a machine instance cannot have
two bridges with the same name registered to itself, but it can have a bus
and a bridge with the same name.

\subsubsection{Adding and Removing or Deleting Components}

\emph{Machine} class provides methods for adding and removing components.
Certain types of components cannot be simply removed, but must be deleted
altogether.  Removing a component means simply unregistering it from its
owning machine, and applies to components that can exist as independent
instances.  Deletion applies to components that cannot exist ``on their
own'', that need to be registered to a machine.  Deletion implies automatic
unregistration.

The methods to add components have the following format:
\begin{description}
\item[void add\emph{ComponentType}(\emph{ComponentType}\&
\emph{componentInstance})] %
\end{description}

The methods for removing or deleting machine components are similar:
\begin{description}
\item[void remove\emph{ComponentType}(\emph{ComponentType}\&
  \emph{componentInstance})] %

\item[void delete\emph{ComponentType}(\emph{ComponentType}\&
  \emph{componentInstance})] %

\end{description}

\subsubsection{Random Access to Components}

The \emph{Machine} class provides a safe mechanism to access individual
components it contains.
%
These components are stored in internal containers hidden from the clients.
In order to still allow random access to components, \emph{Machine} returns
navigators which are handles to the internal containers.

There are many types of navigator, one for each machine component type of
which multiple instances can exist in a machine. The methods to obtain
navigators have the format:
\begin{description}
\item[\emph{ComponentType}Navigator \emph{componentType}Navigator()] %
\end{description}

The methods return a new navigator object which then can be used to
access the components themselves using the following simple API:
\begin{description}
\item[int count()] %
  Returns the item count in the container.
\item[bool hasItem(const string\& name)] %
  Returns true if a component with the given name is found, otherwise false.
\item[\emph{ComponentType}* item(int index)] %
  Returns an item with the given index in the container.
\item[\emph{ComponentType}* item(const string name)] %
  Returns an item with the given name.
\end{description}


Please see the TCE API documentation for more detailed information on the
API of \emph{Machine}.
\section{Implementation}

\subsection{Machine}
\label{sec:machine-imp}

The first step for creating a Machine Object Model is to instantiate an
object of \emph{Machine} class. A client can then begin to create
individual machine components and subcomponents. The machine parts derived
from \emph{Component} class can exist on their own (some of the component
types must be registered to a machine object, however). Machine parts
derived from the \emph{Subcomponent} class are owned by an object of a
\emph{Component} class' subclass, and cannot exist on their own.

All machine components must be registered to the machine before they can be
connected to each other.

The methods that remove or delete (sub)components keep the overall machine
object model consistent. For example, when a bus is removed from a machine,
all socket connections to the bus are deleted. No dangling references to
the removed bus are left inside the machine and the components that remain
registered to it. All other references to registered components are
maintained.

\subsubsection{Component Registration}

A \emph{Machine} instance keeps strict control  on all its components. To
avoid the risk of corrupted (or ``dangling'') object references, components
cannot have references to each other unless registered to a machine.

When a component adds an association to another component, both components
must be already registered to the same machine. If only one or neither
component is registered, or if the components are registered to different
machines, an attempt to add an association between the components results in
a run time error.

When a component is unregistered from a machine, the owning machine takes
care that all references to and from other components are destroyed.
Therefore, unregistered component don't have any references to other
components.

A machine automatically unregisters any component
before deleting it, therefore it also guarantees that no ``dangling''
references (basically, pointers to deleted objects) can be created.

\subsubsection{Subcomponent Registration}

The association between a component and its subcomponent(s) is locally
managed: the machine the component is registered to (if any) does not play
any part in the process of adding or removing a subcomponent.

When a subcomponent is deleted, its destructor notifies its parent component
that it must remove any reference to the subcomponent. Conversely, the
methods of a component for deleting one of its subcomponents must also take
care of destroying the subcomponent. As a result, subcomponents cannot exist
outside a component. Their constructor has the parent component as one of
the parameters.

This tight relation between components and subcomponents is a design
liability. It makes components and subcomponents too dependent on each other
and forces both to present a public interface that is wider than it ought to
be. [[elaborate on run time checks in another section]]

\subsection{Bus}

These main steps are required to construct a valid bus.

\begin{enumerate}
\item %
  Create an object of the \emph{Bus} class.
\item %
  Create an object of the \emph{Segment} class and give the created bus to
  it as a parameter. The segment is now connected to the bus.
\item %
  Create an object of the \emph{Socket} class.
\item %
  Connect the socket to the segment with method \verb|attachBus()|.
  Alternatively, method \verb|attachSocket()| of \emph{Segment} class can be
  used.
\item %
  Set the direction of the socket with method \verb|setDirection()|.  The
  direction should be tested and possibly explicitly set after the socket
  has been attached to a bus.  This is due to the fact that, when a socket
  is attached to a new bus, its direction is sometimes automatically updated
  in order to make it consistent with the direction of other sockets
  attached to the same bus.  Conversely, when the socket is detached from
  all buses, its direction is undefined.
\item %
  Create an object of the \emph{Guard} class and give the \emph{Bus}
  instance to it as a parameter.
\end{enumerate}

Unregistered busses cannot be associated with bridges.

\subsection{Bridge}

A bridge has two attributes: the source and the destination bus.

A bridge cannot be separate from the machine, it is connected to the machine
when it is created.  A bidirectional bridge is represented as two
unidirectional bridges.

\subsection{Unit}

Classes \emph{ImmediateUnit}, \emph{RegisterFile}, \emph{FunctionUnit} and
\emph{ControlUnit} are all specialisation of the base class \emph{Unit}.
All unit subclasses share the same name space for the name attribute. Also,
all units possess subcomponents of type \emph{Port}. Ports are subcomponents
and therefore are always attached to a unit; the port constructor receives
the unit the port is to be added to as a parameter.

\emph{FunctionUnit} objects have their own special kind of ports, which are
instances of the \emph{FUPort} subclass.

The global control unit can only have up to three ports, each with a
predefined name.  These names are reserved, and are used to identify the
specific function of each port.

\subsection{HWOperation}

Class \emph{HWOperation} models operations of the operation set. This class
aguments the model provided by OSAL \emph{Operation}~\cite{OSAL-specs} with
implementation-specific information. Since the implementation of each
operation belongs to a single function unit, the \emph{HWOperation} objects
are owned by function units.

\subsubsection{Operation Latency}


Operation latency is a complex property of an operation implementation and
its function unit. Latency is measured from the reference input of the
operation, which is always the sets-opcode terminal (usually, but not
necessarily, an input). An operation is started (by convention) when the
sets-opcode terminal is written or read.

\emph{Definition: latency of an operation output.}
%
Difference between the cycle in which the operation is started and the
earliest cycle in which the output contains the correct result of the
operation.

By `cycle' here it is meant the ``virtual time'' seen by the program. In
other words, the latency does not include any potential cycles in which the
entire processor is stalled because the result is not ready and a read is
requested.

Operation inputs have also a latency of sorts. This ``latency'' is defined
input slack.

\emph{Definition: slack of an operation input.}
%
Difference between the latest cycle in which the operation input can be
written if it is to affect the operation and the cycle in which the
operation is started.

Typically, the input slack is zero, that is, the operand must be set at
latest in the same cycle in which the operation is started. When an input
has a positive latency, it means that it can be scheduled \emph{after} the
sets-opcode terminal is accessed.

Negative slack is not allowed. In theory, negative slack is applicable to
triggering inputs (non-triggering inputs are read only after the sets-opcode
input is moved, hence it is impossible that they are required even before
the operation is known). A triggering input with negative slack must arrive
some cycles \emph{before} the operation even is started.

Given an operation with $N+1$ inputs (one of which sets-opcode) and $M$
outputs, the complete latency description requires $N$ slacks for inputs and
$M$ latencies for outputs.

Latency and slack are modelled by the following methods:
\begin{description}
\item[latency(out : int) : int]%
  Return the latency of the operation output identified by the index
  \emph{out}.
\item[slack(in : int) : int]%
  Return the slack of the operation input identified by the index \emph{in}.
\item[latency() : int]%
  Return the maximum latency of the operation (computed between all
  outputs).
\end{description}

\section{Error Handling}

Errors are signalled by exceptions. No assertion failure should ever occur
as a consequence of incorrect input data coming from client code.



\chapter{HELPER CLASSES}

This chapter describes parts of the MOM package that, strictly speaking, are
not part of the machine object model, but rather are helper classes that
encapsulate useful services that should be generally available to MOM clients.

\section{Overview}

\section{Interfaces}

\subsection{MachineTester}

\emph{MachineTester} is a fundamental helper class.  It allows to maintain
the machine object models in a consistent state. Single instances of
\emph{MachineTester} can be used to test whether certain complex
modifications to the machine object model can be performed without
corrupting the overall state of the model.

For example, a tester can check whether a connection between two components
(for example, a bus and a socket) is acceptable.


% Ideas for further development
\chapter{IDEAS FOR FURTHER DEVELOPMENT}


% Bibliography
\bibliographystyle{alpha}
\cleardoublepage
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}


\end{document}
