\documentclass[twoside]{tce}
\usepackage{pslatex}

\begin{document}
\author{Tommi Rantanen}
\title{TTA Processor Designer}
\ver{2.6}
\firstday{03.11.2003}
\lastday{15.03.2006}
% id number in S- sequence
\docnum{009}
% draft/complete/committed
\state{complete}
\maketitle

% Version history
\chapter*{Version History}

\begin{HistoryTable}

0.1  & 03.11.2003 & J. Sertamo     &
1.1-1.4\\

0.2  & 05.11.2003 & J. Sertamo     &
1.5, 2, 5\\

0.3  & 19.11.2003 & T. Rantanen    &
Added format for Chapter 4.\\

0.4  & 21.11.2003 & T. Rantanen    &
Generation of the document changed.\\

0.5  & 25.11.2003 & A. Mets‰halme  &
Added View documentation.\\

0.6  & 26.11.2003 & T. Rantanen    &
Added architecture description.\\

0.7  & 27.11.2003 & A. Mets‰halme  &
Added Document documentation.\\

0.8  & 27.11.2003 & L. Laasonen    &
Added XMLParser and Options documentation.\\

0.9  & 01.12.2003 & T. Rantanen    &
Added Framework and Dialog documentation.\\

1.0  & 01.12.2003 & T. Rantanen    &
Final fine tuning.\\

1.1  & 05.12.2003 & T. Rantanen    &
Minor fixes according to inspection.\\

1.2  & 16.02.2004 & A. Mets‰halme  &
View package updated.\\

1.3  & 16.02.2004 & L. Laasonen    &
XML Parser package updated.\\

1.4  & 17.02.2004 & T. Rantanen    &
Document package updated.\\

1.5  & 18.02.2004 & VP. J‰‰skel‰inen &
Framework and Dialog packages updated.\\

1.6  & 18.02.2004 & T. Rantanen    &
Final fine tuning.\\

2.0  & 17.03.2004 & J. M‰ntyneva   &
Updated from course format to TCE project template.\\

2.1  & 25.03.2004 & J. M‰ntyneva   &
MacEdit changed to ProDe. \\

2.2  & 10.05.2004 & J. M‰ntyneva   &
Added Maintenance Chapter. \\

2.3  & 11.05.2004 & A. Mets‰halme  &
Added documentation of the processor layout
                                 algorithm.\\
2.4  & 15.06.2004 & VP. J‰‰skel‰inen &
Updated model and dialog documentation.\\

2.4.1 & 21.10.2004 & L. Laasonen   &
Renamed MDF to ADF.\\

2.5   & 07.02.2006 & A. Cilio      &
State: complete. Reformatting, minor corrections.\\

2.6   & 15.03.2006 & Veli-Pekka J‰‰skel‰inen &
Removed documentation of MachineCanvas implementation details,
which were moved to the wxToolkit design document. Added documentation
on how ProDe utilizes the MachineCanvas module of
wxToolkit library.\\
\end{HistoryTable}

\tableofcontents



\chapter{INTRODUCTION}
\label{cha:intro}

\section{Purpose and Scope}

This is the design document for TTA Processor Designer. The purpose of this
document is to describe the detailed design of the Designer. This document
will describe the Designer in such complete and precise technical manner, that
implementation work will be straightforward.

Intended readers for this document are the project group and the Customer.
The most significant target group is the implementation team of the project
group, but other group members as well as the technically oriented
Customer are potential readers of this document.

This document describes the modular structure and class hierarchy of the
Designer. Additionally, general design principles, internal and external
interfaces and used data structures are defined.

This document is based on~\cite{ProDeReq}, which defines the functional
requirements of the Designer.


\section{Product and Environment}

The name of the product is TTA Processor Designer and the purpose is to provide
hardware engineers an easy-to-use graphical way to edit processor designs.
The product and environment are described in detail in~\cite{ProDeReq}.

\section{Definitions, Acronyms and Abbreviations}

The list of abbreviations and definitions can be found in
Table~\ref{tab:abbrev}. Table~\ref{tab:style} lists typographic
conventions used in this document.

\begin{table}[htb]
\caption{Abbreviations and definitions}
\label{tab:abbrev}
\begin{center}
\begin{tabular}{|p{0.23\textwidth}|p{0.70\textwidth}|}
\hline
ADF           & Architecture Definition Format\\
\hline
API           & Application Programming Interface\\
\hline
canvas        & The area of the Designer window to which the processor
                block figures will be drawn.\\
\hline
Customer      & TUT, Institute of Digital and Computer Systems\\
\hline
Designer      & TTA Processor Designer\\
\hline
GUI           & Graphical User Interface\\
\hline
MVC           & Model-View-Controller\\
\hline
TCE           & TTA Codesign Environment\\
\hline
TTA           & Transport Triggered Architecture\\
\hline
UML           & Unified Modeling Language\\
\hline
XML           & Extensible Markup Language\\
\hline
\end{tabular}
\end{center}
\end{table}

\begin{table}[htb]
\caption{Typographic conventions used in this document}
\label{tab:style}
\begin{center}
\begin{tabular}{|p{0.30\textwidth}|p{0.63\textwidth}|}
\hline
\textbf{Style} &\textbf{Purpose}\\
\hline
\textbf{boldface}†& dialog names\\
\hline
\emph{italic}     & command/action names\\
\hline
[brackets]†         & references\\
\hline
\end{tabular}
\end{center}
\end{table}

\section{References}

References are listed at the end of the document.

\section{Overview}

This document is divided into eight chapters. Chapter~\ref{cha:intro}
sets the scope and purpose of this document along with explanations
of used terms, notions and acronyms.

Application environment is described in Chapter~\ref{cha:overview}. This
includes the description of the physical environment as well as the
software environment, standards and legal issues.

Chapter~\ref{cha:architecture} is one of the most important chapters in
this document. It explains the overall architecture of the Designer along
with the design philosophy used. Additionally, architectural decisions
such as modular structure along with used data structures are
described in this chapter.

Chapter~\ref{cha:package_design} is the other chapter of major importance.
This chapter specifies the detailed design of all the packages introduced
in Chapter~\ref{cha:architecture}. General description, interface and
implementation guidelines are provided for each package.

Some special solutions need to be utilized in the Designer. These are explained
in Chapter~\ref{cha:tech_solutions}.

Ideas rejected during the course of the project are introduced in 
Chapter~\ref{cha:rej_ideas}.

Chapter~\ref{cha:further_devel} presents ideas for further development
of the Designer.

Unknown or open issues for the project group are described in
Chapter~\ref{cha:open_issues}



\chapter{OVERVIEW OF SYSTEM}
\label{cha:overview}

\section{Application Environment}

The Designer is part of the TCE project at the Institute of Digital and
Computer Systems at Tampere University of Technology. One of the
goals of the TCE project is to provide a useful suite of SW tools to
help in TTA processor design.

Being a part of a larger project, the Designer must be compatible with the
other tools and data formats used in the TCE project. These requirements are
discussed in~\cite{ProDeReq}.

End users of the Designer are hardware and software engineers with varying
knowledge of TTA processor design. The Designer should be easy to use for
newcomers, but still provide efficiency to experienced designers. All of the
end users are expected to have adequate skills in using graphical tools in
Unix environment.

\section{Interfaces}

TCE applications are based on a modular design. They are standalone
executables that may inter-operate with each other in a fashion similar to
that of many common Unix shell commands. There could be an overarching
common integrated development environment that controls all the
applications, but each application is designed as a separate, independent
utility.

The most important interfaces for the Designer are the input and output
packages described in~\cite{ProjectPlan} and the interface to X Windows
windowing environment, which is described in detail in
Chapter~\ref{cha:package_design}. Additionally, the supported processor
description format, ADF, must be considered as the most important interface
to the other applications in the TCE project. ADF specification can be found
in~\cite{ADF-specs}.

The Designer is a single user program and does not support networking.

\section{Hardware Environment}

Hardware environment for the Designer is described in~\cite{ProDeReq}.

\section{Software Environment}

Target environment for the Designer is Red Hat Linux 9. This will also
be the main development and the sole testing environment. The Designer
will be designed to work flawlessly with the version of XFree86 windowing
environment and the most common web browsers and other applications
provided by Red Hat Linux 9.

\section{Main Restrictions for Implementation}

The Designer will be programmed in C++ according to~\cite{CodingGuidelines}.
All the documentation and code comments will be written in English.
American English is preferred over British English.

\section{Agreements and Standards}

Data in XML format will be specified according to~\cite{XMLSpec}.

All diagrams will be drawn using UML notation, unless compelling reasons
state otherwise. No specific version of UML notation is fixed, but
generally adopted style is recommended.



\chapter{ARCHITECTURE DESIGN}
\label{cha:architecture}

\section{Philosophy of Solution}
\label{sec:philosophy}

The architecture of the Designer follows the principles of the
Document/View architecture~\cite{wxWin_doc_view} of the
wxWidgets~\cite{wxWindows}. Because wxWidgets is the implementation
library for the graphical part of the Designer, it has huge effect on
the architecture. Naturally, ignoring the support of the
implementation library does not make any sense.

The architecture is highly based on the object oriented design
philosophy. The Designer must support it also because the whole TCE
utilizes object oriented design.

The Document/View architecture is based on the MVC architecture which
is widely used in programs supporting GUI. The major principle of
MVC is to distinguish the visual part, i.e., view, the actual data,
i.e., model, and the communication between them, i.e.,
controller. Usually the separation between different parts is not as
clear as described here.

In wxWidgets, the Document represents the Model of the MVC. The View is
the same in both architectures. The Controller of the MVC is divided
into both Document and into View in Document/View architecture but
mainly it is in the View. Mixing the Controller and the View of the
MVC model is quite characteristic for the architecture. Therefore
wxWidgets does not make any difference between them.

\section{Database Architecture}

-

\section{Software Architecture and Packages}

\begin{figure}[htb]
\centerline{\psfig{figure=eps/PackageDiagram.eps,scale=0.5}}
\caption{The package diagram of the TTA Processor Designer.}
\label{fig:packages}
\end{figure}

The architecture described in Section~\ref{sec:philosophy} is
divided into packages depicted in Figure~\ref{fig:packages}. The
packages are described in detail in Chapter~\ref{cha:package_design}.

Framework package described in Section~\ref{sec:framework} contains
wxWidgets classes required for the Document/View
architecture. Framework package is using Dialogs package for
communicating with the user, View package to ask it to draw the
canvas, Options for loading, saving and storing the configurations of
the user, and Document package to obtain the actual data.

View package described in Section~\ref{sec:view} consists of the class
hierarchy which represents the blocks drawn on the canvas. View
package is using Document package to obtain the data to represent on
the canvas.

Dialogs package described in Section~\ref{sec:dialogs} implements the
dialogs required in the Designer.

Document package described in Section~\ref{sec:document} consists
of the data to be visualized in the Designer.

XML Parser package described in Section~\ref{sec:xmlparser} implements
a general way to read and write XML files.

Options package described in Section~\ref{sec:options} contains
classes to store user-defined configurations of the Designer. XML Parser
package is used to read the configuration file which is in XML format.

\section{Error and Exception Handling}

Exception handling is included within class descriptions in
Chapter~\ref{cha:package_design}.



\chapter{DETAILED DESIGN}
\label{cha:package_design}

In this chapter, each package is described in detail. Documentation of
the package contains the description of the package, class diagram and
references of the most important classes. Refer to~\cite{TCEDoc} for
the references of all the classes of each package.

\section{Framework}
\label{sec:framework}

\begin{figure}[htb]
\centerline{\psfig{figure=eps/FrameworkClassDiagram.eps,scale=0.5}}
\caption{Class diagram of the Framework package.}
\label{fig:framework_class_diagram}
\end{figure}

Classes in the Framework package depicted in
Figure~\ref{fig:framework_class_diagram} implement the wxWidgets
Document/View architecture~\cite{wxWin_doc_view} described briefly in
Section~\ref{sec:philosophy}. Implementation is done by overriding a
minimal set of member functions of the wxWidgets Document/View
architecture base classes. Some of the classes need no specialization,
and the wxWidgets implementation can be used. The classes that need no
specialization are:
\begin{itemize}
\item wxDocTemplate: Template for an ADF document.
\item wxDocManager: Application level manager for templates.
\item wxCommandProcessor: Command processor for commands that modify
      documents.
\end{itemize}

The classes derived from the wxWidgets Document/View architecture base
classes are:
\begin{itemize}
\item MDFDocument: Derived from the wxDocument class.
\item MDFView: Derived from the wxView class.
\item MainFrame: Derived from the wxDocMDIParentFrame class.
\item ChildFrame: Derived from the wxDocMDIChildFrame class.
\end{itemize}

In addition to the classes mentioned above, the Framework package
includes the ProDe class representing the Designer application, and
the Canvas class. The Canvas class is a scrollable window on which
the MDFView object draws the component figures.

A detailed description of the wxWidgets Document/View architecture,
including documentation of the base class interfaces can be found in
the wxWidgets manual~\cite{wxWin_doc_view}.

The Framework package contains also the Request class whose instances
are used to communicate with EditPart objects in the View, and the
Command classes which are instantiated and executed among others when
an EditPart receives a Request object it can handle.

The Framework instantiates Requests and gives them a type that
corresponds to the action the Request refers to. For example when the
user selects a machine block on the canvas and performs the
\emph{Modify Block} action, a modify Request is instantiated and sent
to the selected EditPart. The EditPart acts according to the type of
the Request, delegating to the EditPolicy objects installed on it.

The Commands generated from Requests by EditPolicy objects are inherited
from the ComponentCommand class. These commands are: DeleteBridgeCmd,
DeleteBusCmd, DeleteFUCmd, DeleteGCUCmd, DeleteIUCmd, DeleteRFCmd,
DeleteSocketCmd, ModifyBridgeCmd, ModifyBusCmd, ModifyFUCmd,
ModifyGCUCmd, ModifyIUCmd, ModifyRFCmd and ModifySocketCmd.

These Command classes have specialized responsibilities that
correspond to different actions performed on different machine blocks
on the canvas. They ask the user for information by popping up
appropriate dialogs and then invoke the Model object to make the
changes in the Document. For example, ModifyFUCmd instantiates an
FunctionUnitDialog object to get the information the user wants to
change. Then Model's methods are called accordingly to apply the
changes.

The Commands that can be added to the toolbar and the menus are inherited
from the EditorCommand class. These commands are: AboutCmd, AddASCmd,
AddBridgeCmd, AddBusCmd, AddFUCmd, AddGCUCmd, AddIUCmd, AddRFCmd,
AddSocketCmd, CloseDocumentCmd, EditAddressSpacesCmd, EditConnectionsCmd,
EditOptionsCmd, FitHeightCmd, FitWidthCmd, FitWindowCmd, LoadOptionsCmd,
ModifyComponentCmd, NewDocumentCmd, OpenDocumentCmd, QuitCmd,
SaveDocumentAsCmd, SaveDocumentCmd, SaveOptionsAsCmd, SaveOptionsCmd,
SelectCmd, UserManualCmd, VerifyMachineCmd, ZoomInCmd and ZoomOutCmd.

%\input{class/classProDe.tex}
%\input{class/classMainFrame.tex}
%\input{class/classChildFrame.tex}
%\input{class/classMDFView.tex}
%\input{class/classMDFDocument.tex}
%\input{class/classCanvas.tex}

\section{View}
\label{sec:view}

The View package is responsible for visualizing the processor on the
canvas. It also handles the Requests sent from the Framework according
to GUI actions performed by the user, and forwards possible changes to
the Document. More precisely, the canvas objects (called EditParts)
that represent the visible blocks of the processor respond to Requests
corresponding to \emph{Delete Block} and \emph{Modify Block}
actions. These Requests are converted to Commands that change the
Document. See more detailed description below. Refer to
Figure~\ref{fig:view_class_diagram} for the class diagram of the View
package.

\begin{figure}[htb]
\centerline{\psfig{figure=eps/ViewClassDiagram.eps,width=1.0\textwidth}}
\caption{Class diagram of the View package.}
\label{fig:view_class_diagram}
\end{figure}

The basis of the view package is the MachineCanvas module, which is part
of the wxToolkit library. This document has focus on describing how the
MachineCanvas module is utilized in ProDe. For details
of the MachineCanvas implementation, see wxToolkit design notes document.

The main class in the View is EditPart. Every visible machine block
has a corresponding EditPart instance. They bridge the View and the
Document by mapping the Document to its View and determining what kind
of changes should be made to the Document. EditParts take instances of
the Request class from the Framework. These Requests are generated by
user interaction, for example when selecting block and performing the
\emph{Modify Block} action. If the selected EditPart can handle the
Request, a Command object is generated and returned for the Framework
to execute.

Commands will popup dialogs and invoke the appropriate Model instance
as necessary to alter the Document. They have specialized
responsibilities, for example the ModifyFUCmd class knows which
dialogs to pop and how to invoke Model to correctly reflect the
changes the user makes in the Document. See
Section~\ref{sec:framework} for more information about different
Commands.

EditPolicy objects determine how an EditPart behaves when it receives
a Request. Several EditPolicies can be installed in an EditPart. If an
EditPart receives a Request it cannot handle, simply nothing
happens. For example a function unit can handle modify Requests but
connections can not.

EditPolicies are the most important way of implementing
application specific behaviour of the MachineCanvas. ProDe implements specialized
EditPolicies for most of the compomenent types. ProDe classes inherited
from the EditPolicy base class are: ProDeBridgeEditPolicy, ProDeBusEditPolicy,
ProDeFUEditPolicy, ProDeFUPortEditPolicy, ProDeGCUEditPolicy,
ProDeIUEditPolicy, ProDeIUPortEditPolicy, ProDePortEditPolicy,
ProDeRFEditPolicy, ProDeRFPortEditPolicy, ProDeSegmentEditPolicy and
ProDeSocketEditPolicy.

MachineCanvas module utilizes EditPartFactory to apply correct edit policies
for EditParts. ProDe implements ProDeEditPolicyFactory which is derived
from the EditPolicyFactory base class. ProDeEditPolicyFactory is responsible
for adding ProDe-specific edit policies for the MachineCanvas edit parts.

Another important way of customizing MachineCanvas behaviour are
CanvasTools, which determine which requests are sent to the edit parts
when mouse is used on the canvas. ProDe implements two different mouse
tools. Select tool is simple tool for selecting components on the canvas.
Connect tool is a tool for connecting sockets to busses and sockets to
ports by clicking them on the canvas. Connect tool sends ConnectRequest to
the EditParts. ConnectRequest is a ProDe specific request type, derived from
the Request baseclass.


\section{Dialogs}
\label{sec:dialogs}

Dialog package consists of all dialog classes derived from the wxDialog
class. These include all custom dialogs, which can't be implemented
with wxWidgets common dialogs. The dialogs which can be implemented
with the common dialogs, and are thus excluded from this package are:
\begin{itemize}
\item The \textbf{Open} and \textbf{Save As} file selector dialogs
      will be implemented using wxFileDialog.

\end{itemize}

Component dialogs form the largest group of the custom dialogs. For
each component type in the machine object model, exists a component
dialog. The component dialog is used by both, the commands adding a
new component to the model, and the commands modifying an existing
component. Pointer to the modified machine component is passed to
the dialog constructor as a parameter, and the dialog modifies the
MOM objects directly. Modification legality checks are done using
the MachineTester class, which is part of the MOM. 

A component dialog consists of the dialog window, any number of
controls for the user input and a possible validator for each control.
The validators are used for two purposes. They move data between the
controls and the dialog attributes, and validate the control data if
necessary. Currently all validators are basic wxWidgets validators, which
only filter unwanted characters and transfer data between dialog controls
and the corresponding dialog attributes. The final validation of the
user input is done in the command event handler for the OK button.

Some of the components can't be selected on the Canvas, and therefore
can't be modified directly. These subcomponents are managed by the
parent component. The parent component's dialog opens a subcomponent
dialog when the user modifies or adds subcomponents. The parent
component dialog handles the subcomponent dialogs, and the subdialog
structure is invisible to the command modifying the parent component.

The other custom dialogs include \textbf{Verify} dialog to display a
simple radio button selection, and \textbf{Options} dialog for
modifying application level options. These dialogs have similar
functionality to the component dialogs, and they are used also by the
Commands to query user input.

The dialog package also includes the following simple dialogs for generic
purposes: \textbf{Confirm} dialog for querying user confirmation for an
action, \textbf{Error} dialog for displaying short error messages,
\textbf{Information} dialog for displaying short informative messages and
the \textbf{Warning} dialog for displaying short warning messages.

The dialog window layout is done with standard wxSizers. However, the
dialogs will be implemented using a graphical dialog design tool
called wxDesigner, and the actual sizer structure is generated by the
wxDesigner. Therefore the sizer structures layouting the dialogs are
omitted in this document.

\section{Document}
\label{sec:document}

The Document package contains the data to be visualized on the canvas.
The document package doesn't wrap the machine object model behind an
interface, and therefore modifications to the machine are done by
directly modifying the machine object returned by the Model's getMachine
method.

Refer to %Figure~\ref{fig:document_class_diagram}
for the class diagram of the package.

\begin{figure}[htb]
\centerline{\psfig{figure=eps/DocumentClassDiagram.eps,scale=0.55}}
\caption{Class diagram of the Document package.}
\label{fig:document_class_diagram}
\end{figure}

The Undo/Redo functionality is implemented in the Model class. Before
a modification to the machine is done, the machine state have to be 
saved to the Model's undo stack using the pushToStack method.
The modification can then be undone using the popFromStack method.
%\input{class/classModel.tex}
%\input{class/classComponentDescriptor.tex}
%\input{class/classDescriptorField.tex}
%\input{class/classEditCommand.tex}
%\input{class/classMachineState.tex}

\section{XML Parser}
\label{sec:xmlparser}

\begin{figure}[htb]
\centerline{\psfig{figure=eps/XMLParserClassDiagram.eps,width=0.7\textwidth}}
\caption{Class diagram of the XML Parser package.}
\label{fig:XMLParser_class_diagram}
\end{figure}

The XML Parser package provides tools to read and write XML files. It
reads and writes XML files by means of Xerces C++~\cite{Xerces}. The
main class of the package is XMLSerializer. It acts as a converter
between ObjectState tree and DOM~\cite{DOM} tree and has ability to
create a DOM tree from an XML file and write an XML file from a DOM
tree. It can also validate the read files against an external
Schema~\cite{Schema} file.

ObjectState is a class which with its child ObjectStates describes the
state of an object. Objects intended to be serialized must implement
the Serializable interface. They must be able to create themselves
from an ObjectState object and create an ObjectState object from its
contents. It is the responsibility of the classes in the object model
to create an object model from the ObjectState tree. Refer to
Figure~\ref{fig:XMLParser_class_diagram} for the class diagram of the
package.

Options are serialized using the ProDeOptionsSerializer. It is
derived from XMLSerializer and it uses the functions of XMLSerializer
to read and write the XML files but it also acts as an ObjectState
tree converter. When reading XML files, the XMLSerializer creates an
ObjectState tree which matches one-to-one with the structure of the
XML file. The task of the ProDeOptionsSerializer is to convert the
tree to the form which can be read by ProDeOptions. Of course it has
to do the opposite when writing the configuration file.

%\input{class/classObjectState.tex}
%\input{class/classSerializable.tex}
%\input{class/classXMLSerializer.tex}
%\input{class/classProDeOptionsSerializer.tex}

\section{Options}
\label{sec:options}

\begin{figure}[htb]
\centerline{\psfig{figure=eps/OptionsClassDiagram.eps,width=0.6\textwidth}}
\caption{Class diagram of the Options package.}
\label{fig:options_class_diagram}
\end{figure}

The Options package contains classes to represent the options and
settings of the Designer. The class ProDeOptions is the main class. It
consists of ProDeToolbarButton objects which represent buttons in
the toolbar. It consists also of ProDeKeyboardShortcut objects which
represent keyboard shortcuts of the Designer. Each of the classes
implement the Serializable interface because options are going to be
serialized into the configuration file. Refer to
Figure~\ref{fig:options_class_diagram} for the class diagram of the
package.

%\input{class/classProDeOptions.tex}
%\input{class/classProDeToolbarButton.tex}
%\input{class/classProDeKeyboardShortcut.tex}



\chapter{SPECIFIC TECHNICAL SOLUTION ALTERNATIVES}
\label{cha:tech_solutions}

The Designer will not handle mission-critical data and is only one
application in the chain rather than a complete system. Accordingly, no
special fault tolerance has been introduced in the program. Tasks such as
creating backups or recovering from external error situations have been left
to the end user.

Customer's strive for genericness resulted to modular design, which will
enable easy configurability and addition of new features. Ideas for
further development of the Designer are presented in~\cite{ProDeReq}.

Portability is also taken into consideration, when designing the Designer.
Platform dependent solutions are avoided. Selecting wxWidgets as the
implementation library keeps the portability of the GUI as portable as
possible.

The software tools used in the project are listed in~\cite{ProjectPlan}
along with their respective versions.



\chapter{REJECTED ALTERNATIVES}
\label{cha:rej_ideas}

\section{Script Controller}

The basic idea of the Designer is to modify the machine description
visualized. The first idea was that each modification is applied
through the script, i.e., script would be part of the controller.

Rejected idea is depicted in Figure~\ref{fig:command_chain} as 1Cntrl
solution. The selected idea is 2Cntrl approach.

\begin{figure}[htb]
\centerline{\psfig{figure=eps/CommandChain.eps,width=0.7\textwidth}}
\caption{Command chain alternatives of the Designer.}
\label{fig:command_chain}
\end{figure}


The advantages of the 1Cntrl approach according to Customer are:
\begin{enumerate}

\item Modularity, interface insulation: The interface between GUI part of
Control and Modifier is purely a textual language. This means more
modularity and less sensitivity to function API change. All graph
display applications that I know in the public domain use this
language interface.

\item Design consistency: By putting the Interpreter right in the
middle of the control chain, we ensure that every edit action can be
expressed in the MacScript language, because there is no other way to
get to Modifier. If you have Modifier responding to two different
control front-end then who ensures that you don't add some
functionality that does not exist in MacScript?

\item (Debatable, see also disadvantage 1) The script interface to editing
Machine means that macro, script execution and maybe also command
history and undoing function are almost for free: it all boils down
to executing scripts.  About the undo function, we would store
anti-commands as scripts. In the end, in all cases the GUI wxCommands
simply give a script to the Interpreter, that invokes the
EditCommands.

\item (Minor) Only one module (Interpreter) is client of
Modifier. In fact, Modifier and Interpreter become one thing (or,
Modifier becomes part of Interpreter). This however is a drawback.
\end{enumerate}


The disadvantages of 1Cntrl approach according to Customer are:
\begin{enumerate}

\item Handling history and undoing at level of scripts means that
these functionalities should be moved outside the Interpreter/Modifier
area, into the front-end part of the control, because the
history/macro and undo have to be interpreted. This, on the one hand,
makes sense when you simply interpret a script in "batch mode", you
don't need history or undo, but on the other hand means that some
wxCommands have to keep track of history and undo. History is not
problematic, just store the data structure or the MacScript
strings. Undo functionality is harder to provide without requiring
wxCommand to access Machine. It can work out with collaboration
between wxCommands and Intepreter/Modifier. On one hand, Modifier
are the place closest to Machine and thus more appropriate to have the
functionality of undoing. On the other hand, the undo functionality is
a need of the MacScript client, not a general need of the interpreter,
so it makes sense to put it outside.

\item (advantage of 2Cntrl) what you get from wxCommands or dialogs is
a data structure very close to parsed MacScript language, which would
be the same produced by Interpreter. This is efficient, and both
Interpreter and wxCommands (the "control front-end") use exactly the
same interface to command Modifier.

\item (advantage of 2Cntrl) clean separation of Interpreter (= stupid
translator of strings to data structure) and Modifier, that
is responsible for (re)playing the commands. This is convenient if
Modifier is responsible for do(), undo(), redo() interface.

\item Two extra steps between the GUI action and the edit Machine:
ScriptGenerator and Interpreter.

\end{enumerate}

The advantages of 1Cntrl solution were not convincing enough. Thus,
2Cntrl approach will be implemented.



\chapter{MAINTENANCE HINTS}
\label{cha:maintenance_hints}

\section{Programs}

The following subsections describe what should be kept in view when
making various changes in the software or its external data
structures.

\subsection{Adding a New Machine Component}

The changes needed in the Designer when a new machine component is added
depend on the type of the component. Adding a new unit type is quite
simple. Only a new Factory needs to be written for creating EditParts
of the new unit. That Factory is to be registered in the
MDFEditPartFactory. Then the new unit can be read in the same way as
the other units.

Giving general instructions for adding other types of components is
impossible. It depends on the component's effect on the processor
layout. If the layout is drastically changed, in the worst case, even
the EditPart data structures must be redesigned. This is due to the
complexity of the layouting algorithm caused by the very strong
dependencies between the components. Only the units have a fixed
position, other components depend on the positions of other components
and many other factors. On the other hand, adding new subcomponents to
existing components is relatively easy, if their position depends only
on their parent component.

What must at least be done when adding a new component is to write a
Figure for it. It determines the visualization of the component. Also
a Factory is required for creating EditParts for the new component
type. The Figure can be specialized from the abstract Figure class,
the Factory should be inherited from either the Factory class or
the EditPartFactory class.

Of course, if you want to be able to modify the component via the GUI,
appropriate dialogs and actions must be added. See
Section~\ref{hints_user_interface} for notes on making changes to the
user interface. Section~\ref{hints_adding_actions} discusses issues
concerning adding new actions.

Also, DescriptorConversion class needs to know how to form a
ComponentDescriptor of the component, so a new function must be added
that can handle the new component. Finally, you must add a constant
for the new component to ModelConstants.

Adding a new component type also requires support from the Model
side. Refer to Section~\ref{hints_adding_mom_operations} for
instructions for adding new operations that modify the machine object
model.

\subsection{Adding a New Document Type}

Adding a new document type is quite complex. Depending on the document
type, you should be prepared to write new Document and View packages
supporting the document almost from scratch. Of course it is most
likely that some of the existing code can be reused. Also you might
need to have completely different options for the new document
type. That requires changes in the Options package. The dialogs may
require changes, depending on the differences in the component types.
The Framework package will remain in most parts untouched, except for
the EditorCommands that must correspond with the requirements of the
new document type. Some control on which type of document is currently
open must also be added.

The ChildFrame class, which is used as a frame for each document's sub
window, has lots of document type specific functionality, such as
setting the menu items available for the document type. Currently the
ChildFrame is implemented only one document type in mind. If a new
document type is added, the ChildFrame needs to be split into
different document frame classes for each document type. The current
ChildFrame can be used as a frame for ADF documents, but similar
class, derived from the wxDocMDIChildFrame, has to be written for each
new document type.
 
The document subframes are created by the document's view component, and the
MainFrame can handle the subframes on the base class level. Therefore adding
new child frame types for the MainFrame shouldn't cause serious problems.

Refer to~\cite{wxWindows} for more information on wxWidgets and its
support for multiple document types.

\subsection{Adding a New Action}
\label{hints_adding_actions}

A new action requires a corresponding command class derived from the
EditorCommand base class. The new EditorCommand must be added to
CommandRegistry in the MainFrame constructor. Also a constant for the
name, abbreviation and ID of the action must be added to
ProDeConstants.

\subsection{Adding a New Item in the Options}

Adding new options or modifying them requires of course modifications
to the options dialog. Section~\ref{hints_user_interface} discusses
issues concerning changes in the user interface.

Also ProDeOptions class must be modified because it stores all the
options used in the Designer. If new options are added, they must be
added as new member variables to the ProDeOptions class. Because the
structure of ProDeOptions changes, also saveState and loadState (and
possibly validate) methods must be modified. SaveState method saves
the contents of the ProDeOptions object to an ObjectState
tree. LoadState correspondingly reads the contents from an ObjectState
tree, and it is clear that if new member variables are added to
ProDeOptions class, the ObjectState structure changes as well.

When the ObjectState structure changes, the ProDeOptionsSerializer
class must be modified. There are convertToConfigFileFormat and
convertToOptionsObjectFormat methods of which the
convertToConfigFileFormat converts the ObjectState tree structure
created by the saveState method in ProDeOptions to match with the
structure of configuration file format. If new options are added,
probably the configuration file format changes as well. The
convertToOptionsObjectFormat method converts the ObjectState tree
structure of the configuration file format to match with the structure
created by the saveState method, that is, to the format which can be
read by loadState function.

\section{Database}

The Designer does not utilize a database.

\section{User Interface}
\label{hints_user_interface}

\subsection{Modifying the Main Window}

The main window of the Designer is currently very simple. It consists of
a menu bar, toolbar, status bar and a client area for the document
windows.
 
The menu bar is only used as the Designer menu bar when no open documents
exist. If an open document exists, the menu bar is replaced by a
menu bar supplied by the active document. The Designer's default menu bar
can be altered by modifying the part of the MainFrame source code,
which creates the menu bar. The MainFrame also contains a function for
updating the disabled/enabled state of the menu items. The function
iterates through the menu items searching for commands in the
CommandRegistry. If a command known to the CommandRegistry is found,
the enabled state of the menu item is updated according to the
command's isEnabled() method.
 
Contrary to the menu bars, only one toolbar exists for the whole
Designer. The toolbar contents is read from the Designer options. If
another document type is added to the Designer, each document, or at
least each document type should have its own toolbar. Toolbar button
icons and texts are supplied by the EditorCommands, thus any new
command can be added to the toolbar without any modifications.
 
The statusbar has currently only one field, and the field text is set
directly. If the statusbar is split to several fields, a setter should
be implemented for each field to avoid confusion between the fields
meanings or purposes.
 
\subsection{Modifying Dialogs and Implementing New Dialogs}
 
The dialogs in the Designer were implemented using a graphical dialog design
tool called wxDesigner. WxDesigner generates source code for creating the
dialog widgets and the underlying sizer structure, which lays out the
widgets in the dialog window. wxDesigner has also support for generating a
source code skeleton for the whole dialog class, but this feature was not
utilized. The class skeletons generated by the wxDesigner left part of the
dialog source code outside the class definition, which was not acceptable
considering the strictly object-orientated design philosophy of the TCE
project. Therefore wxDesigner was only utilized to generate source code for
the functions creating the dialog contents.
 
Another problem with wxDesigner was that it doesn't support the user
input validation system offered by wxWidgets. This is why the
generated source code was modified by adding validators for the dialog
widgets. These modifications had to be redone if the dialog was
modified and the source code was regenerated. Therefore, wxDesigner is
not a very useful tool for making small modifications to the dialog
layout. Small modifications to the dialog widgets or the dialog layout
can be done easier by directly modifying the already generated source
code. Despite all these problems, wxDesigner is a very useful tool for
automatically generating complex sizer structures needed for laying
out a number of widgets in the dialog window.
 
All the problems related to the source code generated by the
wxDesigner could be avoided by utilizing yet another way of creating
dialogs. WxDesginer can save descriptions of the dialogs in XML
format, and a dialog class could use these XML files for creating the
dialog constants. However the library needed for generating dialog
contents from the XML descriptions is not officially part of the
wxWidgets framework, but a third party library.  The library also
utilizes an XML parser library, which is not the Xerces XML parser
used in the TCE project. We didn't want to make the Designer dependent
on these libraries, so we rejected the XML dialog descriptions as an
option.
 
\subsection{Adding Mouse Tools}

The Designer has currently two mouse tools, one of which is always
active. These are the SelectTool and ConnectTool, which have the
functionality described in the [Ran03b].
Support for different mouse tools is implemented using the State design
pattern, where the active mouse tool is the state of the MDFView object.
New tools, which redefine the mouse functionality, can be added by
deriving a new tool class from the CanvasTool base class. If a new
tool is added, an EditorCommand for activating the tool is needed too.

\section{Software Interfaces}

The Designer is part of the TCE project, therefore we must adapt to its
requirements. Changes in the interfaces of the other modules in TCE
are possible, even probable, since the TCE tools are continuously
evolving. It must be verified regularly that the Designer is up to date
and that the possible changes in the input and output modules and the
object model for the target processor haven't broke it.

\section{Hardware Interfaces}

No hardware interfaces.

\section{Communications Interfaces}

No communications interfaces.

\section{Portability and Transferability}

The Designer is implemented using wxWidgets as an abstraction layer for
the GUI library. The user interface source code doesn't have any code
specific to the underlying GUI library. However the Designer was
implemented and tested using only the GTK implementation of the
wxWidgets library. It is very likely that compiling the Designer using
another wxWidgets implementation will cause at least some problems.
 
One problem, which emerged in the early GUI prototyping, is that
wxWidgets MDI frames differ a lot between different wxWidgets
implementations. The GTK implementation uses window tabs for each MDI
child frame. The window tabs are not resizeable or iconizeable, and
therefore the current MainFrame/ChildFrame implementation might not
work if another wxWindow implementation with resizeable and
iconizeable MDI child frames is used.

More information on the portability of wxWidgets applications can be
found in~\cite{wxWindows}.

\section{Localization}

Localization has not been taken into account in the design of the product.
It is highly unlikely that a need for non-English version will come up.
However, localization is possible, but requires considerable effort.



\chapter{IDEAS FOR FURTHER DEVELOPMENT}
\label{cha:further_devel}

Ideas for further development can be found in~\cite{ProDeReq}.



%\chapter{OPEN ISSUES}
%\label{cha:open_issues}


\bibliographystyle{alpha}
\cleardoublepage
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}


\end{document}
