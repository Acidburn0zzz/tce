\documentclass[a4paper,twoside]{tce}
\usepackage{pslatex}

\begin{document}
\author{Lasse Laasonen}
\title{TTA Processor Generator}
\ver{0.15.1}
\firstday{05.11.2004}
\lastday{11.01.2006}
% id number in S- sequence
\docnum{020}
% draft/complete/committed\state{draft}

\maketitle



\chapter*{Document History}

\begin{HistoryTable}

 0.1    & 05.11.2004 & L. Laasonen   &
 The initial version. \\

 0.2    & 10.12.2004 & L.Laasonen   &
 Combined GCU and IC generators to one plugin and lots of other changes.\\

 0.3    & 12.01.2005 & L. Laasonen   &
 ProGeCLI derived from ProGeUI. BlockSourceContainer and HDLFileFinalized
 introduced. Lot of smaller fixes. \\

 0.4    & 03.02.2005 & L. Laasonen   &
 Added designs of IDF and BEM modules.\\

 0.4.1  & 04.02.2005 & P. J‰‰skel‰inen &
 Enlarged some of the pictures to make them readable. \\

 0.4.2  & 08.02.2005 & A. Cilio &
 Spelling corrections and cosmetic changes.\\

 0.5    & 22.02.2005 & A. Cilio &
 Completely revised BEM design, 13. Corrected typographic conventions.\\

 0.6    & 28.02.2005 & L. Laasonen &
 Small changes after review by P.\ J‰‰skel‰inen. Updated BEM class
 diagram.\\

 0.7  & 01.03.2005 & A. Cilio &
 Removed opcode table. Corrections style errors.\\

 0.8 & 02.03.2005 & L. Laasonen &
 Updated the BEM class diagram.\\

 0.9 & 04.03.2005 & L. Laasonen &
 Added possibility to give parameters to GCU\&IC generator plugin and query
 information about the plugin.\\

 0.10 & 07.03.2005 & L. Laasonen &
 Updated the sequence diagram. Simplified design: ProGe does not rename the
 HDL blocks as they are copied to the output directory.\\

 0.11 & 17.03.2005 & L. Laasonen &
 Major changes in HBL module design and some other minor changes.
 Updates the BEM module design.\\

 0.12 & 05.09.2005 & L. Laasonen &
 Added a chapter of internal design of GCU.\\

 0.13 & 21.09.2005 & L. Laasonen &
 Major changes caused by replacing HBL with HDB. Simplified netlist module
 etc.\\

 0.14 & 26.09.2005 & L. Laasonen &
 Removed \emph{HDBManager} module from the document (moved to HDB design
 doc).\\

 0.15 & 12.10.2005 & P. J‰‰skel‰inen &
 Updated \emph{ICDecoderPlugin}. Removed erroneus implementation of the
 plug-in mechanism. Stripped IDF object model API.\\

 0.15.1 & 11.01.2006 & A. Cilio &
 Minor updates to implementation state. Marked a section obsolete. \\

\end{HistoryTable}


\tableofcontents



\chapter{INTRODUCTION}

\section{Purpose and Scope}

This document describes in detail the modules that make up the TTA Processor
Generator of the TCE toolset (ProGe).

Intended readers of this document are primarily the developers of the
ProGe.  The level of detail level and the completeness of the design
description is sufficient to make implementation straightforward.

For a complete, implementation-level description of the API of the classes
of the ProGe the reader is referred to the automatically-generated API
reference document.

This document is based on the functional specifications defined
in~\cite{ProGeSpecs} and on the software architecture described
in~\cite{ProGeArchitecture}.

\section{Definitions}

\begin{description}
\item[external port]%
  Port of a function unit block that is not visible for the
  TTA processor itself but is external of the whole processor.
\item[internal port]%
  Port of a function unit or register file block that is visible only
  for the TTA processor itself. Opposite to external port.
\item[opcode]%
  Operation code of an operation in a function unit. The code
  determines which operation is executed if the FU implements several
  operations.
\end{description}

\section{Acronyms and Abbreviations}

\begin{center}
\begin{tabular}{p{0.10\textwidth}p{0.80\textwidth}}
API  & Application Programming Interface \\
FU   & Function Unit \\
GCU  & Global Control Unit \\
HBL  & Hardware Block Library \\
HDL  & Hardware Description Language \\
IC   & Interconnection Network \\
IDF  & Implementation Description File \\
IU   & Immediate Unit \\
MOM  & Machine Object Model \\
PIG  & Program Image Generator\\
ProGe & TTA Processor Generator \\
RF   & Register File \\
TCE  & TTA Codesign Environment \\
UI  & User Interface \\
\end{tabular}
\end{center}



\chapter{SYSTEM OVERVIEW}

\section{``Philosophy of Design''}

% Describe the principles behind this design and give an overview of
% it. Motivate briefly the design if necessary.

\section{External Modules/ Application Environment}

% Overview of module from an external perspective:
% - dependencies with external modules-subsystems
% - IFs of external modules that are used
% - external (file) data formats used

% Do not put here the interfaces provided to other modules.

\subsection{Machine Object Model}

Machine object model base library is used by ProGe. The XML definition
of the processor is first converted to machine object model and then
accessed by ProGe. ADFSerializer is exploited in the conversion. See
\cite{ADF-specs} for the format of the XML definition.

\subsection{Machine Implementation Object Model}

The IDF is read and converted to machine implementation object model
before it is used by ProGe. The object model is used by netlist
generator to pick correct blocks from HDB. IDFSerializer is exploited
in the conversion. See \cite{ProGeSpecs} for the format of the IDF.

\subsection{Binary Encoding Map}

The BEM file is read and converted to binary encoding object model
before it is used by ProGe. BEMSerializer is exploited in the conversion.
See \cite{ProGeSpecs} for the format of the BEM file.

\subsection{Hardware Database}

Hardware Database is used to search hardware implementations of
processor building blocks from. The database is not accessed directly
by ProGe but the interface provided by HDBManager instead
(see~\cite{HDBDesign}).

\section{Internal Design of the Control Unit}

The GCU consists of three blocks that can be separated and implemented
independently. Those are

\begin{enumerate}
\item Instruction fetch block
\item Decompressor block
\item Decoder block
\end{enumerate}

Instruction fetch block is always similar and can be hard
coded. Decompression depends on compression, so the decompressor block
must be custom made. The decoder must be custom made of course, since
each machine configuration has different instructions and control
signals and the decoder block depends also on the implementation of
interconnection network. That is, the decompressor and decoder blocks
must be generated by plugins.

\begin{figure}[htb]
\centerline{\psfig{figure=eps/gcu_design.eps,width=0.75\textwidth}}
\caption{Hardware block design of the GCU.}
\label{fig:gcu-design}
\end{figure}

The decompressor block is generated by the same plugin module that
does the code compression in the Program Image Generator (PIG). The
decoder block is generated by the same plugin that generates the IC
implementation, instead. We have thus two plugin modules involved in
the program/processor generation: (1) Code compressor / decompressor
plugin and (2) decoder / IC plugin.

The interface of the different building blocks of the GCU must be
compatible wit each other. The interfaces are depicted in the Figure
\ref{fig:gcu-design}. Decoder interface to IC may not be the same as in
the picture since it depends on the implementation of IC. Names of the
ports are important in the different hardware blocks in the GCU. They
must be the same as in the picture, as the blocks are later wired
together relying on the names of the ports. For example, the lock
signal of the instruction fetch unit is connected to lock port of
decompressor.

\section{Module Communication}

% This section describes the communication between modules of the
% application or subsystem documented in this design document.

\begin{figure}[tb]
\centerline{\psfig{figure=eps/main_classdiagram.eps,width=1.0\textwidth}}
\caption{High level class diagram of the whole ProGe application.}
\label{fig:high-level-class-diagram}
\end{figure}

High-level class diagram of the application is depicted in
\ref{fig:high-level-class-diagram}. This diagram does not contains all
the classes used in the software. More detailed diagrams of different
modules are presented in the corresponding chapters.

The processing starts from the user interface class ProGeUI which
initializes the processor generator. The processor generator instance
controls the process and passes arguments from one module to
another. High-level sequence diagram is depicted in
\ref{fig:high-level-sequence} from which the module communication can
be seen quite easily.

\begin{figure}[tb]
\centerline{\psfig{figure=eps/main_sequence.eps,width=1.0\textwidth}}
\caption{High level sequence diagram of generating a processor.}
\label{fig:high-level-sequence}
\end{figure}



\chapter{Netlist}
\label{cha:Netlist}

\section{Overview}

\begin{figure}[tb]
\centerline{\psfig{figure=eps/netlist_classdiagram.eps,width=0.5\textwidth}}
\caption{Class diagram of the Netlist module.}
\label{fig:netlist-class-diagram}
\end{figure}

The netlist module is a data structure that describes the interconnections
between different components of the processor. A netlist instance consists
of hardware blocks which contain ports. Ports of hardware blocks may be
connected to other ports. A connection is represented by a graph edge and a
set of properties held by a \emph{PortConnectionProperties} object, which
contains additional information about the connection. The structure of
hardware blocks is hierarchical: a block may also consist of sub-blocks.
When the netlist is translated to a hardware description language, each
block in the netlist is written out as a module. That is, you can create
hierarchical modules by using sub-blocks. Class diagram of Netlist module is
depicted in \ref{fig:netlist-class-diagram}. Hardware blocks in the netlist
are represented by \emph{NetlistBlock} instances. The structure of
interconnection network is not represented by netlist. The IC generator uses
MOM to find out the interconnection of buses and sockets.

\section{NetlistBlock}

Class \emph{NetlistBlock} represents a hardware block in the netlist. It
contains ports which may be connected to other ports. A block may consist of
several sub-blocks.

\notUpToDate

\subsection{Interface}

\begin{description}
\item[NetlistBlock(name : string)]%
  Constructor. Name of the block is given in the parameter.
\item[name() : string]%
  Return the name of the block.
\item[addPort(port : NetlistPort\&)]%
  Add a port to the hardware block. Throws an exception if a
  port exists by the same name already.
\item[portCount() : int]%
  Return the number of ports in the block.
\item[port(index : int) : NetlistPort\&]%
  Return a port by the given index. Throws an exception if the index
  is out of range.
\item[port(name : string) : NetlistPort\&]%
  Return a port by the given name. Throws an exception if no port
  exists by the given name.
\item[subBlockCount() : int]%
  Returns the number of sub-blocks in the block.
\item[subBlock(index : int)]%
  Returns a sub-block by the given index.
\item[subBlock(name : string)]%
  Returns a sub-block by the given name.
\end{description}

\section{NetlistPort}

Class \emph{NetlistPort} represents a port of a hardware block in the
netlist. It has properties such as name, bit width and direction. It may
have a description too. The port may have fixed or parameterized bit width.

\subsection{Interface}

\begin{description}
\item[NetlistPort(name : string, width : int, direction : enum, parent :
  NetlistBlock\&)]%
  Constuctor. Create a non-parameterized port. Name, bit width and direction
  of the port are given as parameters. The direction of the port may be in,
  out or bidirectional. The parent block must be given as parameter as well
  since the port is added automatically to the parent block.
\item[NetlistPort(name : string, direction : string, widthParam : string, parent : NetlistBlock\&]%
  Constructor. Creates a port which has parameterized bit width. Name,
  direction and the name of the width parameter are given as parameters.
\item[setDescription(description : string)]%
  Set the given description for the port.
\item[name() : string]%
  Return the name of the port.
\item[direction() : string]%
  Return the direction of the port.
\item[description() : string]%
  Return the description of the port.
\item[parentBlock() : NetlistBlock\&]%
  Return the parent block of the port.
\item[isWidthParameterized() : bool]%
  Tell whether the bit width of the port is parameterized.
\item[widthParameter() : string]%
  Return the name of the parameter if the bit width of the port is
  parameterized. Otherwise throws an exception.
\item[width() : int]%
  Return the bit width of the port. Throws an exception if the bit
  width is parameterized.
\item[connectPort(port : NetListPort\&, thisFirstBit : int, otherFirstBit : int, width : int)]%
  Connects the port to the given port. The first bit to connect is
  given as parameter as well as the width of the connection.
\item[connectionCount() : int]
  Returns the number of connections.
\item[connection(index : int) : PortConnectionProperties\&]
  Returns a connection by the given index.
\end{description}

\section{PortConnectionProperties}

Class \emph{PortConnectionProperties} represents one or several connections
between the bits of two ports in the netlist. Multi-bit ports may be
connected completely or partially. In the latter case, the connection
involves only a subset of the bits of each port at its ends. Thus, given a
connection between two ports, the bits of one port do not have to be all
connected to the bits of the other port.

\subsection{Interface}

\emph{PortConnectionProperties} has the following interface:

\begin{description}
\item[PortConnectionProperties(port1 : NetlistPort\&, port2 : NetlistPort\&,
  port1FirstBit : int, port2FirstBit : int, width : int)]%
  Constructor. The ports to connect are given by \emph{port1} and
  \emph{port2} parameters. The first bit of \emph{port1} to be connected is
  given in \emph{port1FirstBit} parameter and the first bit of \emph{port2}
  in \emph{port2FirstBit}, respectively. The bit width of the connection is
  given in the \emph{width} parameter.
\item[port1() : NetlistPort\&]%
  Return the first port connected.
\item[port2() : NetlistPort\&]%
  Return the second port connected.
\item[port1FirstBit() : int]%
  Return the first bit connected of the first port.
\item[port2FirstBit() : int]%
  Return the first bit connected of the second port.
\item[width() : int]%
  Return the bit width of the connection.
\end{description}



\chapter{Netlist Generator}

\section{Overview}

Netlist generator module consists of one class called
NetlistGenerator. The purpose of that class is to generate the netlist
depicted in Figure~\ref{cha:Netlist}. Netlist generator uses IDF
module as source data and HDBManager to search hardware blocks from
HDB's. Netlist generator creates a new netlist and adds the FU's,
RF's, IU's and GCU to the netlist. Then it asks the IC/Decoder plugin
to add IC and instruction decoder to the netlist. It is the task of
IC/Decoder plugin to make the wirings between GCU, IC and
units. Netlist generator provides information of netlist blocks to the
GCU/Decoder plugin. For example, it needs to know what is the meaning
of different ports in the netlist blocks.

\section{Interfaces}

NetlistGenerator has the following interface:

\begin{description}
\item[NetlistGenerator(mid : MachineImplementation\&, plugin : GeneratorPlugin\&)]%
  Constructor. The implementation description and the IC/Decoder
  plugin are given as parameters.
\item[generate() : NetlistBlock*]%
  Generates the netlist.
\item[fuPort(fu : string, port : string) : NetlistPort\&]
  Returns the port in the netlist that is the same port as the given port in
  the given FU.
\item[rfPort(rf : string, port : string) : NetlistPort\&]
  Returns the port in the netlist that is the same port as the given port in
  the given RF.
\item[loadPort(port : NetlistPort\&) : NetlistPort\&]
  Returns the load enable port of the given port.
\item[opcodePort(port : NetlistPort\&) : NetlistPort\&]
  Returns the opcode port of the given port.
\item[guardPort(block : NetlistBlock\&) : NetlistPort\&]
  Returns the guard port of the given (RF) block.
\item[clkPort(block : NetlistBlock\&) : NetlistPort\&]
  Returns the clock port of the given block.
\item[rstPort(block : NetlistBlock\&) : NetlistPort\&]
  Returns the reset port of the given block.
\item[glockPort(block : NetlistBlock\&) : NetlistPort\&]
  Returns the global lock port of the given block.
\item[glockReqPort(block : NetlistBlock\&) : NetlistPort\&]
  Returns the global lock request port of the given block.
\end{description}

\section{Implementation}

% Describe here important low-level details. Only details about complex
% problems that require ``smart solution'' should be treated.  Do not
% describe every single detail of the implementation when that follows from
% the specification/design in a straightforward manner.

Names given to netlist blocks and port are important. The same names
might appear in the final HDL files, too. This depends on the
implementation of the NetlistWriter.

For FUs and RF's the name should be the name of the corresponding
block in ADF with prefixes fu\_ or rf\_. Names of ports must match
with the actual port names that exist in the HDL (or synthesized)
files in HDB since the netlist writer uses these names directly in
port mapping.

\section{Error Handling}

When generating the netlist, the corresponding FU's, RF's and IU's are
searched from HDB's. An exception is thrown if some block is not found.



\chapter{IC\&Decoder Generator}

\section{Overview}

\begin{figure}[tb]
\centerline{\psfig{figure=eps/plugin_classdiagram.eps,width=0.75\textwidth}}
\caption{Class diagram of the plugin architecture.}
\label{fig:plugin-class-diagram}
\end{figure}

The IC\&Decoder generator is a plugin module. That is, it is
dynamically loaded at the execution time of the application. The class
diagram of the module is depicted in
Figure~\ref{fig:plugin-class-diagram}. IC\&Decoder generator is just
one class in the diagram but it is recommendable to implement them in
different classes and just create a plugin class that uses them
together. There are two reasons for this solution:

\begin{enumerate}
\item Reuse of same GCU or decoder generator in several plugins is possible.
\item Responsibility of compatibility of GCU and decoder is left to the
      creator of the plugin. Automatic verification of compatibility
      would be very hard, if not impossible.
\end{enumerate}

However, it is not required that IC and decoder generators are in separate
classes. It is sufficient that there is a shared object that
implements the interface of GeneratorPlugin class. The way it is
implemented is totally free.

\section{ICDecoderPlugin}

The ICDecoderPlugin class is a base class for the plugins.

\subsection{Interface}

The ICDecoderPlugin has the following interface:

\begin{description}
\item[GeneratorPlugin(machine : Machine\&)]%
Constructor. The machine is given as parameter.
\item[generate(outputDir : string)]%
  Generates the HDL code for GCU and decoder. HDL files for IC and
  decoder are generated to files which are located into the given
  directory. Throws an exception if GCU or decoder cannot be generated.
\item[completeNetlist(manager : NetlistGenerator\&, netlist : NetlistBlock\&)]
  Completes the given netlist by adding IC and decoder blocks and
  connections of IC and decoder. Information of the blocks is queried
  from the given netlist generator.
\item[targetHDL() : string]%
  Return the target HDL generated by the plugin.
\item[requiredRFLatency(iu : string) : int]%
  Returns the register file latency required for the immediate unit of
  the given name.
\item[setParameter(name : string, value : string)]%
  Gives a parameter to the plugin. It may be, for example, name of a
  code compression data file.
\item[requiredParameterCount() : int]
  Returns the number of required parameters.
\item[requiredParameter(index : int) : string]
  By the given index, returns the name of the required
  parameter. Throws an exception if the given index is out of range.
\item[parameterDescription(parameter : string) : string]
  Returns a description of the given parameter.
\item[pluginDescription() : string]
  Returns a brief description of the plugin.

\item[estimateDelayOfPath(..., DelayInNanoSeconds\& delay) : boolean]

\end{description}

\subsection{Error Handling}

The GCU\&Decoder generator plugin may refuse to create the GCU and
decoder. This happens if the plugin cannot create such decoder (or IC)
requested by the given parameters. Also, if some mandatory parameter
for the plugin is missing, an error occurs. The \emph{generate} method
throws an exception with an error message in these cases.

\section{ICDecoderPluginProxy}

The purpose of ICDecoderPluginProxy class is to provide the plugin
like it would be a normal object. It hides loading the plugin and the
different syntax of calling the methods of the plugin. It is derived
from GeneratorPlugin class.

\subsection{Interface}

The interface of GeneratorPluginProxy is similar to GeneratorPlugin
class except that its constructor takes the plugin file as parameter
additionally.



\chapter{BlockSourceCopier}

\section{Overview}

The \emph{BlockSourceCopier} class is responsible of copying the HDL (or synthesized binary) files of FU's, RF's and IU's of the processor to the output directory of the application.

\section{Interface}

The BlockSourceFinalizer class has the following interface:

\begin{description}
\item[BlockSourceCopier(impl : MachineImplementation\&)]%
The constructor. Machine implementation description is given as parameter.
\item[copy(directory : string)]%
Copies the block source files to the given directory. The given
directory is the root directory. Different types of files are copied
to different subdirectories.
\end{description}



\chapter{NetlistWriter}

\section{Overview}

The netlist writer module consists of \emph{NetlistWriter} interface
and class(es) that implement it. The purpose of the classes is to
write the given netlist in some HDL. For different HDL's, new classes
that implement the \emph{NetlistWriter} interface can be
created. Class diagram of the module is depicted in
\ref{fig:netlistwriter-class-diagram}.

\begin{figure}[tb]
\centerline{\psfig{figure=eps/netlistwriter_classdiagram.eps,width=0.2\textwidth}}
\caption{Class diagram of netlist writer module.}
\label{fig:netlistwriter-class-diagram}
\end{figure}

\section{Interface}

The abstract NetlistWriter class has the following interface:

\begin{description}
\item[NetlistWriter(netlist : Netlist\&)]%
  Constructor. The netlist is given as parameter.
\item[write(dstDirectory : string)]%
  Generates the HDL files to the given destination directory.
\end{description}



\chapter{Processor Generator}

\section{Overview}

The module consist of ProcessorGenerator class. It acts as a
middle-man between user interface, netlist generator, GCU\&IC
generator HDL file finalizer and top-level generator. The user
interface module tells the ProGeController what to do and gives MOM,
IDF and BEM based on the parameters given by user. The controller
initialises netlist generator to generate the initial netlist. Then it
gives the netlist and BEM to GeneratorPluginProxy which handles the
generation of GCU and IC and updating the netlist. Finally, the
netlist is given to the TopLevelGenerator which generates the toplevel
file.

\section{Interfaces}

The ProcessorGenerator class has the following interface:

\begin{description}
\item[ProcessorGenerator()]%
  Constructor.
\item[generateProcessor(language : string, machine : Machine\&, implementation : MachineImplementation\&, bem : BinaryEncoding\&, plugin : GeneratorPluginProxy\&)]%
  Generates the processor. The language to be generated is given. The
  machine, machine implementation, binary encoding map and the plugin
  to be used are given, too. Throws an exception if an error occurs
  during generation of the processor.
\item[setPluginParameter(name : string, value : string)]
  This method is used to give a parameter to the GCU\&IC generator
  plugin. The method can be called many times to give several
  parameters.
\item[generatorPluginCount() : int]
  Returns the number of GCU\&IC generators available.
\item[generatorPlugin(index : int) : string]
  Returns name of the plugin file by the given index. Throws an
  exception if the given index is out of range.

\end{description}



\chapter{User Interface}

\section{Overview}

The command line user interface of ProGe is implemented in ProGeCLI
class. The class is derived from ProGeUI class which is an abstract
base class for different user interfaces. ProGeCLI class is completely
separated from the rest of the application. No other classes depend on
ProGeCLI. This way adding different user interfaces is made as simple
as possible. ProGeCLI just parses the command line by means of the
command line framework from toolkit. Then it calls the methods of
ProGeUI parent class. Class diagram of the module is depicted in
\ref{fig:ui-class-diagram}.

\begin{figure}[tb]
\centerline{\psfig{figure=eps/ui_classdiagram.eps,width=0.60\textwidth}}
\caption{Class diagram of the user interface module.}
\label{fig:ui-class-diagram}
\end{figure}

\subsection{ProGeUI}

The ProGeUI class provides protected methods that are useful for
derived user interface classes.

\subsubsection{Interface}

ProGeUI class has the following protected interface:

\begin{description}
\item[ProGeUI()]%
  Constructor.
\item[loadMachine(adf : string)]%
  Loads the machine from the given ADF file.
\item[loadBinaryEncoding(bem : string)]%
  Loads the binary encoding from the given BEM file.
\item[loadMachineImplementation(idf : string)]%
  Loads the machine implementation from the given IDF file.
\item[loadProcessorConfiguration(pcf : string)]%
  Loads the processor configuration from the given configuration file.
\item[loadGeneratorPlugin(file : string)]%
  Loads the GCU\&Decoder plugin from the given file.
\item[loadPluginParameter(name : string, value : string)]%
  Loads a parameter for the plugin.
\item[generateProcessor(hdl : enum, useSources : bool)]%
  Starts the generation of the processor with the loaded
  information. Throws an exception if some information is missing or if an
  error occurs during generation of the processor.
\end{description}

\subsection{ProGeCLI}

The ProGeCLI class implements the command line user interface of
ProGe. It is derived from ProGeUI class.

\subsubsection{Interface}

The ProGeCLI class has the following interface:

\begin{description}
\item[ProGeCLI()]%
  Constructor.
\item[generateProcessor(argc : int, argv : char**)]%
  Parses the given command line parameters and generates the processor
  using other classes.
\end{description}

\section{Error Handling}

\subsection{Illegal Command Line Parameters}

If illegal command line parameters are given, generateProcessor prints
usage of the application and throws an exception.

\subsection{Synthesizability of Processor Architecture}

The given ADF must be synthesizable in order to generate the
processor. An exception with error message is thrown from
generateProcessor() if the ADF is not synthesizable. MachineValidator
class from \emph{mach} base library is used to verify the
synthesizability of the architecture before passing it to the netlist
generator.

\subsection{Given Plugin Is Not Found}

An exception is thrown from generateProcessor if the given plugin file
cannot be found from the predefined directories that should contain
plugins.



\chapter{IDF Module}

\section{Overview}

The IDF module is a object model which identifies implementation of a
machine defined in an IDF. Class diagram of the module is depicted in
Figure~\ref{fig:IDF-classdiagram}.

\begin{figure}[tb]
\centerline{\psfig{figure=eps/idf_classdiagram.eps,width=0.3\textwidth}}
\caption{Class diagram of the IDF module.}
\label{fig:IDF-classdiagram}
\end{figure}

\section{MachineImplementation}

MachineImplementation class is the main class of the module. It
contains UnitImplementation instances each of which defines the
implementation used for a unit.

\subsection{Interface}

Please refer to the TCE API documentation for details on how to access
the object model.

\section{UnitImplementation}

UnitImplementation class stores the implementation id and the HDB that
contains the id as well as the name of the unit (FU, RF or IU).

\subsection{Interface}

UnitImplementation class has the following interface:

\begin{description}
\item[UnitImplementation(state : ObjectState*)]%
Constructor. Loads the state of the object from the given ObjectState
tree.
\item[hdbFile() : string]%
Returns the HDB that contains the implementation.
\item[id() : int]
Returns the id of the unit in the HDB.
\item[unitName() : string]
Returns the name of the unit in ADF.
\end{description}



\chapter{BEM Module}

\section{Overview}

BEM (Binary Encoding Map) module is an object model which represents the
binary encodings of sockets, ports, bridges and operations in a TTA
instruction. The information in the object model is the same found in the
BEM file, specified in~\cite{ProGeSpecs}. Class diagram of the module is
depicted in Figure~\ref{fig:BEM-classdiagram}. The structure of the BEM
object model reflects the target architecture template and therefore the
machine object model (specified in~\cite{MOM-design}). However, this module
does not depend on other domain modules, because the components of a machine
are referred to exclusively by name.

\begin{figure}[tb]
\centerline{\psfig{figure=eps/bem_classdiagram.eps,width=1.2\textwidth}}
\caption{Class diagram of the Binary Encoding Map Module.}
\label{fig:BEM-classdiagram}
\end{figure}

\section{BinaryEncoding}
\label{sec:BinaryEncoding}

\emph{BinaryEncoding} is the root class in the object model of the binary
encoding map. An instance of this class is sufficient to access all the
information pertaining a binary encoding map, so an object can be passed to
clients whenever a full description of the encoding map is required.
\emph{BinaryEncoding} is mostly a specialised container of objects of other
classes. It provides a minimal amount of bookkeeping and consistency
checking, and it implements the \emph{Serializable} interface.

The classes directly managed by \emph{BinaryEncoding} are:
\begin{enumerate}
\item \emph{MoveSlot} (Section~\ref{sec:MoveSlot}).
\item \emph{ImmediateControlField} (Section~\ref{sec:ImmediateControlField}).
\item \emph{SocketCodeTable} (Section~\ref{sec:SocketCodeTable}).
\end{enumerate}

\subsection{Interface}

\emph{BinaryEncoding} class has the following interface:

\begin{description}
\item[BinaryEncoding()]%
  Constructor. Creates an empty BEM.
\item[moveSlotCount() : int]%
  Return the number of move slots in the instruction.
\item[moveSlot(index : int) : MoveSlot\&]%
  Return the move slot at given index. The index does not have to reflect
  the actual order within the TTA instruction word. Throw \emph{OutOfRange}
  exception if the index is negative or is not smaller than the number of
  move slots of the TTA instruction word.
\item[hasMoveSlot(name : string) : bool]%
  Tell whether the encoding map contains a move slot with the given name.
\item[moveSlot(name : string) : MoveSlot\&]%
  Return the move slot that programs the bus identified by the given
  name. Throw \emph{InstanceNotFound} exception if the encoding map does not
  contain a move slot with the given name.
\item[addMoveSlot(slot : MoveSlot\&)]%
  Add the given move slot to the encoding map. This method is to be called
  from the constructor of \emph{MoveSlot}. Throws an
  \emph{ObjectAlreadyExists} exception if the encoding map contains a slot
  with the same name already.
\item[removeMoveSlot(slot : MoveSlot\&)]%
  Remove the move slot from the encoding map. This method is to be called
  from the destructor of \emph{MoveSlot}.
\item[hasImmediateControlField() : bool]%
  Tell whether the instruction word has a immediate control field.
\item[immediateControlField() : ImmediateControlField\&]%
  Return the immediate control field of the instruction word. Return a
  \emph{NullImmediateControlField} instance if the instruction word does not
  have it (single-template instruction).
\item[setImmediateControlField(field : ImmediateControlField\&)]%
  Add the given immediate control field to the instruction word. This method
  is to be called from the constructor of ImmediateControlField. Throw
  \emph{ObjectAlreadyExists} exception the instruction word already has an
  immediate control field.
\item[unsetImmediateControlField()]%
  Remove the long immediate field. This method is to be called from the
  destructor of ImmediateControlField.
\item[socketCodeTableCount() : int]%
  Return the number of socket code tables contained by the encoding map.
\item[socketCodeTable(index : int) : SocketCodeTable\&]%
  Return the socket code table at the given index. Throw \emph{OutOfRange}
  exception if the index is negative or is not smaller than the number of
  socket code tables in the encoding map.
\item[addSocketCodeTable(table : SocketCodeTable\&)]%
  Add the given socket code table to the encoding map. This method is to be
  called from the constructor of \emph{SocketCodeTable}. Throw
  \emph{ObjectAlreadyExists} exception if the encoding map already contains
  a socket code table with the same name of the given table.
\item[removeSocketCodeTable(table : SocketCodeTable\&)]%
  Remove the given socket code table from the encoding map. This method is
  to be called from the destructor of \emph{SocketCodeTable}.
\end{description}

\subsection{Implementation}

All objects that are directly managed by \emph{BinaryEncoding} are
automatically registered to the parent encoding map at the time of
construction and are released (unregistered) before being destroyed.
%
To ensure that the methods that add or remove these objects are called only
by the appropriate client (respectively, the constructor and the destructor
of the object in question), there must be a mechanism at run time to verify
this restriction is upheld.

A possible implementation of these run time checks is based on the parent
\emph{BinaryEncoding} pointers of the managed objects.
%
By setting the parent pointer to null, the destructor of the managed class
signals to the remove method it calls that it has been invoked by the
destructor. Since no public method lets clients nullify (or even change!)
the parent pointer, it is guaranteed that a null pointer implies correct use
of the remove method.
%
Similarly, by leaving the parent pointer initialised to null, the
constructor of the same managed class signals to the add method it calls
that it has been invoked by the constructor.
%
The add and remove methods should abort if they are not called from the
destructor.

\section{InstructionField}
\label{sec:InstructionField}

\emph{InstructionField} is an abstract base class that represents the
properties common to all types of bit fields of the TTA instruction word. A
bit field has a position and a width attribute. The first one defines the
bit position of the field within its parent field. The second one defines
the bit width of the field.

\subsection{Interface}

The InstructionField class has the following interface:
%
\note{DISCUSS: inconsistent API setting a position is something relative to
a parent, but this class has no parent!}
%
\begin{description}
\item[InstructionField()]%
  Constructor. Create an instruction field \emph{width} bits wide at
  position \emph{position}.
\item[bitPosition() : int]%
  Return the bit-accurate position of the field relative to its parent.
\item[relativePosition() : int]
  Returns the relative position of the field compared to its
  ``sibling'' fields. If the field is the rightmost field, returns
  0. The leftmost field returns the number of sibling fields - 1.
\item[setRelativePosition(position : int)]%
  Sets a new relative position for the field.
\item[width() : int]%
  Return the bit width of the field.
\item[setExtraBits(bits : int)]
  Sets the number of extra bits to the field. The field can be forced
  longer than necessary by defining some number of extra bits. In
  practice, there will be the given amount of zeros always in the
  MSB end of the field.
\item[extraBits() : int]
  Returns the number of extra bits.
\end{description}

\section{ImmediateControlField}
\label{sec:ImmediateControlField}

\emph{ImmediateControlField} is a specialised \emph{InstructionField} and
represents the field of the TTA instruction that contains the long immediate
control tag. This tag defines the templates of the instruction. A TTA
instruction template specifies which move slots are used to program data
transports and which are used to encode immediate bits.  An
\emph{ImmediateControlField} object can never exist alone. It is always
registered to a \emph{BinaryEncoding} instance.

\subsection{Interface}

The \emph{ImmediateControlField} class has the following interface:

\begin{description}
\item[ImmediateControlField(position : int, width : int, parent :
  BinaryEncoding\&)]%
  Constructor. Create an immediate control field with position, width and
  the parent \emph{BinaryEncoding} instance given as parameters. The field
  is registered to the parent automatically.

  Throw \emph{ObjectAlreadyExists} exception if the TTA instruction already
  has an immediate control field.

\item[templateCount() : int]%
  Return the number of instruction templates with a binary encoding assigned.

\item[template(index : int) : string]%
  Return the name of the template encoded in this field at position
  \emph{index}.

  Throw \emph{OutOfRange} exception if \emph{index} is negative or is not
  smaller than the number of instruction templates with a binary encoding
  assigned.

\item[hasTemplateEncoding(name : string) : bool]%
  Tell whether the instruction template with the given name has a binary
  encoding in this field.

\item[templateEncoding(name : string) : int]%
  Return the code that identifies the instruction template with the given
  name. Throw \emph{InstanceNotFound} exception if the instruction template
  with the given name is not assigned encoding.

\item[addTemplateEncoding(name : string, encoding : int)]%
  Assign the given code to the instruction template identified by given
  name.

\item[removeTemplateEncoding(name : string)]%
  Remove the code of the instruction template with the given name.
\end{description}

\section{MoveSlot}
\label{sec:MoveSlot}

The \emph{MoveSlot} class represents move slots, fields of the TTA
instruction dedicated to program data transports. Move slots are subdivided
into 2 or 3 fields: the guard (optional), source and destination
fields. Each type of move slot field is modelled by a different class.
\emph{MoveSlot} has handles to the instances of these classes.  A move slot
is identified by the name of the transport bus it controls.  \emph{MoveSlot}
instances cannot exist alone; they belong to a binary encoding and are
always registered to a \emph{BinaryEncoding} object.

\subsection{Interface}

The \emph{MoveSlot} class has the following interface:

\begin{description}
\item[MoveSlot(busName : string, parent : BinaryEncoding\&)]%
  Constructor. Create a move slot with the given name (of the controlled
  bus) and the given parent binary encoding map.

  Throw \emph{ObjectAlreadyExists} exception if the binary encoding map
  already contains a move slot with the same name.
\item[name() : string]%
  Return the name of the move slot. This is usually the name of the bus for
  which it defines data transports.
\item[setName(name : string)]%
  Set the name of the move slot.
%
  \note{DISCUSS: Is it needed? Avoid this method, make name a
  construction-time constant}
%
  This is usually the name of the bus for which it defines data transports.
\item[setGuardField(field : GuardField\&)]%
  Add the given guard field to the move slot. Throw [[exception]]
  \note{DISCUSS: which exception?} if the slot has a guard field
  already. This method is to be called from the constructor of
  \emph{GuardField}.
\item[unsetGuardField()]%
  Remove the guard field from the move slot. This method is to be called
  from the destructor of \emph{GuardField}.
\item[hasGuardField() : bool]%
  Tell whether the move slot has a guard field.
\item[guardField() : GuardField\&]%
  Return the guard field. Return a \emph{NullGuardField} \note{DISCUSS:
  better throw? otherwise, what is the sense of hasGuardField()?} instance
  if the move slot does not have a guard field.
\item[setSourceField(field : SourceField\&)]%
  Add the given source field to the move slot. Throw
  \emph{ObjectAlreadyExists} exception if the slot has a source field
  already. To be called from the destructor of \emph{SourceField} only.
\item[unsetSourceField()]%
  Remove the source field from the move slot. This method is to be called
  from the destructor of \emph{SourceField}.
\item[hasSourceField() : bool]%
  Tell whether the slot has a source field.
\item[sourceField() : SourceField\&]%
  Return the source field of the move slot. Return a \emph{NullSourceField}
  \note{DISCUSS: throw instead?} instance if the move slot does not have a
  source field.
\item[setDestinationField(field : DestinationField\&)]%
  Add the given destination field to the move slot. Throw
  \emph{ObjectAlreadyExists} exception if the move slot has a destination
  field already.
\item[unsetDestinationField()]%
  Remove the destination field from the move slot. This method is to be
  called from the destructor of \emph{DestinationField}.
\item[hasDestinationField() : bool]%
  Tell whether the move slot has a destination field.
\item[destinationField() : DestinationField\&]%
  Return the destination field of the move slot. Return a
  \emph{NullDestinationField} instance if the slot does not have a
  destination field.
\end{description}

\section{GuardField}
\label{sec:GuardField}

The \emph{GuardField} class represents the guard field of the move slot. The
guard field defines the guard expressions that control whether a data
transport is completed or cancelled. A \emph{GuardField} instance contains
the control codes that identify the guard expressions supported by a given
move slot. \emph{GuardField} is an instruction field, hence it is derived
from class \emph{InstructionField}. \emph{GuardField} instances cannot exist
alone; they belong to a move slot and are registered to a \emph{MoveSlot}
object at construction time.

\section{Interface}

The GuardField class has the following interface:

\begin{description}
\item[GuardField(position : int, width : int, parent : MoveSlot\&)]%
  Constructor. Create a guard field and register it into a move slot. The
  parent move slot, the position of the field within it, as well as bit
  width if the field are given as parameters. Throw [[exception]]
%
  \note{DISCUSS: exception type}
%
  if the given more slot already has a guard field.

\item[removeGuardEncoding(encoding : GPRGuardEncoding\&)]%
  Remove the given guard encoding. This method is to be called only from the
  destructor of \emph{GPRGuardEncoding}.

\item[removeGuardEncoding(encoding : FUGuardEncoding\&)]%
  Remove the given guard encoding. This method is to be called only from the
  destructor of \emph{FUGuardEncoding}.

\item[addGuardEncoding(encoding : GPRGuardEncoding\&)]%
  Add a guard expression and its encoding to the set of expressions
  supported by this guard field. This method is to be called from the
  constructor of \emph{GPRGuardEncoding}. Throw \emph{ObjectAlreadyExists}
  exception if the guard field already contains a guard encoding with equal
  control code, or a guard encoding for the same guard expression.

\item[addGuardEncoding(encoding : FUGuardEncoding\&)]%
  Add a guard expression and its encoding to the set of expressions
  supported by this guard field. This method is to be called from the
  constructor of \emph{FUGuardEncoding}. Throw \emph{ObjectAlreadyExists}
  exception if the guard field already contains a guard encoding with equal
  control code, or a guard encoding for the same guard expression.

\item[gprGuardEncodingCount() : int]%
  Return the number of guard expressions with general purpose register term
  that are encoded in this field.

\item[gprGuardEncoding(index : int) : GPRGuardEncoding\&]%
  Return the \emph{GPRGuardEncoding} at position \emph{index}. Throw
  \emph{OutOfRange} exception if \emph{index} is out of range.

\item[hasGPRGuardEncoding(rf : string, index : int, invert : bool) : bool]%
  Tell whether the guard field has an encoding for the given guard
  expression. The expression is identified by a general purpose register
  (register file name and register index) and by the \emph{invert} flag.

\item[gprGuardEncoding(rf : string, index : int, invert : bool) :
  GPRGuardEncoding\&]%
  Return the \emph{GPRGuardEncoding} for the given guard expression. The
  expression is identified by a general purpose register (register file name
  and register index) and by the \emph{invert} flag. Return a
  \emph{NullGPRGuardEncoding} \note{DISCUSS: better throw? otherwise, what
  is the sense of hasGuardField()?} instance if there is no such guard.

\item[fuGuardEncodingCount() : int]%
  Return the number of guard expressions with function unit output term that
  are encoded in this field.

\item[fuGuardEncoding(index : int) : FUGuardEncoding\&]%
  Return the \emph{FUGuardEncoding} at position \emph{index}. Throw
  \emph{OutOfRange} exception if \emph{index} is out of range.

\item[hasFUGuardEncoding(fu : string, port : string, invert : bool) : bool]%
  Tell whether the guard field has an encoding for the given guard
  expression. The expression is identified by a function unit output port
  (FU name and port name) and by the \emph{invert} flag.

\item[fuGuardEncoding(fu : string, port : string, invert : bool) :
  FUGuardEncoding\&]%
  Return the \emph{FUGuardEncoding} for the given guard expression.  The
  expression is identified by a function unit output port (FU name and port
  name) and by the \emph{invert} flag. Return a \emph{NullFUGuardEncoding}
  \note{DISCUSS: better throw?  otherwise, what is the sense of
  hasGuardField()?} instance if there is no such guard.
\end{description}

\section{GuardEncoding}

Class \emph{GuardEncoding} captures the properties shared by all types of
guard encoding.

\emph{GuardEncoding} class has the following interface:

\begin{description}
\item[isGuardInverted() : bool]%
  Tell whether the outcome of the guard expression is to be taken inverted
  or not.

\item[encoding() : int]%
  Return the encoding of the guard.
\end{description}

\section{GPRGuardEncoding}

The \emph{GPRGuardEncoding} class maps a guard expression with general
purpose register term to a control code. Instances of this class are always
registered to a guard field.

\subsection{Interface}

\emph{GPRGuardEncoding} class has the following interface:

\begin{description}
\item[GPRGuardEncoding(rf : string, index : int, invert : bool, encoding :
  int, parent : GuardField\&)]%
  Constructor. Create a guard encoding and register it into the given guard
  field. The guard expression is identified by the name of register file,
  the index of the GPR and the \emph{invert} flag, all given as parameters.

  Throw \emph{ObjectAlreadyExists} exception if the guard expression is
  already encoded in the parent field, or if the given control code is
  already assigned to another guard expression.
%
  Throw [[exception]] \note{DISCUSS: exception type} if the given encoding
  does not fit to the bit width of the parent guard field.

\item[registerFile() : string]%
  Return the name of the register file that contains the GPR of this guard
  expression.

\item[registerIndex() : int]%
  Return the index of the GPR of this guard expression.

\item[setEncoding(encoding : int)]%
  Set new encoding
%
  \note{DISCUSS: remove this method, 99\% of clients don't need it, nor it is
    consistent with the API (no set method for RF, index, invert)}
%
  for the guard expression. Throw \emph{ObjectAlreadyExists} exception if
  the given encoding is assigned to another guard already.
%
  Throw [[exception]] if the given encoding does not fit in the bit width of
  the parent guard field.
\end{description}

\section{FUGuardEncoding}

The \emph{FUGuardEncoding} class maps a guard expression with FU output port
term to a control code. Instances of this class are always registered to a
guard field.

\subsection{Interface}

\emph{FUGuardEncoding} class has the following interface:

\begin{description}
\item[FUGuardEncoding(fu : string, port : string, invert : bool, encoding
  : int, parent : GuardField\&)]%
  Constructor. Create a guard encoding and register it into the given guard
  field.  The guard expression is identified by the name of function unit
  and port, and the \emph{invert} flag, all given as parameters.

  Throw \emph{ObjectAlreadyExists} exception if the guard expression is
  already encoded in the parent field, or if the given control code is
  already assigned to another guard expression.
%
  Throw [[exception]]
%
  \note{DISCUSS: exception type}
%
  if the given encoding does not fit to the bit width of the parent guard
  field.

\item[functionUnit() : string]%
  Return the name of the function unit that contains the port of this guard
  expression.

\item[port() : string]%
  Return the name of the FU port of this guard expression.

\item[setEncoding(int : encoding)]%
  Set new encoding
%
  \note{DISCUSS: see notes for GPRGuardEncoding}
%
  for the guard expression. Throw \emph{ObjectAlreadyExists} exception if
  the given encoding is assigned to another guard already.
%
  Throw [[exception]] if the given encoding does not fit to the bit width of
  the parent guard field.
\end{description}

\section{SlotField}

\emph{SlotField} is an abstract base class that models the properties common
to \emph{SourceField} and \emph{DestinationField} classes. \emph{SlotField}
contains and manages the encodings for sockets.

\subsection{Interface}

The SlotField class has the following interface:

\begin{description}
\item[SlotField(position : int, width : int)]%
  Protected constructor. Initialise position of the field within the move
  slot and bit width of the field with the given parameters.

\item[addSocketEncoding(encoding : SocketEncoding\&)]%
  Add the given socket encoding. Throw \emph{ObjectAlreadyExists} exception
  if the field already has an encoding for the given socket. This method is
  to be called from the constructor of \emph{SocketEncoding}.

\item[removeSocketEncoding(encoding : SocketEncoding\&)]%
  Remove the given socket encoding. This method is to be called from the
  destructor of \emph{SocketEncoding}.

\item[socketEncodingCount() : int]%
  Return the number of socket sources that are encoded in this field.

\item[hasSocketEncoding(name : string) : bool]%
  Tell whether the source field has an encoding for the socket with the
  given name.

\item[socketEncoding(index : int) : SocketEncoding\&]%
  Return the socket encoding stored at position \emph{index}. Throw
  \emph{OutOfRange} exception if \emph{index} is out of range (negative or
  not smaller than the number of sockets encoded in the field).

\item[socketEncoding(name : string) : SocketEncoding\&]%
  Return the socket encoding of the socket with given name. Return a
  \emph{NullSocketEncoding} instance if this source field does not encode
  the socket.
\end{description}

\section{SourceField}

Class \emph{SourceField} represents the source field of a move slot. It is a
specialisation of \emph{SlotField} class. In addition to socket encodings, a
source field may encode an inline immediate or up to two bridge sources.

\subsection{Interface}

The SourceField class has the interface as follows:

\begin{description}
\item[SourceField(position : int, width : int, parent : MoveSlot\&)]%
  Constructor. Create a source field and register it into a move slot.  The
  parent move slot, the position of the field within it, as well as bit
  width if the field are given as parameters.

  Throw [[exception]]
%
  \note{DISCUSS: exception type}
%
  if the given more slot already has a guard field.

\item[addImmediateEncoding(encoding : ImmediateEncoding\&)]%
  Add an encoding for inline immediates to the source field. This method is
  to be called from the constructor of \emph{ImmediateEncoding} class.

  Throw \emph{ObjectAlreadyExists} exception if the field already has an
  encoding for inline immediates.


\item[removeImmediateEncoding()]%
  Remove the encoding for inline immediates from the source field. This
  method is to be called from the destructor of \emph{ImmediateEncoding}.

\item[hasImmediateEncoding() : bool]%
  Tell whether the source field can encode immediates.

\item[immediateEncoding() : ImmediateEncoding\&]%
  Return the encoding for inline immediates. Return a
  \emph{NullImmediateEncoding} instance if the source field does not encode
  immediates.

\item[addBridgeEncoding(encoding : BridgeEncoding\&)]%
  Add an encoding for given bridge to the source field.

  Throw \emph{ObjectAlreadyExists} exception if the field already has an
  encoding for the given bridge or if there is a socket or bridge with the
  same encoding.
%
  \note{DISCUSS: what if source field already encodes 2 bridges?}

\item[removeBridgeEncoding(encoding : BridgeEncoding\&)]%
  Remove the encoding of the given bridge.

\item[bridgeEncodingCount() : int]%
  Return the number of bridge sources encoded in this field.

\item[bridgeEncoding(index : int) : BridgeEncoding\&]%
  Return the bridge encoding stored at position \emph{index}. Throw
  \emph{OutOfRange} exception if \emph{index} is out of range.
\end{description}


\section{ImmediateEncoding}

Class \emph{ImmediateEncoding} represents control code that signals inline
immediates for a source field.

\subsection{Interface}

\begin{description}
\item[ImmediateEncoding(position : int, width : int, encoding : int, parent
  : SourceField\&)]%
  Constructor.  Create an inline immediate encoding and register it into the
  given source field.  The parent source field, the position within it, the
  bit width and the encoding of the control code are given as parameters.

  Throw \emph{ObjectAlreadyExists} exception if the source field already
  encodes immediates.

\item[encoding() : int]%
  Return the control code which signals that the source field contains an
  inline immediate.
\end{description}

\section{BridgeEncoding}

Class \emph{BridgeEncoding} maps a bridge to a binary encoding.

\subsection{Interface}

\begin{description}
\item[BridgeEncoding(name : string, encoding : int, parent : SourceField\&)]%
  Constructor. Create an encoding for bridge \emph{name} and register it
  into source field \emph{parent}. The bridge encoding is assigned value
  \emph{encoding}.

  Throw \emph{ObjectAlreadyExists} exception if the parent source filed
  already encodes the bridge, or if the given control code is already
  assigned to another move source (socket, bridge or immediate).

\item[encoding() : int]%
  Return the encoding of the bridge.
\item[bridgeName() : string]
  Return the name of the bridge.
\end{description}

\section{DestinationField}

The \emph{DestinationField} class represents the destination field of a move
slot. The destination field contains only socket encodings and so it is just
a realization of \emph{SlotField} class. It does not provide any additional
methods.

\section{SocketEncoding}

The \emph{SocketEncoding} models how socket sources or destinations are
mapped to control codes. Sockets have an independent encoding in each source
or destination field they appear in. The socket encoding is a specialisation
of \emph{InstructionField}. A socket encoding can be more complex than a
fixed control code and encode many destinations all reached from the same
socket. In this case, the socket encoding contains a \emph{SocketCodeTable}
instance (see Section~\ref{sec:SocketCodeTable}).

\subsection{Interface}

The SocketEncoding class has the following interface:

\begin{description}
\item[SocketEncoding(name : string, encoding : int, parent : SlotField\&)]%
  Constructor. Create a socket encoding and register it into the given slot
  field. The socket is identified by name. The (fixed) part of the socket
  encoding and the parent slot field are given as parameters.

  Throw an exception if the parent slot field has an encoding for the same
  socket already or if the encoding is already assigned.
%
  Throw [[exception]] \note{DISCUSS: exception type} if the given encoding
  does not fit in the bit width of the parent slot field.

\item[socketName() : string]%
  Return the name of the socket.

\item[encoding() : int]%
  Return the value of the fixed part of the encoding.

\item[setSocketCodes(codeTable : SocketCodeTable\&, encoding : int)]%

  Attach a set of socket codes to the socket encoding and set a new value
  for the fixed part of the socket encoding. If not given, the existing
  encoding value is used as the fixed part of the encoding. The socket codes
  by default take the least significant bits of the sockete encoding.

  Throw \emph{ObjectAlreadyExists} exception if the fixed part of the socket
  encoding is assigned to another socket already.
%
  Throw [[exception]] \note{DISCUSS: exception type} if the encoding (new or
  existing, does not matter) does not fit in the bit width left for the
  fixed part of the socket encoding.

\item[setEncoding(encoding : int)]%
  Set new encoding for the socket.

  Throw [[exception]] \note{DISCUSS: exception type} if the encoding does
  not fit in the bit width of the parent slot field.

\item[unsetSocketCodes()]%
  Unset the socket code table. The bits reserved to the socket codes are
  assigned to the fixed socket encoding and set to zero.

\item[hasSocketCodes() : bool]%
  Tell whether the socket encoding contains a socket code table.

\item[socketCodes() : SocketCodeTable\&]%
  Return the socket code table. Return a \emph{NullSocketCodeTable} instance
  if the socket does not have a socket code table set.
\end{description}


\section{SocketCodeTable}
\label{sec:SocketCodeTable}

If a socket is attached to several ports, each port is identified by a
different control code. This control code forms the variable part of the
socket encoding and is defined by \emph{SocketCodeTable} class.

The \emph{SocketCodeTable} class contains objects that represent port
control codes, namely \emph{FUPortCode} and \emph{RFPortCode}, defined,
respectively, in Sections~\ref{sec:FUPortCode}
and~\ref{sec:FUPortCode}.

Because a single \emph{SocketCodeTable} instance can be shared by several
socket encodings, it is not owned by \emph{SocketEncoding} objects. Instead,
socket code tables are owned by \emph{BinaryEncoding} class, which provides
methods to access and handle them.

\subsection{Interface}

The \emph{SocketCodeTable} has the following interface:

\begin{description}
\item[SocketCodeTable(name : string, parent : BinaryEncoding\&)]%
  Constructor. Create a code table and register it to a binary encoding map.
  The name string that identified the table, the bit width of the control
  codes contained in the table and the parent encoding map are given as
  parameters.

  Throw \emph{ObjectAlreadyExists} exception if the binary encoding map
  already contains a socket code table with the same name.

\item[name() : string]%
  Return the name of the table.

\item[setName(name : string)]%
  Set the name of the table.

  Throw \emph{ObjectAlreadyExists} exception if the binary encoding map
  already contains a socket code table with the same name.

\item[width() : int]%
  Return the bit width of control codes in the table.

\item[setExtraBits(bits : int)]
  Sets the number of extra bits to the field. The field can be forced
  longer than necessary by defining some number of extra bits. In
  practice, there will be the given amount of zeros always in the
  MSB end of the field.

\item[extraBits() : int]
  Returns the number of extra bits.

\item[addFUPortCode(code : FUPortCode\&)]%
  Add a control code that identifies the port of a function unit.

  Throw \emph{ObjectAlreadyExists} exception if the port is already encoded
  in this table. This method is to be called from the constructor of
  \emph{FUPortCode} class.

\item[removeFUPortCode(code : FUPortCode\&)]%
  Remove the given FU port code. This method is to be called from the
  destructor of \emph{FUPortCode}.

\item[fuPortCodeCount() : int]%
  Return the number of FU ports encoded in this table.

\item[fuPortCode(index : int)]%
  Return the FU port code stored at position \emph{index} in the table.

  Throw \emph{OutOfRange} exception if \emph{index} is out of range.

\item[hasFUPortCode(fu : string, port : string) : bool]%
  Tell whether the socket code table has a control code for the port of
  function unit with name \emph{fu} identified by given name string.

\item[hasFUPortCode(fu : string, port : string, operation : string) : bool]%
  Tell whether the socket code table has a control code that identifies the
  given operation and the port that carries it. The port belongs to the
  function unit with name \emph{fu} and is identified by given name string.

\item[fuPortCode(fu : string, port : string) : FUPortCode\&]%
  Return the code for the port of function unit with name \emph{fu}
  identified by given name string. Return a \emph{NullFUPortCode} if the
  socket code table does not have a code for the given port.

\item[fuPortCode(fu : string, port : string, operation : string) :
  FUPortCode\&]%
  Return the code that identifes the given operation and the port that
  carries it. The port belongs to the function unit with name \emph{fu} and
  is identified by given name string. Return a \emph{NullFUPortCode} if the
  socket code table does not have a code for the given port or if the port
  does not carry the given operation.

\item[addRFPortCode(code : RFPortCode\&)]%
  Add a control code that identifies a register file.\footnote{
%
    In fact, the control code identifies a RF port, but which port is
    irrelevant, since all ports are identical and each must be attached to a
    different socket.}

  Throw \emph{ObjectAlreadyExists} exception if the register file is already
  encoded in this table. This method is to be called from the constructor of
  \emph{RFPortCode} class.

\item[removeRFPortCode(code : RFPortCode\&)]%
  Remove the given RF port code. This method is to be called from the
  destructor of \emph{RFPortCode}.

\item[rfPortCodeCount() : int]%
  Return the number of register file sources or destinations encoded in this
  table.

\item[rfPortCode(index : int)]%
  Return the RF code stored at position \emph{index} in the table.

  Throw \emph{OutOfRange} exception if \emph{index} is out of range.

\item[hasRFPortCode(rf : string) : bool]%
  Tell whether the socket code table has a port code for the register file
  with name \emph{rf}.

\item[rfPortCode(rf : string) : RFPortCode\&]%
  Return the port code for the given RF port. Return a NullRFPortCode if
  there is no code for the given port.
\end{description}

\section{FUPortCode}
\label{sec:FUPortCode}

Class \emph{FUPortCode} represents the control code that identifies an FU
port or, if the port carries an opcode, the combination of port and
operation.

\subsection{Interface}

FUPortCode class has the following interface:

\begin{description}
\item[FUPortCode(fu : string, port : string, portID : int, portIDPos : bool, parent :
  SocketCodeTable\&)]%
  Constructor. Create an encoding for a FU port and register it into a
  socket code table. The port is identified by a name string and by the name
  of its function unit.  The name strings, the parent code table and the
  value of the port ID and its position are given as parameters.

\item[FUPortCode(fu : string, port : string, operation : string, portID : int, opcode : int, portIDpos : bool, parent : SocketCodeTable\&)]%
  Constructor. Create an encoding for a FU port and register it into a
  socket code table. The port is identified by a name string, the
  operation carried by it, and the name of the parent function unit.
  The name strings, the parent code table and the value of the portID
  and opcode and portID position are given as parameters.

\item[fuName() : string]%
  Return the name of the function unit.

\item[portName() : string]%
  Return the name of the port.

\item[portID() : int]%
  Returns the port ID.

\item[opcode() : int]%
  Returns the opcode. Throws an exception if the port code does not carry an
  opcode.

\item[setPortID(portID : int)]
  Sets a new port ID.

\item[setOpcode(opcode : int)]
  Sets a new opcode. Throws an exception if the port code does not define any
  operation.

\item[hasOperation() : bool]%
  Tell whether this control code identifies also one of the operations
  carried by the FU port.

\item[operationName() : string]%
  Return the name of the operation identified by this control code.

  Throw [[exception]] \note{DISCUSS} if this control code identifies a plain
  FU port, without operation.

\item[setPortIDPosition(position : bool)]
  Sets the position of the port ID compared to opcode.

\item[portIDPosition() : bool]
  Returns the port ID position.

\item[width() : int]
  Returns the required bit width of the whole port code (portID + opcode).
\end{description}

\section{RFPortCode}
\label{sec:FUPortCode}

RFPortCode class defines a binary encoding for a register file port.

\subsection{Interface}

The RFPortCode Class has the following interface:

\begin{description}
\item[RFPortCode(rf : string, port : string, encoding : int, indexWidth : int, parent : SocketCodeTable\&)]%
Constructor. Name of the register file and port as well as the
binary encoding are given as parameters. Also the bit width of the
register index which is given when the port is read or written, is
given. Registers the created instance to the given \emph{SocketCodeTable}
automatically. Throws an exception if the parent \emph{SocketCodeTable} has
an encoding defined for the same port already or if the given encoding
is assigned to another port already.
\item[rfName() : string]%
Return the name of the register file.
\item[portName() : string]%
Return the name of the port.
\item[encoding() : int]%
Return the encoding.
\item[setEncoding(encoding : int)]%
Set new encoding for the port. Throws an exception if the encoding is
assigned to another port already.
\item[indexWidth() : int]%
Return the bit width of the register index.
\end{description}



\chapter{REJECTED ALTERNATIVES}

% Rejected alternatives for (parts of) the design should be listed here with
% the reasoning and date the alternative was dumped. For future reference.
%
%18.11.2003 . . .



\chapter{IDEAS FOR FURTHER DEVELOPMENT}

% Ideas that are not part of the design yet but that might be added in the
% future are listed here. This is to have ideas written down somewhere.
% This list should contain the date of addition, the idea described briefly
% and the inventor of the idea.

\section{Helper Class to Extract Opcode Tables}

Very often there is a structure in the control codes of opcode-setting FU
ports, that is, in the encoding of FU ports that carry an operation
code. These control codes are separated into a fixed part, which identifies
the physical port, and a variable part, which identifies the operation to
execute.

\emph{OperationCodeTable} could be a helper class that maps operations to
control codes (also called ``opcodes''). Operation code tables may be
created by clients of \emph{BinaryEncoding} to extract common sets of
operations identified by the same control codes among several different
socket code tables.

The primary motivation of such an abstraction is to introduce order and
structure where they are present and ease development of BEM files by means
of specialised applications.

The extraction of operation codes is only possible when several codes that
identify the same FU port are identified within their socket code table by
the same fixed part of their encoding, while the variable part identifies
the various operations that can be carried by the FU port.

The interface of \emph{OperationCodeTable} could be:

\begin{description}
\item[OperationCodeTable(name : string, width : int)]%
  Constructor. Create an operation code table identified by string
  \emph{name}. The bit width of the operation codes is given as parameter.

\item[name() : string]%
  Return the name of the table.

\item[width() : int]%
  Return the bit width of the operation codes in the table.

\item[addOperationCode(name : string, encoding : int)]%
  Map the operation with given name to \emph{encoding} control code.

  Throw an exception if \emph{encoding} is a number already assigned to
  another operation, of if it does not fit to the bit width of the table.

\item[removeOperationCode(name : string)]%
  Remove the mapping of the operation with given name from the table.

\item[operationCount() : int]%
  Return the number of operations encoded in this table.

\item[operation(index : int) : string]%
  Return the name of the operation that has a control code stored at
  position \emph{index} in the table.

  Throw \emph{OutOfRange} exception if \emph{index} is out of range.

\item[encoding(name : string) : int]%
  Return the encoding of the operation with the given name.
\end{description}

The client that manages these operation code tables will
probably nedd to implement the following interface:

\begin{description}
\item[opcodeTableCount() : int]%
  Return the number of operation code tables currently managed.

\item[opcodeTable(index : int) : OperationCodeTable\&]%
  Return the operation code table at position \emph{index}.

  Throw \emph{OutOfRange} exception if \emph{index} is negative or is not
  smaller than the number of operation code tables currently managed.

\item[addOpcodeTable(table : OperationCodeTable\&)]%
  Add the given operation code table to the set of tables currently
  managed.

  Throw \emph{ObjectAlreadyExists} exception if an operation code table with
  same name is already managed.

\item[removeOpcodeTable(table : OperationCodeTable\&)]%
  Remove the given operation code table from the set of tables currently
  managed.
\end{description}



\chapter{PENDING ISSUES}

% Pending issues concerning this design, a sort of TO DO list.
% This chapter should be empty when implementation of this module/subsystem
% is completed.



\chapter{MAINTENANCE}

% This chapter treats the problem of extending the design with new
% capabilities that fit in a predefined framework.

% For example, in case of the TPEF module, this chapter could describe the
% steps that must be taken in order to add a new Section subclass and/or a
% SectionReader subclass.

% Remove this chapter no obvious and standardised way to extend the design
% with new capabilities exists.


% ------------------------------------------------------------------------

%  References are generated with BibTeX from a bibtex file.
\bibliographystyle{alpha}
\cleardoublepage
%% Equivalent to a chapter in the table of contents
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}



\end{document}

%%% Local Variables:
%%% mode: latex
%%% mode: auto-fill
%%% TeX-master: t
%%% End:
