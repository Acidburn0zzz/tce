\documentclass[a4paper,twoside]{tce}

\begin{document}
\author{Veli-Pekka J‰‰skel‰inen}
\title{Proxim}
\ver{0.6}
\firstday{3.1.2005}
\lastday{13.04.2006}
% id number in S- sequence
\docnum{\#\#\#}
% draft/complete/committed
\state{draft}

\maketitle


\chapter*{Document History}

\begin{table}[htb]
\begin{center}
\begin{tabular}{p{0.08\textwidth}p{0.10\textwidth}
                p{0.16\textwidth}p{0.55\textwidth}}
Version & Date       & Author          & Comment\\
\hline
 0.1    & 03.01.2005 & Veli-Pekka J‰‰skel‰inen & Document template.\\
 0.2    & 10.02.2005 & Veli-Pekka J‰‰skel‰inen & Most of the class descriptions
                                                 written.\\
 0.3    & 18.02.2005 & Veli-Pekka J‰‰skel‰inen & Added class diagram etc. \\
 0.4    & 02.05.2005 & Veli-Pekka J‰‰skel‰inen & Major update. Changed
                                                 application name to Proxim,
                                                 updated design to correspond
                                                 to prototyped
                                                 implementation.\\
 0.5    & 03.03.2006 & Veli-Pekka J‰‰skel‰inen & Updated documentation. Some
                                                 class descriptions and the
                                                 class diagram are still not
                                                 up to date.\\
 0.6    & 13.04.2006 & Veli-Pekka J‰‰skel‰inen & Updated class diagram. Updated
                                                 some class descriptions.\\
\hline
\end{tabular}
\end{center}
\end{table}

% Table of contents
\tableofcontents

% Document text
\chapter{INTRODUCTION}

\section{Purpose and Scope}

This document gives an overview of the design of Proxim.
Proxim is a graphical user interface module for the TTA Processor
Simulator. Description of the TTA Processor Simulator can be found in the
document \cite{SimulatorSpecs}.


\section{Definitions}

% Uncomment this to enable the ``term explanation box''
%\begin{description}
%\item[term]
%    term definition
%\end{description}


\section{Acronyms and Abbreviations}

\begin{table}[htb]
\begin{center}
\begin{tabular}{p{0.15\textwidth}p{0.85\textwidth}}
TTA & Transport Triggered Architecture\\
GUI & Graphical User Interface \\
LMB & Left mouse button\\
RMB & Right mouse button\\
 \ldots &  \ldots \\
\end{tabular}
\end{center}
\end{table}


\chapter{ARCHITECTURE}

\section{``Philosophy of Design''}

Proxim is a GUI module for the TTA Processor simulator engine, and all
simulation logic is contained in the TTA Processor Simulator. See
\cite{simulatorModDesign} for overview of the Simulator modules.

Internally, the module is divided to two components which are ran in separate
threads: 
simulator engine wrappper encapsulates the simulator in a worker
thread and GUI thread manages the user interface and controls the simulator
engine. The interaction of these two threads is the most complex part of the
Proxim design, and it is documented in chapter FIXME.

The user interface is implemented using wxWidgets crossplaform GUI library.
More information about wxWidgets can be found in \cite{wxWidgets}.
Most of the Proxim classes are derived from the wxWidgets classes
and therefore follow the wxWidgets framework class hierarchy.


\section{External Modules/ Application Environment}

The general idea is that the Proxim knows as little as possible
about the internal workings of the Simulator. However, Proxim needs to
access models of the simulated program and processor directly.

Proxim uses the following data owned by the Simulator:
\begin{itemize}
\item \emph{Machine object model} of the simulated processor is needed to
create the processor visualization in the MachineStateWindow.
\item \emph{Machine state model} of the simulated processor is needed to
display the current status of machine components in the machine status window.
\item \emph{Program object model} of the simulated program is needed to
display the machine code of the simulated program in the machine code
window.
\end{itemize}

\chapter{MODULE DESIGN}
\section{Threading Overview}
\label{sec:threading_overview}
Proxim execution is divided into two threads. The simulator engine is
ran in a worker thread, controlled by a GUI thread. The execution is split
into two threads mainly because the GUI can't be locked in an inoperative state
when the simulator engine is running a simulation.

Threading of Proxim is implemented using the portable threading system
of wxWidgets. The GUI thread is the main thread created by the wxWidgets
framework, so there is no wxThread derived class for it. The simulator
engine thread is implemented in the ProximSimulationThread class, which
is derived from the wxThread class.

The communication between these two threads is done in two different ways:

The simulator engine thread signals the GUI thread about simulator state
changes by sending SimulatorEvents, which is a custom class derived from
the wxEvent class. The wxWidgets event system is the recommended method of
signaling in the wxWidgets threading system.

The simulator engine thread can't be controlled using wxEvents, because the
thread doesn't have an event handler listening for wxEvents. Another reason
for not using wxEvents when controlling the simulator engine thread, is that
the simulator interpreter needs a LineReader for textual i/o.

The simulator engine thread is controlled by the GUI thread by using
a thread-safe LineReader. ProximLineReader acts as a two-way interface between
the threads. The user input, whether it's a textual command in the console, or
a command initiated using the menubar, is sent as a command string to the
linereader. Simulator engine thread requests the command strings from the line
reader.

LineReader interface specifies an outputStream() -function which returns an
output stream that is used in simulator to direct the textual output from the
simulator to the user interface. In the ProximLineReader the output
stream is implemented using a stringstream, which the simulator engine thread
writes, and the GUI thread reads.

\section{Simulator Events}

Simulator state changes are signaled from the simulator engine thread to the
GUI thread by posting SimulatorEvents. Possible event types and their meanings
are as follows:
\begin{itemize}
\item \emph{EVT\_SIMULATOR\_START:} Simulation engine has started simulation.
This event is sent even if only a single instruction is simulated using step
or next command.
\item \emph{EVT\_SIMULATOR\_RUN:} Simulator engine has started to run
a simulation, or continued to run a stopped simulation. This event is not sent
if the simulation is advanced using next/step instruction methods.
\item \emph{EVT\_SIMULATOR\_STOP:} Simulator has stopped to run simulation.
\item \emph{EVT\_SIMULATOR\_TEXT:} The simulator interpreter returned textual
output in response to the last executed command. The output is set as the
data string of the event.
\item \emph{EVT\_SIMULATOR\_RUNTIME\_ERROR:} Simulator encountered
a runtime error while simulating. Possible error message is set as the event
data string.
\item \emph{EVT\_SIMULATOR\_RUNTIME\_WARNING:} Simulator encountered
a runtime warning while simulating. Possible warning message is set as the
event data string.
\item \emph{EVT\_SIMULATOR\_ERROR:} The simulator encountered an error. Error
explanation text is set as the event data string.
\item \emph{EVT\_SIMULATOR\_COMMAND:} A command string is sent to the simulator
interpreter. The sent command string is set as the event data string.
	\item \emph{EVT\_SIMULATOR\_COMMAND\_DONE:} Execution of the last command is
completed.
\item \emph{EVT\_SIMULATOR\_LOADING\_MACHINE:} Simulator has started to load
a new machine.
\item \emph{EVT\_SIMULATOR\_MACHINE\_LOADED:} A new machine description is
loaded in the simulator.
\item \emph{EVT\_SIMULATOR\_LOADING\_PROGRAM:} Simulator has started to load
a new program.
\item \emph{EVT\_SIMULATOR\_PROGRAM\_LOADED:} A new program is loaded in the
simulator.
\end{itemize}

SimulatorEvent handlers can be set in the wxWindow event tables using the
following macros:
\begin{itemize}
\item \emph{EVT\_SIMULATOR\_START(id, function):} sets the event handler
function for EVT\_SIMULATOR\_START events.
\item \emph{EVT\_SIMULATOR\_STOP(id, function):} sets the event handler
function for EVT\_SIMULATOR\_STOP events.
\item \emph{EVT\_SIMULATOR\_TEXT(id, function):} sets the event handler
function for EVT\_SIMULATOR\_TEXT events.
\item \emph{EVT\_SIMULATOR\_ERROR(id, function):} sets the event handler
function for EVT\_SIMULATOR\_ERROR events.
\item \emph{EVT\_SIMULATOR\_COMMAND(id, function):} sets the event handler
function for EVT\_SIMULATOR\_COMMAND events.
\item \emph{EVT\_SIMULATOR\_LOADING\_MACHINE(id, function):} sets the event
handler function for EVT\_SIMULATOR\_LOADING\_MACHINE events.
\item \emph{EVT\_SIMULATOR\_MACHINE\_LOADED(id, function):} sets the event
handler function for EVT\_SIMULATOR\_MACHINE\_LOADED events.
\item \emph{EVT\_SIMULATOR\_LOADING\_PROGRAM(id, function):} sets the event
handler function for EVT\_SIMULATOR\_LOADING\_PROGRAM events.
\item \emph{EVT\_SIMULATOR\_PROGRAM\_LOADED(id, function):} sets the event
handler function for EVT\_SIMULATOR\_PROGRAM\_LOADED events.

\end{itemize}

\section{Simulator Event Handling}
SimulatorEvents are posted to the ProximMainFrame using the standard wxEvent
processing system of wxWidgets. ProximMainFrame processes all SimulatorEvents
by forwarding a copy of the event to each sub window registered as a simulator
listener. This allows subwindows to update themselves automatically whenever
it's necessary. Although a subwindow receives all simulator events, it doesn't
have to handle any events. If the subwindow doesn't define an event handler
function for an event type, the event is automatically skipped.

\chapter{CLASSES}

\begin{figure}[htb]
\centerline{\psfig{figure=eps/ClassDiagram.eps,width=0.9\textwidth}}
\caption{Diagram of Proxim core classes.}
\label{fig:class_diagram}
\end{figure}

Figure \ref{fig:class_diagram} shows the core classes of Proxim
and their relations.

\section{Proxim}
Proxim is the main class of the application. It is derived from the
wxApp class, which represents the application itself in the wxWidgets
framework. Proxim class interprets the command line parameters,
initializes the application and creates the main window.

Proxim also creates and owns the CommandRegistry and GUIOptions instances.


\section{ProximMainFrame}
ProximMainFrame is the top level parent window of the GUI. It is derived
from the wxFrame class. ProximMainFrame owns and manages all Proxim subwindows.
All subwindows are derived from the ProximSimulatorWindow class.

ProximMainFrame also initializes the application menubar and toolbar and
handles events generated by them. The events are handled by requesting
commands from the CommandRegistry which correspond the menu/toolbar item
IDs.

\section{ProximSimulatorWindow}
ProximSimulatorWindow is a baseclass for Proxim subwindows that are interested
in simulator engine events. The baseclass contructor registers and destructor
untegisters the window automatically as a simulator event listener.

\section{ConsoleWindow}
ConsoleWindow is a generic console, which can display text from an
output stream, and direct input text to a ProximLineReader instance.
ConsoleWindow doesn't have any command parsing logic, and the input text
is sent to the linereader as it is.

\section{ProximLineReader}
ProximLineReader implements the LineReader interface, solving
the problem of interfacing a LineReader with a GUI running in another thread.
The user input reading functions of the LineReader
interface work the following way:

\begin{enumerate}
\item Simulator engine thread requests user input, and starts to listen
to a wxCondition. This suspends the worker thread until the wxCondtion is
signaled.
\item The user enters a command, and the GUI thread event handlers pass
the user input to the ConsoleWindowLineReader.
\item The command is set as the LineReader input, and the wxCondition is
signaled about the new input.
\item The signal wakes up the simulator engine thread, which receives the
command from the LineReader.
\end{enumerate}

\section{ProximMachineStateWindow}
ProximMachineStateWindow is a parent window for an instance of MachineCanvas.
The window contains a horizontal splitter window. Left hand
side of the splitter window cointains simulation status information,
and information about the machine component selected in the MachineCanvas.
Right hand side of the splitter window contains a MachineCanvas instance
displaying status of the simulated processor.

\section{MachineCanvas}
MachineCanvas is a generic window for visualizing Machine Object
Models. MachineCanvas is the main class of wxToolkit's machine object model
visualization library. See wxToolkit documentation for details.

\section{ProximDisassemblyWindow}
ProximDisassemblyWindow utilizes a wxGrid to display disassembly of the
simualted program. Each instruction is displayed on own line, with
disassembled instruction moves. The disassembly window updates itself
automatically whenever a SimulatorEvent requiring an updated is received.
The context menu actions of the window are processed internally in the window
and all user commands are sent as string commands to the LineReader.

\section{ProximMemoryWindow}
ProximMemoryWindow utilizes MemoryControl widget of the wxToolkit library to
display contents of the simulated memory. See wxToolkit documentation for
MemoryControl details.

\section{ProximSimulationThread}
Derived from the wxThread class, which is a base class for portable wxWidgets
threads. ProximSimulationThread class wraps the simulation backend in
a separate worker thread. ProximSimulationThread runs the simulator engine by
requesting commands in a loop from the user and passing them to the
SimulatorInterpreter. The cycle of requesting and processing commands
is executed until the thread is terminated.

\section{SimulatorEvent}
SimulatorEvent is an event class, which is used to pass information about
the simulator events and state changes to the GUI thread. List of possible
event types and corresponding event table macros is in section FIXME.
SimulatorEvents have to kind of event information: the event type ID
which defines what happened and a payload data string. The meaning
of the data string depends on the event type, and is not used with all
event types. Meaning of the data string for each type is listed in the
section FIXME.


\section{TracedSimulatorFrontend}
TracedSimulatorFrontend is a class which adds events to the
SimulatorFrontend baseclass. TracedSimulatorFrontend implements the Informer
interface and passes events whenever the simulator state changes. This allows
the simulation engine thread to track the simulator state by registering
itself as a listener of the simulator events.


\chapter{REJECTED ALTERNATIVES}

2.5.2005 Single threaded design.

The first draft of the Proxim design described a design, where the simulator
engine was not ran in a separate thread. Running the simulator engine in the
same thread as the GUI would have caused problems, because the GUI would
have been locked whenever the simulator engine is busy. However it is
essential that the simulator user can break the simulation at any point,
so the design with no separate thread for the simulator engine was dumped.

\chapter{IDEAS FOR FURTHER DEVELOPMENT}

% Ideas that are not part of the design yet but that might be added in the
% future are listed here. This is to have ideas written down somewhere.
% This list should contain the date of addition, the idea described briefly
% and the inventor of the idea.

% Example:
%
% 18.11.2003 . . . -P.J‰‰skel‰inen

\chapter{PENDING ISSUES}

% Pending issues concerning this design, a sort of TODO list.
% This chapter should be empty when implementation of this module/subsystem
% is completed.

\chapter{MAINTENANCE}

% This chapter treats the problem of extending the design with new
% capabilities that fit in a predefined framework.

% For example, in case of the TPEF module, this chapter could describe the
% steps that must be taken in order to add a new Section subclass and/or a
% SectionReader subclass.

% Remove this chapter no obvious and standardised way to extend the design
% with new capabilities exists.


% ------------------------------------------------------------------------

%  References are generated with BibTeX from a bibtex file.
\bibliographystyle{alpha}
\cleardoublepage
% Equivalent to a chapter in the table of contents
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}



\end{document}
