\documentclass[a4paper,twoside]{tce}

\begin{document}
\author{Veli-Pekka J‰‰skel‰inen}
\title{TCE wxToolkit Library}
\ver{0.4}
\firstday{11.10.2004}
\lastday{30.12.2005}
\docnum{\#\#\#}
\state{draft}

\maketitle


\chapter*{Document History}

\begin{table}[htb]
\begin{center}
\begin{tabular}{p{0.08\textwidth}p{0.10\textwidth}
                p{0.16\textwidth}p{0.55\textwidth}}
Version & Date       & Author          & Comment\\
\hline
 0.1    & 11.10.2004 & J. Nyk‰nen      & Initial version\\
 0.1.1  & 12.10.2004 & J. Nyk‰nen      & Added information about MemoryControl
                                         and MemoryGrid.\\
 0.2    & 26.10.2004 & VPJ             & Added information about NumberControl
                                         and HelpBrowser.\\
 0.3    & 20.12.2005 & VPJ             & Updated MachineCanvas and MemoryWindow
                                         specs. Moved machine canvas
                                         implementation details, written by
                                         Ari Mets‰halme, from the ProDe design
                                         document to this document.\\
 0.4    & 30.12.2005 & VPJ             & Added information about GUIOptions.\\
\hline
\end{tabular}
\end{center}
\end{table}


\tableofcontents


\chapter{INTRODUCTION}

\section{Purpose and Scope}

This document describes the design of wxToolkit library. This document can be
used by the clients of the library as the reference manual. wxToolkit is a
toolkit for generic modules used by applications that uses wxWidgets as 
graphic library.

\section{Acronyms and Abbreviations}

\begin{table}[htb]
\begin{center}
\begin{tabular}{p{0.15\textwidth}p{0.85\textwidth}}
 TCE  & TTA Codesign Environment\\
\end{tabular}
\end{center}
\end{table}


\chapter{Dialogs}

wxToolkit contains a number of useful dialogs for graphical user interfaces.
These dialogs are confirmation dialog, error dialog, information dialog, and
warning dialog. The usage of each dialog is straightforward. The following
example shows a common usage:

\begin{verbatim}
void
ExampleDialog::doSomething() {
  // error occurs
  ErrorDialog error(this, _T(``Error occured''));
  error.ShowModal();
}
\end{verbatim}

Each dialog takes two parameter: parent window and a message. 
Figure~\ref{fig:dialog} shows an example of the error dialog. 
The other dialogs are quite similar.

\begin{figure}[htb]
\centerline{\psfig{figure=eps/Dialog.eps,width=0.2\textwidth}}
\caption{Example of dialog.}
\label{fig:dialog}
\end{figure}

\chapter{CommandRegistry and GUICommand}

\emph{CommandRegistry} and \emph{GUICommand} are classes for handling command
events. CommandRegistry contains GUICommands that then executes commands.
The usage is simple: application has CommandRegistry in which all the commands
are registered. When command event occurs, CommandRegistry is searched for such
command and that command is then executed if it is found.

\section{Interface of CommandRegistry}

Interface contains functions for adding new commands and retrieving information
of the contained commands.

\paragraph{void addCommand(GUIcommand* command)}
Adds a new command to command registry.

\paragraph{GUICommand* createCommand(const int id)}
Creates a new command with given id and returns it. If command with given
id is not found, returns NULL.

\paragraph{GUICommand* createCommand(const std::string name)}
Creates a new command with given name and returns it. If command is not
found, return NULL.

\paragraph{GUICommand* firstCommand()}
Returns a pointer to the first command in command registry or NULL if 
command registry is empty.

\paragraph{GUICommand* nextCommand()}
Returns pointer to the next command or NULL, if no further commands are
found.

\paragraph{string commandShortName(const string name)}
Returns a short name of the given command. Throws InstanceNotFound if command
with given name is not found.

\paragraph{int commandId(const std::string name)}
Returns a command id of the command with given name. Throws InstanceNotFound
if command with given name is not found.

\paragraph{string commandIcon(const string name)}
Returns the path for the command icon of the given command name. Throws
InstanceNotFound if such command is not found.

\paragraph{bool isEnabled(const string command)}
Returns true if command with a given name is enabled (it can be executed).
Throws InstanceNotFound if command with given name is not found.

\section{Interface of GUICommand}

GUICommand is an abstract base class for commands executed by user interfaces.
Interface provides access to command's attributes as well as means to execute
the command.

\paragraph{GUICommand(string name, wxWindow* parent)}
Constructor takes a pointer to parent window and the name of the command.

\paragraph{int id() [pure virtual]}
Returns the id of the command.

\paragraph{GUICommand* create() [pure virtual]}
Creates a command and returns a pointer to it.

\paragraph{bool Do() [pure virtual]}
Executes the command. Returns true if execution is successful.

\paragraph{string icon() [pure virtual]}
Returns the path of the command's icon. If command does not have an icon,
empty string is returned.

\paragraph{bool isEnabled() [pure virtual]}
Returns true if command is enabled, i.e., it can be executed.

\paragraph{string shortName()}
Returns the short name of the command.

\paragraph{void setParentWindow()}
Sets the parent window.

\paragraph{wxWindow* parentWindow()}
Returns a pointer to a parent window.

\paragraph{string name()}
Returns the name of the command.

\section{MemoryControl and MemoryGrid}

\emph{MemoryControl} is widget for showing and modifying the contents of
Memory objects. The format of the memory data is shown either in bits,
hexadecimal or decimal  format.

MemoryControl uses MemoryGridTable to access Memory object contents only
when they are needed. In other words,  MemoryControl doesn't copy Memory
contents to the widget, so even very large memory objects can be displayed
and modified using the widget.

\subsection{MemoryControl interface}

Public interface of MemoryControl contains only constructor, destructor, and
one method for updating the contents of the MemoryGrid. Constructor parameters
are parent window, pointer to memory wrapper object, and the starting and
ending point of the memory.


\chapter{Widgets}

\section{MachineCanvas}
MachineCanvas is a machine object model visualization widget.
Without any customization, the MachineCanvas widget just displays
a non-interactive machine visualization in a scrollable window.
Interactivity of the MachineCanvas can be customized to application's needs by
implementing \emph{EditPolicies} for the component \emph{EditParts}.

\subsection{MachineCanvas architectiure.}
Every visible component in the MachineCanvas has corresponding
EditPart object, which links the actual component in the machine
object model to the visualization. The EditParts form a hierarchy where
every EditPart is a child of another EditPart, except for the special
RootEditPart, which is the top level parent of all EditParts.
Another specialized EditPart, ConnectionEditPart, is used for
representing bus-socket and socket-port connections in the EditPart
hierarchy.

EditParts may contain other EditParts as their children. For example
function unit EditParts contain port EditParts. These container
EditParts may also be invisible, so that they don't correspond to any
concrete machine block, but their only purpose is to parent their
children. An example of such EditPart is the contents EditPart that
parents all the EditParts of the canvas, and is therefore the EditPart
that corresponds to the whole processor. The root EditPart parents the
contents EditPart. It is an instance of a class inherited from
EditPart, i.e. the RootEditPart class. The other subclass of EditPart
is the ConnectionEditPart class which represents a connection between
two EditParts.

Figure objects represent the visuals of an EditPart, that is, how a
machine block should look like on the canvas and where it is
located. Every visible machine block has its own Figure class that is
derived from the Figure base class. Figures can also
have children, and in that case, they know how to layout them. The
Figures of container EditParts are invisible: their responsibility is
to merely layout their child Figures. Laying out the processor on the
canvas is based on Figures laying out their children. Container
Figures inherited from Figure are BusContainerFigure, ContentsFigure,
SocketContainerFigure and UnitContainerFigure.

User interaction is implemented using Requests and EditPolicies.
Each EditPart may have any number of EditPolicies installed. EditPolicies
determine how an EditPart behaves when it receives a Request. If an EditPart
can handle a Request, it will create a ComponentCommand when the Request
is performed. The ComponentCommand can then be executed to perform the
requested action on the component corresponding to the EditPart.

Requests are usually sent by a canvas tool object, derived from the
MachineCanvasTool class. Purpose of canvas tools is to translate
mouse clicks on the canvas to Requests which are sent to the EditParts.

EditPart hierarchy is constructed from a machine object model using edit
part factories. When a machine object is loaded to the MachineCanvas, it
passes the machine object model to a MachineEditPartFactory, which will utlize
component specific factories to create EditPart hierarchy of the complete
machine. Component specific EditPolicies are created using an
EditPolicyFactory.

The MachineEditPartFactory object is responsible for browsing through the
machine model and creating the contents EditPart that corresponds to the
whole machine. It in turn delegates the creation of the EditParts for
each high-level machine block to its registered factories. High-level
in this context means a machine block whose only parent is the machine
itself. These factories can also have registered factories to generate
child EditParts. For example, FUFactory has a UnitPortFactory
registered for creating EditParts for each port in the function
unit. Factories inherited from the Factory base class are
ConnectionFactory which has the subclasses SocketBusConnFactory and
SocketPortConnFactory, and EditPartFactory whose subclasses are:
BridgeFactory, BusFactory, FUFactory, GCUFactory, IUFactory,
MachineEditPartFactory, RFFactory, SegmentFactory, SocketFactory and
UnitPortFactory.

\subsection{Implementation Details on Laying Out the Processor}

In the following, the processor layout algorithm will be described in
high level. Details can be found in the code and its comments.

After the EditPart hierarchy has been constructed, MachineCanvas asks the
root EditPart for its contents. Before the contents can be drawn on
the canvas, they must be laid out by calling the layout method of the
contents EditPart's Figure. It will first recursively layout all the
child Figures (the container EditParts in this case), who in turn
layout their children. After a Figure has laid out its children, it
lays out itself, as can be seen from the implementation of the Figure
class. This means for example calculating and setting the size of a
container etc. If a need arises to first layout a Figure and the
children after that, the basic implementation of the Figure's layout
method must be overridden.

The children of the contents EditPart are the unit container, the bus
container and the socket container. The units are first laid out to
their basic locations starting from the top left corner of the
canvas. The units lay out their child ports, and the ports lay out the
sockets that are connected to them so that the connected sockets are
positioned under the ports, unless there is already a socket. In that
case the socket is positioned to the right hand side of the socket
occupying the space. If a socket is connected to two ports, the port
on the left ``captures'' the socket, if it doesn't already have a
socket positioned under it, in which case, the socket is positioned
under the right port.

Then, the buses and bridges are laid out under the unit
container. This is simply done by positioning the created bus chain
and bus figures vertically one after another. Bus chain figures then
similarly position the BusFigure and BridgeFigure objects in it. These
objects are already correctly ordered in the BusChain in the bus and
bridge EditPart generation part in MachineEditPartFactory.

Finally, the sockets can be laid out. The sockets connected to ports
have the correct y-position already, but unconnected sockets need to
be positioned on the right-hand side of the unit container. Size of
the bus container is naturally set so that the buses reach also the
unconnected sockets.

\subsection{MachineCanvas usage}
Interactive MachineCanvas can be utulized and customized by following these
steps:
\begin{enumerate}
\item{Derive a ComponentCommand class for all actions which can be executed
on the machine components, such as displaying component info, deleting or
modifying a specific component type etc.}
\item{Derive an EditPolicy class for each component type, which needs to
be interacted with. These EditPolicies create the ComponentCommands
implemented in the previous step, when a request is performed on an EditPart.}
\item{Derive an EditPolicyFactory class, which will create custom EditPolicies
implemented in the previous step for interactive components.}
\item{Derive a MachineCanvasTool, which will translate mouse clicks and actions
to suitable requests. MachineCanvasTool has to send the requests to
EditParts. EditPart at the cursor location can be accessed using findEditPart()
method of the MachineCanvas interface.}
\item{Instantiate a MachineCanvas object and pass an instance of the derived
EditPolicyFactory to it's constructor.}
\item{Load a machine object model to be displayed on the canvas by calling the
setMachine() method.}
\item{Set a derived MachineCanvasTool as the canvas tool by calling the
setTool() method.}
\end{enumerate}

\section{NumberControl}

\emph{NumberControl} widget allows numeric values to be displayed and
edited in different formats. The available formats are:

\begin{itemize}
\item Binary
\item Decimal integer
\item Decimal unsigned integer
\item Hexadecimal
\item Floating point number
\end{itemize}

The widget consist of a text field and a choice control. The numeric value
format can be changed using the mode choicer control, which contains choice
item for each available format. Available input modes can be defined to the
widget constructor using style flags MODE\_HEXDECIMAL, MODE\_BINARY,
MODE\_INT, MODE\_UNSIGNED and MODE\_FLOAT. The mode choicer can be disabled
using NO\_MODE\_CHOICER flag.

The textfield validates input depending on the current mode, e.g., if the
widget is in binary mode, only ones and zeros can be entered to the text
field. The conversion between different formats is done using the binary
representation of the values, i.e., the converted value will have the
same binary pattern as the starting value.

\subsection{NumberControl interface}
Public interface of NumberControl contains:
\begin{itemize}
\item Constructor.
\item Destructor.
\item Widget mode setters for all available modes.
\item Mode getter, which returns style flag of the current widget mode.
\item Overloaded widget value setter for setting the numeric value as
  either int, unsigned or float.
\item Widget value getters for int, unsigned and float value of the binary
pattern.
\end{itemize}

\chapter{GUIOptions}

\emph{GUIOptions} is an options framework for graphical user interfaces.
The GUIOptions framework implements handling of keyboard shortcuts and
list configurable toolbar buttons. Application specific options can be
added by deriving new classes from the framework base classes.
The framework consist of the following classes:
\begin{itemize}
\item{\emph{GUIOptions:} Main class of the framework. All options are
stored in an instance of this class.}
\item{\emph{GUIOptionsSerializer:} XML-serializer for saving and loading
options to and from an xml-file.}
\item{\emph{KeyboardShortcut:} Stores attributes of a single keyboard
shortcut.}
\item{\emph{ToolbarButton:} Stores attribures of a single toolbar button.}
\item{\emph{KeyboardShortcutDialog:} Dialog for defining key-combinations
of keyboard shortcuts.}
\item{\emph{OptionsDialog:} Base class for options dialogs. Contains two
option-tabs: keyboard shortcut tab, and a toolbar customization tab.}
\end{itemize}

To add application specific options, follow these steps:
\begin{enumerate}
\item{Derive a class from the GUIOptions base class, which has getters and
setters for the new options.}
\item{Derive a class from the GUIOptionsSerializer class, which handles
writing and reading of the new options to and from an xml-file.}
\item{Derive an OptionsDialog for the application. The OptionsDialog base
class has addPage() -method, which allows the derived classes to add
new option tabs to the dialog.}
\end{enumerate}

\chapter{HelpBrowser}
\emph{HelpBrowser} is a simple frame for displaying html documents.
The browser frame has a toolbar with the following buttons:

\begin{itemize}
\item \emph{Close} button for closing the browser window.
\item \emph{Back} button for navigating to the previous page.
\item \emph{Forward} button for navigating back to the page which was
left using the \emph{Back} button.
\end{itemize}

The html-document is displayed using a wxHtmlWindow widget of the
wxWidgets basic widget set. Documentation for the supported html tags
can be found in the wxWidgets documentation \cite{wxWidgets}.

\section{HelpBrowser Interface}
The public interface of the HelpBrowser contains only a constructor
and a destructor. The path to the html file to display is passed to
the constructor.
\end{document}
