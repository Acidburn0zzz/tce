\documentclass[twoside]{tce}

\usepackage{pslatex}

\begin{document}
\author{Andrea Cilio, Pekka J\"a\"askel\"ainen}
\title{Operation Set Abstraction Layer}
\ver{0.11.0}
\firstday{25.11.2003}
\lastday{14.03.2007}
% id number in S- sequence
\docnum{027}
% draft/complete/committed
\state{draft}
\maketitle

% highlighted style for parameters/variables or otherwise non-fixed parts
% of a command syntax or of lines of text displayed by the application
\newcommand{\parm}[1]{\textsl{#1\/}}

% commands to produce XML tags and elements
\newcommand{\xmltag}[1]{\texttt{<#1>}}
\newcommand{\xmlelem}[2]{\texttt{<#1> #2 </#1>}}
\newcommand{\xmlaelem}[3]{\texttt{<#1 #2> #3 </#1>}}

\chapter*{Version History}

\begin{HistoryTable}

 0.1   & 11.11.2003 & A. Cilio     &
 First incomplete draft.\\

 0.2   & 16.02.2004 & A. Cilio     &
 Completely revised.  Extended chapters 3,5,11. \\

 0.3   & 24.02.2004 & A. Cilio     &
 Chapter 4 (incomplete). Extended: 5.1,11. \\

 0.4   & 04.03.2004 & A. Cilio     &
 Completely revised. Behavior definition, 5.1.  Database files,
 5.3. Extended: 4.2, 4.3, 11. \\

 0.5   & 22.03.2004 & A. Cilio     &
 Completely revised chapters 1--4.  API specifications moved to design
 document.  \\

 0.6   & 23.03.2004 & A. Cilio     &
 Revised and extended: 5,8,11.  Properties in XML format. \\

 0.7   & 29.03.2004 & A. Cilio     &
 Partial revision after review by P. J\"a\"askel\"ainen. Removed
 nonfunctional specifications, 4. Added: 4.2.3,4.2.6.\\

 0.8   & 30.03.2004 & A. Cilio     &
 Revised introduction, 1. Extended and revised: 10,11. \\

 0.9 & 24.05.2004 & A. Cilio &
 Added rejected idea: operand aliases.  Added section on helper
 applications, 4.4. \\

 0.10 & 09.06.2004 & P. J\"a\"askel\"ainen &

 Changed \emph{memory} tag of Operation properties to \emph{writes-memory}
 and \emph{reads-memory} tags. Updated the behavior description language to
 match the implementation. Corrected spelling. \\
 
 0.10.1 & 29.07.2004 & P. J\"a\"askel\"ainen &
 The search paths of operations in \emph{base} and \emph{custom} changed to
 \verb\$ROOT/share/tce\. \\

 0.10.2 & 30.07.2004 & P. J\"a\"askel\"ainen &
 Minor changes to OSAL Builder specifications. \\

 0.10.3 & 31.08.2004 & P. J\"a\"askel\"ainen &
 Added examples of load and store operations.\\

 0.10.4 & 01.09.2004 & A. Cilio &
 Minor change to operation behaviour file requirements. \\

 0.11   & 06.09.2004 & P. J\"a\"askel\"ainen &
 Updated behavior definition language to ``as built''.\\

 0.11.1 & 21.10.2004 & L. Laasonen &
 Changed name of MDF to ADF.\\

 0.11.2 & 02.08.2005 & P. J\"a\"askel\"ainen &
 Couple of minor corrections.\\

 0.11.3 & 03.08.2005 & P. J\"a\"askel\"ainen &
 Reverted removal of `trap' property of operation.\\

 0.11.4 & 03.08.2005 & A. Cilio &
 Assigned document number. \\

 0.11.5 & 02.12.2005 & A. Cilio &
 Cleanup and update of state macros. \\

 0.11.6 & 12.12.2005 & P. J\"a\"askel\"ainen &
 Now INT macro gives signed integers; introduced UINT. \\
 
 0.11.7 & 05.01.2006 & P. J\"a\"askel\"ainen &
 Allow underscore in operation name strings. \\
 
 0.11.8 & 25.04.2006 & A. Cilio &
 Minor update to `as is' state. \\

 0.11.9 & 22.08.2006 & Veli-Pekka J\"a\"askek\"ainen &
 Updated OSAL behavior language documentation. IO macro introduced and related
 changes made. \\

 0.11.10 & 18.12.2007 & Mikael Lepist\"o &
 Updated trigger semantics block and io type attribute to operation declaration.

\end{HistoryTable}


\tableofcontents



\chapter{INTRODUCTION}

\section{Purpose}

This document describes the abstraction layer that represents the operation
repertoire supported by the target architecture template of the TCE toolset.
The purpose of this document is threefold.  First, it gives an overview of the
abstraction layer and the motivations for it.  Second, it provides the
complete functional specifications needed to design the abstraction layer
module. Third, it describes the macro definition set that constitute the
``operation behavior language'' used to describe simulation behavior for
operations.

\section{Product Idea}

TCE is a toolset based on a templated, parametrized processor architecture.
The operation set of TTA processors must be completely configurable.
Operations are selected from a global repertoire of the target architecture
template.  For maximum flexibility, it must be possible to add new
operations to the repertoire without requiring recompilation of the
applications that depend on operation properties.

Many TCE applications depend on properties of the operations implemented on
a given target processor.  Therefore, it is convenient that the operation
set be a separate module that implements a centralized service.  The
properties and behavior of operations are accessible through a standardized
interface.  Also the way operations properties are stored is standardized.

There is no fundamental distinction between operations that are predefined
and distributed together with the toolset and custom, user-defined
operations: All operations are defined and used in the same way.

Typical applications will need only a small subset of all operations in the
architecture template repertoire.  Most applications are expected to work
with a given target processor architecture, which implements only a fraction
of the operation set in the repertoire.

\section{Product Overview}

OSAL implements a model of the operation repertoire available in the target
architecture template of the TCE toolset with the following properties:
\begin{enumerate}
\item %
  Uniqueness: properties and behavior of operations are stored in one place
  and are shared by all tools that access the operation model.
\item %
  Generality: the operation model is valid with any hardware implementation
  of the operation, because it does not specify parameters that depend on
  the hardware implementation.
\item %
  Consistency: the format in which properties and behavior of operations
  are defined is the same for all operations.
\item %
  Flexibility: operation properties and behavior can be loaded individually
  by the clients, on a ``as-needed'' basis.
\end{enumerate}

The OSAL module provides a common interface to access the operation
repertoire of the TTA template and the properties and the behavior of
operations in the repertoire.

Implementation-independent information about operations is stored in data
files and dynamic modules.  Applications open and link to functions and
objects of these modules at run time to obtain a behavior model of the
operations, that is, code to emulate operations.

Operations are identified and referenced by their name, which must be unique
across the whole repertoire.  In general, access to the operation properties
will suffice and an application does not need to know the specific semantics
of the operations.  However, some TCE applications need to recognize certain
basic operations.  For example, a code optimizer or an instruction scheduler
may need integer sum and load from memory to generate register spill code.
For this reason, the name of certain basic operations is predefined and
reserved.

Before being able to access properties and behavior model of an operation,
OSAL clients must lookup the operation itself.  OSAL clients are free to
lookup operations in any order and at any time of the OSAL extent.  It is
not required to load all (required) operation definitions when the client
initializes the access to OSAL.  Operations can be looked up only
individually.

\subsection{Restrictions}

The operation model provided by OSAL is purely architectural.  The hardware
implementation of the operations is completely outside the scope of OSAL.
Therefore, implementation-dependent aspects of operations are not included
in the operation model.

A high-level, purely behavioral implementation in a hardware description
language, such as VHDL, of the operation should be specified in a separate
subsystem of the TTA Codesign Environment.  There can be several such
hardware implementation for the same operation.

\section{Definitions}

\begin{description}
\item[Application]%
  A stand-alone executable program that provides services for users of the
  TCE toolset. It may be controlled by a command-line interface or by a
  graphical user interface, or via a driver application that integrates a
  group of related applications.
\item[Instruction] %
  In Transport Triggered Architectures, a set of programmed data transports
  that are executed in parallel in a single clock cycle of the target
  processor.
\item[Operation] %
  The minimum amount of activity that can be performed by a function unit
  and that has an effect on the accessible architecture state.  In a
  sequential processor architecture, operations are equivalent to machine
  instructions.
\item[Repertoire] (of operations) %
  The set of all operations that may be implemented in a processor that
  instantiates the TTA template.
\end{description}

\section{Acronyms and Abbreviations}

\begin{center}
\begin{longtable}{p{0.15\textwidth}p{0.85\textwidth}}
API   & Application Programming Interface. \\
MAU   & Minimum Addressable Unit (of a memory address space). \\
OSAL  & Operation Set Abstraction Layer.  \\
TCE   & TTA Codesign Environment. \\
TTA   & Transport Triggered Architectures. \\
\end{longtable}
\end{center}



\chapter{USER DESCRIPTION}

\section{User Profile}

There are two types of users of the OSAL: \emph{tool developers} and
\emph{toolset users}.

Tool developers need to access the operation set interface when implementing
any application that requires information on the operations supported by the
target processor. Tools that access operation properties include (but are
not limited to) simulator, instruction scheduler, code optimization passes.

Depending on their needs, toolset users may require different levels of
knowledge about the Operation Set:
\begin{enumerate}
\item %
  A user who defines or works with target processors that support only
  predefined (possibly custom) operations, refer to the operations supported
  by the target architecture by their name and does not have to know
  anything about of the operation models stored in OSAL.
\item %
  A user who defines new custom operations for the target architecture
  template must know the standard format used to define operations and where
  the definitions can be installed.
\end{enumerate}

\section{Key User Needs}

One consistent format for all operation definitions: custom, user-defined
operations and predefined operations are specified in the same format.

Run-time operation configuration. The user who defines new operations have
to build the new definitions, but after the new operation definitions are
compiled and installed, can run any tool without need to relink them.
Linkage to required operation data occurs at run-time.

Only minimal, strictly necessary knowledge is demanded from the user.
%
A user of the toolset needs to know only the name of a previously installed
custom operation to use it in the source code.
%
A tool developer needs know nothing about how operations are defined if only
pre-installed operations are used; knowledge of the Operation Set
Abstraction Layer interface is sufficient.



\chapter{PRODUCT OVERVIEW}

\section{Product Perspective}

The OSAL module is part of the software subsystem of the TCE toolset and
provides fundamental services needed, among others, by the most important
domain object models: target processor and TTA program.

The OSAL consists of two parts:
\begin{enumerate}
\item %
  A fixed interface to access operations in the architecture template
  repertoire.
\item %
  The model of each operation in the repertoire.
\end{enumerate}
%
The model of an operation defines its static properties and its behavior.
The definition of an operation consists of a list of properties and a small
set of functions that model the behavior.  Model information can be
accessed via an operation interface, and is stored in modules that can be
linked at run time.  Each module is defined and compiled independently.

\paragraph{OSAL dependencies.}
The OSAL makes use of low-level services provided by the TCE toolkit
library.

The definition of operations that access memory depends on the Memory Model,
described in~\cite{MemoryModuleDesign}.  See the Simulator Functional
Specifications~\cite{SimulatorSpecs} for specification of Memory Model
requirements.

OSAL does not depend on domain objects.  

\paragraph{Modules that depend on OSAL.}
One fundamental module of the domain library contains references to the
operation models and is thus a client of the OSAL module:
\begin{enumerate}
\item %
  The Program object model
\end{enumerate}

Other clients may directly refer to the operation model interface.  Clients
of OSAL load operation definitions at run time.  References to operations
consist of (unique) name strings.  The client resolves references to the
required operations by giving their name to OSAL and asking it to look up an
operation object with that name.  If lookup succeeds, the client obtains an
object that offers an interface to access the properties and the behavior
of the requested operation.

The order in which dynamic modules are scanned for operations is important.
An operation definition found in a module has precedence over any other
definitions found in modules that are loaded later.

\section{Product Position Statement}

Encapsulate behavior and properties of operations of the target architecture
template behind a single, centralized interface. Enable run-time
configurability of the operation set without relinking client applications
of the operation model.

\section{Summary of Capabilities}

The main capabilities that motivate the Operation Set Abstraction Layer are
summarized in the following table.

\begin{center}
\begin{longtable}{p{0.40\textwidth}p{0.55\textwidth}}
  User Benefit                 &       Supporting Feature \\
\hline
 Consistent way to define operations   & Unique format and set of
                                         conventions used to define
                                         operations; no fundamental
                                         difference between predefined
                                         operation set and custom or
                                         user-defined operations. \\
 Consistent IF for accessing operation & Unique operation interface to
                                         access the behavior and the
                                         properties of operations. \\
 Minimized coding burden on clients    & Organization into shared
                                         modules, unique interface.\\
 Run-time configurability              & Use of run time link capabilities
                                         of dynamic modules. \\
 Performance                           & After dynamic linking, an operation
                                         object may be referenced
                                         directly. \\
 Installation-wide setup               & Possibility to install additional
                                         dynamic modules in a path shared by
                                         all toolset users.\\
 Individual setup                      & Possibility to install additional
                                         dynamic modules in a local path of
                                         the toolset user.\\
\end{longtable}
\end{center}

\section{Assumptions and Dependencies}

In addition to the general dependencies specified in~\cite{ProjectPlan}, the
OSAL requires operating system support for a programming interface to
dynamic linking loader.  This interface is standard in recent versions of
Linux/GNU operating systems, and should be compatible with the interface on
Sun Solaris.

\section{Distribution}

Although part of the system might be released under a public license, the
operation defined by users must be protected as individual intellectual
property.  Further details on the public license are given
in~\cite{ProjectPlan} and~[[license document]].



\chapter{PRODUCT FEATURES}

The Operation Set Abstraction Layer consists of two main parts: a global
interface and set of interfaces related to individual operations.  The
global interface allows to gain access to operations in the operation
repertoire.  The interfaces related to the operation model make it possible
to access properties and behavior of individual operations.

\section{Operation Repertoire}
\label{sec:opset-if}

OSAL global interface consists of methods to manage the target architecture
operation set.

\subsection{Setup of an Operation Repertoire}
\label{ssec:opset-paths}

Any client that needs to access operations of the target architecture
obtains the operation models via the interface of the operation repertoire.
This interface is the root of the OSAL module.

An operation repertoire searches the data files containing operation
definitions in the following paths:
\begin{enumerate}
\item %
  \verb|$ROOT/share/tce/opset/base|
\item %$
  \verb|$HOME/.tce/opset/custom|
\item %
  \verb|$ROOT/share/tce/opset/custom|
\item %
  \verb|$CWD/data|
\item %
  \verb|$CWD|
\end{enumerate}

The parameter \emph{ROOT} contains the path where the toolset is installed,
\emph{CWD} refers to the current working directory, and \emph{HOME} the path
to the home directory of the user who is running the toolset applications.

The first path is reserved to \emph{base operations}.  Generally, base
operations are:
\begin{enumerate}
\item %
  Predefined in the toolset distribution.
\item %
  Generated by fronted compiler directly from source language statements and
  expressions.
\end{enumerate}
Write access to this directory should be restricted to users with
administration rights on the toolset.  The contents of this directory
usually is not changed after installation.

The second path is reserved to custom operations that a user defines and
does not want to share with other users.  Typically, these are custom,
application-specific operations, or domain-specific operations that are not
yet fully tested.

The last three paths are reserved to custom, shared operations. These
operations are typically:
\begin{enumerate}
\item %
  Defined by users and customized for an application domain.
\item %
  Generated from special user-defined assembly macro invocations in the
  source code of the target application.  The fronted compiler does not know
  how to generate such operations.
\item %
  Shared by all users (installation-wide visibility).
\end{enumerate}

These directories should be owned by the user and have no write access
restriction for toolset users, at least for those who design new operations.

The order in which dynamic modules within a directory are accessed is
undefined.

\subsection{Operation Lookup}
\label{ssec:repertoire-lookup}

The fundamental service provided by the operation repertoire is easy
operation lookup.  Operations are identified by a name string.  See
Section~\ref{sec:operation-if} for details.

If an operation with the given name is not found, the application may
proceed undisturbed.  A \emph{null operation} will be returned and possible
errors resulting from failed lookup will be postponed until the missing
operation should effectively be used.  Therefore, it is not error to lookup
an undefined operation in case any data of it is going to be used.

If postponed failure is unwanted, clients of OSAL can check if the looked up
operation is effectively defined.  See Section~\ref{ssec:oper-check} for
details.

\section{Operation}
\label{sec:operation-if}

The Operation Set Abstraction Layer defines a model that provides interfaces
to access properties and behavior of operations.  This model does not
include properties of the hardware implementation such as latency, resource
utilization and bit width (precision).\footnote{
%
  Internal bit width of operations can actually be hard-coded and thus
  determined by operation behavior.}

The OSAL model of an operation represents anything that is known of an
operation and that does not depend on its hardware implementation.

The internal state of operations (where applicable) is not part of the
operation model; it is an independent, external model (see
Section~\ref{sec:oper-state}).  The operation model is simply a client of
the operation state model.

Since the model of a given operation contains only static properties and the
control part of the operation behavior, it can be shared by any client of
the operation model.  What differentiates instances of the same operation
implemented on different function units is the operation-specific state:
each operation implementation has access to a different operation state.

\subsection{Static Properties of Operations}
\label{ssec:oper-info}

The operation model provides an interface to access and manipulate all
operation properties described in Section~\ref{ssec:operation-properties}.
The interface does not have to mirror exactly the format of properties, when
doing so would result in redundancies.

The static properties of operation inputs and outputs are partitioned into a
separate model.  The operation interface allows to access the model of 
a given input or output by its index number.

\subsection{Behavior of Operations}

Static properties are not sufficient to model an operation.  A crucial bit
of information is the semantics of an operation.  The semantics of an
operation is captured by defining its behavior: the results produced by the
operation for a given set of input values.

Rest of this section has been moved to the TCE User Manual.

\subsection{Operation Operands}
\label{ssec:operand}

The Operation Set Abstraction Layer operation model provides interfaces to
access and manipulate all properties of operation inputs and outputs
described, respectively, in Sections~\ref{ssec:opinput-properties} and
\ref{ssec:opoutput-properties}.

\subsection{Operation Input and Output Values}
\label{ssec:io-values}

The operation behavior model communicates with its clients through the
input values it reads and the output values it computes as result.  Input
and output values are modeled by a type that can represent any number that
can be manipulated by operations of the target architecture template.

The meaning of the data stored in the input and output values is completely
arbitrary and depends solely on the operation semantics.
%
For convenience however, input and output values provide an interface to
treat the value represented as one of three commonly used base data types:
\begin{enumerate}
\item An unsigned integer.
\item An signed integer.
\item A single-precision, IEEE-754 floating-point number.
\item A double-precision, IEEE-754 floating-point number.
\end{enumerate}

Input and output values do not store just value data.  For each value, also
its bit width is stored.  In addition:
\begin{enumerate}
\item %
  Input values have a flag that tells whether data is actually specified.
  This flag is required to support operations that have optional inputs.
\item %
  Output values have a flag that tells whether the represented value is a
  valid result computed by the operation.
\end{enumerate}

\subsection{Operation Model Check}
\label{ssec:oper-check}

The operation model returned by a lookup may be defective in two ways:
\begin{enumerate}
\item %
  No operation with the given name is found in the repertoire databases.
  In this case, a \emph{null operation} is returned (see
  Section~\ref{ssec:repertoire-lookup}).
\item %
  The operation definition is found, but no behavior model exists for such
  definition (i.e. if operation can be simulated).
\end{enumerate}

The operation model provides an interface to test whether operation lookup
has failed and the behavior model has not been found.

\section{Operation State}
\label{sec:oper-state}

In one form or another, when it generates results that do not depend solely
on the input values, an operation contains state.  This state may be
completely hidden in an external model of the operation,%
\note{pending issue \ref{sec:external-vs-internal}}
%
or it may be implemented within the OSAL module.

If the state of the operation is implemented in the OSAL module and not by
an external module, then state data is grouped in a class specific for that
operation: the \emph{operation state class}.

Operation state requires accurate cooperation between the OSAL model of the
operation behavior and the client code using such model, because of its
unusual requirements:
\begin{enumerate}
\item %
  Several different operations may share the same operation state object.
\item %
  Operation state contents of information is specific for each group of
  operations that share the same operation state class.
\item %
  Operation state contents of information is fully visible only to the code
  that implements the behavior of the operations that contain such state.
\item %
  The objects that model different implementations of an operation have
  independent access to instances of operation state.  The code that
  implements the behavior of a given operation must work with different
  operation state objects, and the client of operation behavior must be
  able to keep and pass such objects to the operation.
\end{enumerate}

The operation state is a very specific piece of information local to one or
few operations, yet it does not belong to any of the operation objects that
use it, but to a container object.  Such container object usually represents
the hardware block that implements one or more operations.  In the rest of
this section ``function unit'', for clarity of exposition, will be used
instead of ``container'', but in general what described here applies to any
object capable of handling operation state objects and pass them to the
operation behavior interface.


\subsection{Operation State Interface Visible to Clients of Operations}

The interface of the operation state objects is completely hidden from
clients of operation behavior.
%
Nevertheless, since the operation state does not belong to the operation,
but to the client (for example, the function unit state), a minimal
interface is provided to obtain, identify and pass operation state objects.

\paragraph{Passing operation state objects.}
All operation state objects share the same base class.  Even this class is
hidden to the clients.  The clients see the operation context, which is
primarily a container of operation state objects.

The clients do not pass directly operation state objects to the operation
behavior interface, but the \emph{OperationContext} object.  The clients
are responsible for keeping \emph{OperationContext} and for passing it to
the operation methods that require it.
%
Each operation behavior method must lookup its own operation state object
among all the objects in \emph{OperationContext}.

\paragraph{Creation of operation state objects.}
Since operation state objects are specific to each group of operations,
clients must delegate creation to them.

\paragraph{Bookkeeping.}
The only responsibility of clients of operations with state is to manage
deallocation of \emph{OperationContext} and the \emph{OperationState}
objects it contains.  Before deleting itself, a client should delete these
objects.  This is a violation of the general principle that the creator of
an object must also destroy it, but it is well motivated by the peculiar
requirements of operation state objects, described above in this section.

\paragraph{Managing}
\emph{OperationState} objects may provide functionality for querying the
availability of the operation state and advancing the internal clock. 
This functionality is reserved for such operation families that have
synchronous functionality.

\subsection{Operation Context}

The operation context is that part of the state of a function unit which
affects the code that models operation behavior.  The operation context
consists of the operation state objects of all the operations implemented by
the function unit and special state data.

The operation context is represented by class \emph{OperationContext}, which
is primarily a container of operation state objects (see
Section~\ref{sec:oper-state}).

Optionally, \emph{OperationContext} can contain a reference to a memory
model.  All operations implemented by a function unit that access memory
must access the same address space (see ADF specifications~\cite{ADF-specs}
for details).

\paragraph{Operation state lookup.}
The operation context class offers an interface to facilitate operation
state lookup by code that implements operation behavior.  In addition,
\emph{OperationContext} allows to add new operation state objects.

Operation state objects are uniquely identified, within the
\emph{OperationContext} objects that contains them, by a name string, which
is defined in the same source file that contains the operation behavior
implementation (Section~\ref{ssec:operation-behavior}).

\paragraph{Special context.}
In addition to state data for operations, the operation context keeps data
that is globally available to all operations implemented by a function unit.
This context data are:
\begin{enumerate}
\item %
  The Memory Module accessed by the function unit (if any).
\item %
  Control state: the state of the processor control path: program counter,
  return address, system call registers.
\end{enumerate}

The control state can only be stored inside a Global Control Unit, other
function units cannot have control state.  The Memory Module accessed by the
Global Control Unit represents the memory where the program's instructions
are stored.

\paragraph{Accessing Context-wide State Information}

Operation context provides functionality for checking the overall availability
of operation context. Operation context is in unavailable state only if
it contains operation state instances and at least one of them is in
unavailable state. Additionally, it's possible to advance the clock of
each clocked state instance in the operation context using one function call.

\chapter{DATABASES}
\label{ch:database}

The operations of a TTA processor are defined in one or more operation
definition files.  The static properties are stored in data files, and the
behavior (simulation functions) are stored in source files.

The behavior definitions of several operations may be grouped in a single
source file.  Grouping is necessary to support operations that share the
same processor state in a convenient way.

Rest of this chapter has been moved to TCE user manual.


\section{Intensity of Use}

The operation set database is going to be accessed far more often than it is
modified.  Most applications that deal with the target processor model or
with the program model will require access to the database.  During a
simulation run, the target architecture simulator invokes the code that
emulates the behavior of operations millions of times, therefore the
efficiency of the code that performs the invocation is critical.

\section{Files and Configuration}

The operation repertoire data is organized in two types of files:
\begin{enumerate}
\item %
  Data files that contains operation properties.
\item %
  Dynamic modules that contain operation behavior.
\end{enumerate}

Each of the searched directories contains one or more data files.  To each
properties data file corresponds an optional dynamic module.

The dynamic modules are compiled from source files in behavior description
language (see Section~\ref{ssec:behaviour-commands}).

\subsection{Operation Properties Files}

Operation properties are stored in a data file in XML format with suffix
`.opp'.  The information stored in this type of file is accessed by
applications at run time, so any change to properties affects immediately
new applications that are run and that access such file.

The operation property file root element is denoted by the XML tag
\emph{osal}:
\begin{verbatim}
  <osal . . . > . . . </osal>
\end{verbatim}

\paragraph{Version information.}
Version information is stored in the form of attributes of the top-level
declaration element:
\begin{verbatim}
  <osal version="1.1" required-version="1.0">
      . . .
  </osal>
\end{verbatim}

The \emph{version} attribute is mandatory.  The \emph{required-version}
attribute is optional; if not specified, the required version takes the
value of the \emph{version} attribute.

\paragraph{Operation declaration.}

An operation declaration consists of an \emph{operation} element and has the
following format:
\begin{verbatim}
  <operation>
      <name> string </name>
      <inputs> number </inputs>
      <outputs> number </outputs>
      <reads-memory/>
      <writes-memory/>
      <trap/>
      <side-effects/>
      <affected-by> . . . </affected-by>
      <affects> . . . </affects>
      <in id="number" type="FloatWord"> . . . </in>
      . . .
      <out id="number" type="SIntWord"> . . . </out>
      . . .
      <trigger-semantics> . . . </trigger-semantics>
      . . .
  </operation>
\end{verbatim}

The elements \emph{name}, \emph{inputs}, \emph{outputs} specify,
respectively, the name, the number of inputs and the number of outputs of
the operation.

The elements \emph{writes-memory}, \emph{reads-memory}, \emph{trap}, 
\emph{side-effects}, when present, indicate, respectively, that the operation 
can read and/or write memory, can cause traps and has side effects.
%
It is an error to omit the \emph{reads-memory} or \emph{writes-memory} element 
when one of the inputs or outputs of the operation explicitly refer to 
a memory access.
%
It is an error to omit the \emph{side-effect} element when
\emph{affected-by} or \emph{affects} element is present and its list is not
empty.  Also, it is an error to omit it when at least one of the inputs is
optional, or when all the outputs are optional.

The elements \emph{affected-by} and \emph{affects} contain lists of elements
with the same syntax.  Neither element needs to be present when the list is
empty.  The lists consist of \emph{operation} elements with the following
syntax:
\begin{verbatim}
  <operation name="string"/>
\end{verbatim}
%
Each of these \emph{operation} elements represents a reference to an
operation and indicates that the operation currently being defined depends
on or affects the operation identified by the name attribute.
%
It is an error to declare are reference to the operation being declared
(self reference): such dependencies are implied by the \emph{side-effects}
element.

The elements \emph{in} and \emph{out} are the only elements of an operation
declaration that may be repeated.  Each element defines the properties of,
respectively, an input and an output of the operation.  There may be at most
as many \emph{in} and \emph{out} elements as the number of, respectively,
inputs and outputs of the operation.

\paragraph{Input declaration.}
An \emph{in} element has the following format:
\begin{verbatim}
  <in id="number" type="UIntWord">
      <mem-address/>
      <mem-data/>
      <can-swap> . . . </can-swap>
  </in>
\end{verbatim}

The attribute \emph{id} specifies the input of the operation whose
properties are defined by the \emph{in} element. \emph{Type} attribute can
be either \emph{SIntWord}, \emph{UIntWord}, \emph{FloatWord} or \emph{DoubleWord}.

The \emph{mem-address} and \emph{mem-data} elements, when present, indicates
that the input is used to compute, respectively, a memory address or a data
word that is going to be stored in memory.

The \emph{can-swap} element contains a list of references to inputs of the
operation for which permutation of value with the input being declared does
not alter the result of the operation.  Each reference is specified with an
\emph{in} element with the following syntax:
\begin{verbatim}
  <in id="number" type="DoubleWord"/>
\end{verbatim}
%
The \emph{id} attribute value must be a valid input identifier, that is, a
number in the range 1--\emph{n}, where \emph{n} is the number of inputs of
the operation.
%
It is an error to define a reference to the input being declared.

If empty, the \emph{in} element of an operation input can be omitted from
the operation declaration.

\paragraph{Output declaration.}
An \emph{out} element has the following format:
\begin{verbatim}
  <out id="number" type="UIntWord">
      <mem-data/>
  </out>
\end{verbatim}

\note{pending issue \ref{sec:optional-out}}

The \emph{mem-data} element, when present, indicates that the output
contains a data word whose value depends on data read from memory.

If empty, the \emph{out} element of an operation output can be omitted from
the operation declaration.

\paragraph{Trigger semantics.}

This block defines an DAG graph for operation or multiple DAG graphs if multiple
\emph{trigger-semantics} blocks are defined. DAG might be used to simulate 
behavior of operation. Language for writing \emph{trigger-semantics} block is 
described in TCE user manual.

\subsection{Operation Behavior Files}

The behavior of operations is defined in one or more source files by means
of a dedicated language (described in
Section~\ref{ssec:behaviour-commands}).
%
These files are compiled into dynamic modules with suffix `.opb'.  For each
operation property file there is a corresponding module with the same base
name.

The organisation of source files that contain operation behaviour
definitions is purely logic-oriented, and not forced upon the user due to
implementation reasons.  Actually, operations that share the same state
should be defined in the same source file (or should include a common state
definition from another file), but this doesn't hurt the logic.

There are few constraints in the contents of the source files. A source file
consists of a sequence of definition blocks introduced by one of the
statements described in Section~\ref{ssec:behaviour-commands}. An operation
state definition block must precede any definition blocks of operations that
uses such state class. The most common type of operation, is stateless and
deterministic operation, so most of a source file will usually consist of
\verb#OPERATION# definition blocks containing only a \verb#TRIGGER#
declaration.

Operation behavior modules are compiled out of operation property files and
source files in behavior description language by means of the OSAL Builder,
an external application described in Section~\ref{ssec:OSAL-builder}.



\chapter{OTHER PRODUCT REQUIREMENTS}

\section{Applicable Standards}

The common subset of the programming interface to dynamic linking loader
provided by Sun Solaris and Linux/GNU operating systems will be used.
%
For additional standards, see document~S-001 \cite{ProjectPlan}.

\section{Environment Requirements}

%% Remove this section (not needed) for functional specifications of
%% modules or applications of a larger project.

%  Requirements in terms of computer environment, administrator rights for
%  installation, level of expertise - only for complete products.

It must be possible for a common user to provide additional operations to
the common Operation Set. This means that a location of the shared
installation must have access and write access for every user.

Also, the base operation set should be protected from accidental
redefinitions by a user.

\section{Other Requirements}

For system requirements, performance requirements, and further environment
requirements, the reader is referred to document~S-001 \cite{ProjectPlan}.

\chapter{REJECTED OR ABANDONED IDEAS}

\begin{description}
\item[04.03.2004 --- Single-file Database] %
  Instead of splitting properties and behavior of operations in two files,
  all data could be defined in a single file.  A single file has the
  advantage of simplicity, but it has also the following disadvantages:
  \begin{itemize}
  \item %
    Less flexibility: whenever the data file is changed, the dynamic modules
    that implement the model of operation behavior must be recompiled.
  \item%
    Two fundamentally different formats (XML and behavior description
    language) are mixed in the same file.
  \end{itemize}
  By far the most important advantage of separate files that makes such
  organization preferable is that it is possible to run applications that
  use operation properties event if the behavior is not implemented.
  Another advantage is that any change in operation properties is
  automatically reflected by OSAL client applications.  No compilation step
  is required.
\item[29.03.2004 --- Fail on missing operation] %
  Rejected because it is convenient to allow lookup failure in cases when a
  program contains undefined operations, but the application does not access
  any property of such operations (for example, because the procedures they
  belong to have been excluded from processing).

  Rejected also the alternative of a switch to OSAL so that the client
  (application) can choose the preferred behavior.  The client just has to
  test that the looked up object is null, that's simple enough!
\item[19.05.2004 --- Aliases for operation operands] %
  Rejected because:
  \begin{enumerate}
  \item %
    The practical need for it is minimal; operation operands are unlikely to
    be changed in order.
  \item %
    It requires a new XML element declaration:
\begin{verbatim}
    <in id="0"> . . . </in>
    . . .
    <alias id="0"> aliasName </alias>
\end{verbatim}
  \item %
    It makes it possible to refer to the same entity in two different ways.
  \item %
    An almost identical effect on readability may be obtained, more
    efficiently, by taking references of input/output words in the behavior
    code.
  \end{enumerate}
\end{description}



\chapter{IDEAS FOR FURTHER DEVELOPMENT}

% Ideas that are not part of the specifications yet but that might be
% required in future are listed here. This is to "leave room" in design for
% later extensions and to have ideas written down somewhere.  This list
% should contain the date of addition, the idea described briefly and the
% inventor of the idea.

\begin{description}
\item[22.03.2004]%
  Support for global operation state, shared by all hardware implementations
  of a given operation.  Currently, the scope of operation state is the
  single client that implements the operation (typically, a function unit).
  There could be cases where any implementation of a given operation share a
  piece of the state.  This case seems unlikely to have practical
  usefulness, and adding it later could be a difficult task, nevertheless,
  the possibility should not be ruled out.  --A. Cilio

\item[30.03.2004]%
  Automatic detection of changes to the operation definitions at run time.
  A change to operation definitions may or may not affect a client
  application that was started before the modification took place.  If the
  operation model of that operation has been already loaded, the change will
  pass unobserved, otherwise it will affect the client.

  In practice this is a very theoretical problem, because it is unlikely
  that a user wants to continue using an application throughout a change to
  the operation set, but it may be a problem for installation-wide operation
  definitions, since other users may access the changed files.

  A possible solution for this problem is to record the time stamp of the
  files containing operation definitions (properties data files and
  behavior modules).  Whenever a new operation is looked up, the timestamps
  are compared, and if a change is detected, all operation models that have
  been previously loaded are reloaded.

\item[25.04.2006]%
  Documentation field in operation properties. A property definition
  includes an (optional?) \emph{documentation} element with a textual
  description of the operation.
\end{description}



\chapter{PENDING ISSUES}

% Pending issues concerning these specifications, a sort of TODO list.
% This chapter should be empty when the final product is ready.

\section{External vs. Internal Operation Behavior Specification}
\label{sec:external-vs-internal}

For example, a function that reads a stream (\emph{readstream}) could be
implemented internally as follows:
\begin{verbatim}
if (STATE.streamIn == NULL) {
    // open the C++ stream that emulates the buffer used by readstream
    istream x("name");
    STATE.streamIn = x;
}
int result;
STATE.streamIn >> result;
INT(2) = result;  // assuming INT(1) is used for a dummy trigger
RETURN_READY;
\end{verbatim}

Instead, the SystemC equivalent implementation of the \emph{readstream}
behavior would require to read the value at an output port and rise a
signal to an input port that controls buffer pointer advancing.  Notice that
this model is external in the sense that it is \emph{implemented} as a
separate SystemC module, but it is still part of the TTA processor core and
as such it is internal.

\section{Name Clashes between Operation State Classes}
\label{sec:state-name}

Operations refer to their operation state by name.

It is probably impossible or very awkward to ensure, at time an operation
behavior definition is compiled, that two or more operation definitions
have not the same name.

If name clashes occur accidentally in different dynamic modules, it is very
unlikely that they will cause any problem, because it is unlikely that two
unrelated user-defined operations will be implemented in the same function
unit.

It is possible to detect name clashes at run time, when an operation creates
a state object.  In this case, when a state object with the same name of the
object to create already exists, dynamic type checking (the base operation
state class object is downcast to the specific state class of the operation)
can detect if the existing object is not the required one.

What to do when such name clashes occur?
\begin{enumerate}
\item %
  Abort and complain that two different object state classes have the same
  name.
\item %
  Make the name of the second state object type unique by using a predefined
  scheme and then create the object.  Whenever the original name is used to
  lookup a state object of the second type, the initial result will
  fail the dynamic type check, and the second lookup with the modified name
  will return the correct object.
\end{enumerate}

The first scheme is simple but annoying, because it requires a user to know
the name of object state classes for completely unrelated (possibly
predefined) operations.  This violates one of the principles whereby the
user is not required to know anything in OSAL that he does not have to
modify.

The second scheme solves the problem of name clashes, but at the cost of
slower lookups.  The dynamic type checking is not an overhead, because it
must be performed in any case.  This scheme could be used as a
error-tolerant fall-back, combined with a warning.

\section{Memory Byte Order}
\label{sec:mem-byte-order}

Currently, there is no way to specify the byte order (or ``endianess'') of
the target memory.  The byte order of memory affects the architecture, so
this information should probably be stored in the ADF.

\section{Optional Operation Outputs}
\label{sec:optional-out}

Does the ``is optional'' property of operation outputs make sense?

In a TTA program, any operation result can be ignored simply by not
performing the result data transport.  This may make sense when a TTA
instruction scheduler performs a \emph{partial speculation} of an operation.

For example:
\begin{verbatim}
100  X -> FU.OP.t
101  b0: 103 -> jump
102  FU.r -> Y
103  . . .
\end{verbatim}
Operation `OP' is partially speculated; its result is only used (stored in
destination `Y') if a predicate condition is false.  When the predicate
condition is true, the program trace contains an operation whose result is
ignored.



% ------------------------------------------------------------------------

%% Remove this part if there are no references.  Usually there will be at
%% least a reference to the functional specifications of the TCE Project
%% (S-001).

%  References are generated with BibTeX from a bibtex file.
\bibliographystyle{alpha}
\cleardoublepage
%% Equivalent to a chapter in the table of contents
\addcontentsline{toc}{chapter}{BIBLIOGRAPHY}
\bibliography{Bibliography}


\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

% LocalWords:  skel inen
