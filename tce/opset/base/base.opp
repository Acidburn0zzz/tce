<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<osal version="0.1">

  <operation>
    <name>ADDSUB</name>
    <description>Add and sub the inputs and store results to 3 and 4, respectively.</description>
    <inputs>2</inputs>
    <outputs>2</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <out id="4" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(add, IO(1), IO(2), IO(3));
      EXEC_OPERATION(sub, IO(1), IO(2), IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL1ADD</name>
    <description>Array indexing for 16-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl, IO(1), 1, shifted);
      EXEC_OPERATION(add, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL2ADD</name>
    <description>Array indexing for 32-bit data types</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue shifted;
      EXEC_OPERATION(shl, IO(1), 2, shifted);
      EXEC_OPERATION(add, shifted, IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADD</name>
    <description>Integer addition.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(add, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUB</name>
    <description>Integer subtraction.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sub, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDW</name>
    <description>Loads 4 minimum addressable units from memory. Address must be aligned to 4.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STW</name>
    <description>Stores 4 minimum addressable units to memory. Address must be aligned to 4.</description>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(stw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQ</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(eq, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GT</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gt, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LT</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gt, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtu, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NE</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="SIntWord"/>
    <trigger-semantics> 
      SimValue t1;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gt, IO(1), IO(2), t1);
      EXEC_OPERATION(gt, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GE</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics> 
      SimValue t1;
      EXEC_OPERATION(gt, IO(2), IO(1), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gt, IO(1), IO(2), t1);
      EXEC_OPERATION(eq, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gtu, IO(2),IO(1), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(gtu, IO(1), IO(2), t1);
      EXEC_OPERATION(eq, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LE</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gt, IO(1),IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(gt, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(gtu, IO(1),IO(2), t1);
      EXEC_OPERATION(xor, t1, 1, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(eq, IO(1), IO(2), t1);
      EXEC_OPERATION(gtu, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHL</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shl, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHR</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(shr, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SHRU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>AND</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(and, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>IOR</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(ior, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>XOR</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(xor, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>JUMP</name>
    <description/>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-branch/>
    <in id="1" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(jump, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CALL</name>
    <description/>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <control-flow/>
    <is-call/>
    <in id="1" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(call, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MIN</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(min, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAX</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(max, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MINU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(minu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAXU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="UIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(maxu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDQ</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="SIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldq, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDH</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="SIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDD</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="32" id="2" type="UIntWord">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldd, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STQ</name>
    <description/>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="8" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(stq, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="16" id="2" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(sth, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STD</name>
    <description/>
    <inputs>2</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in element-count="1" element-width="32" id="2" type="UIntWord">
      <mem-data/>
    </in>
    <trigger-semantics>
      EXEC_OPERATION(std, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXQW</name>
    <description>sign extend from 8 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <out id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxqw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SXHW</name>
    <description>sign extend from 16 bits</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <out id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(sxhw, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEG</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <out id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(neg, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEGF</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <out id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(negf, IO(1), IO(2));
    </trigger-semantics>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(subf, IO(1), IO(1), tmp);
      EXEC_OPERATION(subf, tmp, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEGH</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <out id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(negf, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(negh, IO(1), IO(2));
    </trigger-semantics>
    <trigger-semantics>
      SimValue tmp;
      EXEC_OPERATION(subh, IO(1), IO(1), tmp);
      EXEC_OPERATION(subh, tmp, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAXF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="FloatWord"/>
  </operation>

  <operation>
    <name>MINF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="FloatWord"/>
  </operation>

  <operation>
    <name>MAXH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord"/>
    <out id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(maxf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MINH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord"/>
    <out id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(minf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MUL</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="SIntWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mul, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIV</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(div, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(divu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADDF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(addf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUBF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(subf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MULF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mulf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(divf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(eqf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(nef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gtf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gtf, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(gef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gtf, IO(1), IO(2), t1);
      EXEC_OPERATION(eqf, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(ltf, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gtf, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEF</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(lef, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQUF</name>
    <description>


</description>    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>EXEC_OPERATION(eqf, IO(1), IO(2), IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>NEUF</name>
    <description>


</description>    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1;
EXEC_OPERATION(eqf, IO(1), IO(2), temp1);
EXEC_OPERATION(xor, temp1, 1, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>GTUF</name>
    <description>

</description>    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>EXEC_OPERATION(gtf, IO(1), IO(2), IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>GEUF</name>
    <description>


</description>    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(eqf, IO(1), IO(2), temp2);
EXEC_OPERATION(ior, temp1, temp2, IO(3));


</trigger-semantics>
  </operation>

  <operation>
    <name>LTUF</name>
    <description>


</description>    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2, temp3;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(eqf, IO(1), IO(2), temp2);
EXEC_OPERATION(ior, temp1, temp2, temp3);
EXEC_OPERATION(xor, temp3, 1, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>LEUF</name>
    <description>


</description>    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1;
EXEC_OPERATION(gtf, IO(1), IO(2), temp1);
EXEC_OPERATION(xor,temp1,1, IO(3));

</trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqf, IO(1), IO(2), t1);
      EXEC_OPERATION(gtf, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ADDH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(addf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>SUBH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord"/>
    <out id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(subf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(subh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MULH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(mulf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(mulh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>DIVH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord"/>
    <out id="3" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(divf, t1, t2, t3);
      EXEC_OPERATION(cfh, t3, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(divh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MACH</name>
    <description/>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in id="3" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out id="4" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulh, IO(2), IO(3), t1);
      EXEC_OPERATION(addh, IO(1), t1, IO(4));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2, t3, t4, t5;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(chf, IO(3), t3);
      EXEC_OPERATION(mulf, t2, t3, t4);
      EXEC_OPERATION(addf, t1, t4, t5);
      EXEC_OPERATION(cfh, t5, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MSUH</name>
    <description/>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in id="3" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out id="4" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulh, IO(2), IO(3), t1);
      EXEC_OPERATION(subh, IO(1), t1, IO(4));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1, t2, t3, t4, t5;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(chf, IO(3), t3);
      EXEC_OPERATION(mulf, t2, t3, t4);
      EXEC_OPERATION(subf, t1, t4, t5);
      EXEC_OPERATION(cfh, t5, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MACF</name>
    <description/>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in id="3" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out id="4" type="FloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulf, IO(2), IO(3), t1);
      EXEC_OPERATION(addf, IO(1), t1, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MSUF</name>
    <description/>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in id="3" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out id="4" type="FloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mulf, IO(2), IO(3), t1);
      EXEC_OPERATION(subf, IO(1), t1, IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MAC</name>
    <description/>
    <inputs>3</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord">
      <can-swap>
        <in id="3"/>
      </can-swap>
    </in>
    <in id="3" type="SIntWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <out id="4" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(mul, IO(2), IO(3), t1);
      EXEC_OPERATION(add, t1, IO(1), IO(4));
    </trigger-semantics>
  </operation>

  <operation>
    <name>EQH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(eqf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(eqh, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NEH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="HalfFloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(nef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(neh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gth, IO(1), IO(2), t1);
      EXEC_OPERATION(gth, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GTH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(gtf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gth, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>GEH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(gef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(geh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(gth, IO(1), IO(2), t1);
      EXEC_OPERATION(eqh, IO(1), IO(2), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LTH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(ltf, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(lth, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(gth, IO(2), IO(1), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LEH</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <in id="2" type="HalfFloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1, t2, t3;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(chf, IO(2), t2);
      EXEC_OPERATION(lef, t1, t2, IO(3));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(leh, IO(1), IO(2), IO(3));
    </trigger-semantics>
    <trigger-semantics>
      SimValue t1,t2;
      EXEC_OPERATION(eqh, IO(1), IO(2), t1);
      EXEC_OPERATION(gth, IO(2), IO(1), t2);
      EXEC_OPERATION(ior, t1, t2, IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFI</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <out id="2" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfi, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFIU</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <out id="2" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfiu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIF</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <out id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cif, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIFU</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <out id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cifu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFD</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <out id="2" type="DoubleWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfd, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CDF</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="DoubleWord"/>
    <out id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cdf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHI</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <out id="2" type="SIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(cfi, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(chi, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHIU</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <out id="2" type="UIntWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(cfiu, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(chiu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIH</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <out id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(cif, IO(1), t1);
      EXEC_OPERATION(cfh, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(cih, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CIHU</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <out id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1;
      EXEC_OPERATION(cifu, IO(1), t1);
      EXEC_OPERATION(cfh, t1, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(cihu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CHF</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <out id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(chf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>CFH</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <out id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(cfh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ROTL</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>ROTR</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(rotr, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ABS</name>
    <description>

</description>    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <out id="2" type="SIntWord"/>
  </operation>

  <operation>
    <name>ABSF</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <out id="2" type="FloatWord"/>
    <trigger-semantics>
      EXEC_OPERATION(absf, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>ABSH</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <out id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(absf, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
      EXEC_OPERATION(absh, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDQU</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="8" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldqu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>LDHU</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <reads-memory/>
    <in element-count="1" element-width="32" id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out element-count="1" element-width="16" id="2" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>
      EXEC_OPERATION(ldhu, IO(1), IO(2));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MOD</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="SIntWord"/>
    <in id="2" type="SIntWord"/>
    <out id="3" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(mod, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>MODU</name>
    <description/>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(modu, IO(1), IO(2), IO(3));
    </trigger-semantics>
  </operation>

  <operation>
    <name>STDOUT</name>
    <description>Writes a single 8bit char to "standard output" which is platform dependent. In simulator outputs the character to simulator console. Used for debugging. printf() uses this by default.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <in id="1" type="SIntWord"/>
    <trigger-semantics>
      EXEC_OPERATION(stdout, IO(1));
    </trigger-semantics>
  </operation>

  <operation>
    <name>NOT</name>
    <description/>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <out id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>ANDN</name>
    <description>Does a bitwise negation (NOT) on the 2nd input followed by AND of the 1st input and the negated 2nd output. Special instruction in TI C64X.












</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>	SimValue negResult, mulin;
	EXEC_OPERATION(not, IO(2), negResult);
	EXEC_OPERATION(and, negResult, IO(1), IO(3));










</trigger-semantics>
  </operation>

  <operation>
    <name>LMBD</name>
    <description>Leftmost Bit Detection (from TI C64X). Counts the number of 0's or 1's in the bit representation of operand 1 before the first 1 or 0. 2nd operand is used to tell whether to search for a 0 or 1.</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="UIntWord"/>
    <in id="2" type="UIntWord"/>
    <out id="3" type="UIntWord"/>
  </operation>

  <operation>
    <name>STREAM_IN</name>
    <description>The "default streaming" operation for input.

Reads one sample of input from the data stream. The width of the sample is defined by the function unit output port width. 

When triggered with 0 writes a new sample to the output, if there are one ore more samples to be read in the buffer, otherwise causes a global lock.




</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <affects>
      <operation name="STREAM_IN_STATUS"/>
    </affects>
    <in id="1" type="UIntWord"/>
    <out id="2" type="RawData"/>
  </operation>

  <operation>
    <name>STREAM_OUT</name>
    <description>The "default streaming" operation for output.

Writes one sample to the output data stream. The width of the sample is
defined by the function unit input port width.

In case no room is available in the output buffer, causes a global lock.

</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <side-effects/>
    <affects>
      <operation name="STREAM_OUT_STATUS"/>
    </affects>
    <in id="1" type="RawData"/>
  </operation>

  <operation>
    <name>STREAM_IN_STATUS</name>
    <description>The "default streaming" operation for querying input buffer status.

Trigger with 0.

Return an integer with the following meanings:

0 = buffer empty
1 = not empty nor full (implies a buffer size &gt; 1 sample and that there is at least one sample in the buffer)
2 = buffer full

This operation allows handling stream buffer underflow without a global lock, thus allows doing something useful (run another thread, for example) while the buffer is empty.

</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <affected-by>
      <operation name="STREAM_IN"/>
    </affected-by>
    <in id="1" type="UIntWord"/>
    <out id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>STREAM_OUT_STATUS</name>
    <description>The "default streaming" operation for querying output buffer status.

Trigger with 0.

Return an integer with the following meanings:

0 = buffer empty
1 = not empty nor full (implies a buffer size &gt; 1 sample and that there is at least one sample in the buffer)
2 = buffer full

This operation allows handling stream buffer overflow without a global lock, thus allows doing something useful (run another thread, for example) while the
buffer is full.

</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <affected-by>
      <operation name="STREAM_OUT"/>
    </affected-by>
    <in id="1" type="RawData"/>
    <out id="2" type="RawData"/>
  </operation>

  <operation>
    <name>RTIMER</name>
    <description>Real time timer. 

Counts time (given in microseconds) down from the given value until reaches zero.

When triggered with 0, returns the current timer value, when triggered with a value greater than 0, sets the timer value.

The simulation behavior definition assumes 100MHz clock frequency, which can be modified using the environment variable TCE_RTIMER_CLOCK=MHZ.

</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in id="1" type="UIntWord"/>
    <out id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>RTC</name>
    <description>Real time clock.

Counts time (microseconds) up from zero.

When triggered with 0, resets the timer value to zero, when triggered with a value greater than 0, returns the timer value.

The simulation behavior definition assumes 100MHz clock frequency, which can be modified using the environment variable TCE_RTIMER_CLOCK=MHZ.

</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in id="1" type="UIntWord"/>
    <out id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>ORDF</name>
    <description>Returns 1 if floating point input operands are ordered. i.e. neither of the input operands is NaN.

</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord">
      <can-swap>
        <in id="2"/>
      </can-swap>
    </in>
    <in id="2" type="FloatWord">
      <can-swap>
        <in id="1"/>
      </can-swap>
    </in>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2;
EXEC_OPERATION(eqf, IO(1), IO(1), temp1);
EXEC_OPERATION(eqf, IO(2), IO(2), temp2);
EXEC_OPERATION(and, temp1, temp2, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>UORDF</name>
    <description>Returns 1 if the two floating point operands are unordered. i.e. isNaN(io1) || isNan(io2).

</description>
    <inputs>2</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <in id="2" type="FloatWord"/>
    <out id="3" type="UIntWord"/>
    <trigger-semantics>SimValue temp1, temp2, temp3;
EXEC_OPERATION(eqf, IO(1), IO(1), temp1);
EXEC_OPERATION(eqf, IO(2), IO(2), temp2);
EXEC_OPERATION(and, temp1, temp2, temp3);
EXEC_OPERATION(xor, temp3, 1, IO(3));



</trigger-semantics>
  </operation>

  <operation>
    <name>SQRTF</name>
    <description>Performs a square root of a single precision floating point. For example, the MIPS R4000 FPU implements it.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="FloatWord"/>
    <out id="2" type="FloatWord"/>
  </operation>

  <operation>
    <name>INVSQRTH</name>
    <description>Performs a inverse square root of a half-precision floating point.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <out id="2" type="HalfFloatWord"/>
  </operation>

  <operation>
    <name>SQUAREH</name>
    <description>Computes the square of a half-precision floating point.
</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <in id="1" type="HalfFloatWord"/>
    <out id="2" type="HalfFloatWord"/>
    <trigger-semantics>
      SimValue t1, t2;
      EXEC_OPERATION(chf, IO(1), t1);
      EXEC_OPERATION(mulf, t1, t1, t2);
      EXEC_OPERATION(cfh, t2, IO(2));
    </trigger-semantics>
    <trigger-semantics>
EXEC_OPERATION(mulh, IO(1), IO(1), IO(2));
</trigger-semantics>
  </operation>

  <operation>
    <name>LEDS</name>
    <description>Control leds by writing a bit pattern. Bit 1 switches a led on and 0 switches off.</description>
    <inputs>1</inputs>
    <outputs>0</outputs>
    <in id="1" type="UIntWord"/>
  </operation>

  <operation>
    <name>LDW4</name>
    <description>Loads vector of 4 words from memory.</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STW4</name>
    <description>Stores 4 words to memory consecutively.</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <in id="4" type="RawData">
      <mem-data/>
    </in>
    <in id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(5));



</trigger-semantics>
  </operation>

  <operation>
    <name>LDW2</name>
    <description>Loads two words from memory.</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>STW2</name>
    <description>Stores two words to memory.</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));




</trigger-semantics>
  </operation>

  <operation>
    <name>STW8</name>
    <description>Writes 8 words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <in id="4" type="RawData">
      <mem-data/>
    </in>
    <in id="5" type="RawData">
      <mem-data/>
    </in>
    <in id="6" type="RawData">
      <mem-data/>
    </in>
    <in id="7" type="RawData">
      <mem-data/>
    </in>
    <in id="8" type="RawData">
      <mem-data/>
    </in>
    <in id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(stw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(5));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(6));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(7));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(8));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(stw, tmp, IO(9));




</trigger-semantics>
  </operation>

  <operation>
    <name>LDW8</name>
    <description>Loads 8 words from memory.</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <out id="6" type="RawData">
      <mem-data/>
    </out>
    <out id="7" type="RawData">
      <mem-data/>
    </out>
    <out id="8" type="RawData">
      <mem-data/>
    </out>
    <out id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldw, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(3));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(4));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(5));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(6));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(7));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(8));
EXEC_OPERATION(add, tmp, 4, tmp);
EXEC_OPERATION(ldw, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>BCAST2</name>
    <description>Copies data to two outputs</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <in id="1" type="RawData"/>
    <out id="2" type="RawData"/>
    <out id="3" type="RawData"/>
  </operation>

  <operation>
    <name>BCAST4</name>
    <description>Copies data to two outputs</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <in id="1" type="RawData"/>
    <out id="2" type="RawData"/>
    <out id="3" type="RawData"/>
    <out id="4" type="RawData"/>
    <out id="5" type="RawData"/>
  </operation>

  <operation>
    <name>BCAST8</name>
    <description>Copies data to two outputs</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <in id="1" type="RawData"/>
    <out id="2" type="RawData"/>
    <out id="3" type="RawData"/>
    <out id="4" type="RawData"/>
    <out id="5" type="RawData"/>
    <out id="6" type="RawData"/>
    <out id="7" type="RawData"/>
    <out id="8" type="RawData"/>
    <out id="9" type="RawData"/>
  </operation>

  <operation>
    <name>LDH2</name>
    <description>Reads two half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU2</name>
    <description>Reads two half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDH4</name>
    <description>Reads four half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU4</name>
    <description>Reads four half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDH8</name>
    <description>Reads eight half words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <out id="6" type="RawData">
      <mem-data/>
    </out>
    <out id="7" type="RawData">
      <mem-data/>
    </out>
    <out id="8" type="RawData">
      <mem-data/>
    </out>
    <out id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldh, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldh, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDHU8</name>
    <description>Reads eight half words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <out id="6" type="RawData">
      <mem-data/>
    </out>
    <out id="7" type="RawData">
      <mem-data/>
    </out>
    <out id="8" type="RawData">
      <mem-data/>
    </out>
    <out id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldhu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(ldhu, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ2</name>
    <description>Reads two quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU2</name>
    <description>Reads two quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>2</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));

</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ4</name>
    <description>Reads four quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU4</name>
    <description>Reads four quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>4</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQ8</name>
    <description>Reads eight quarter words from memory with sign extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <out id="6" type="RawData">
      <mem-data/>
    </out>
    <out id="7" type="RawData">
      <mem-data/>
    </out>
    <out id="8" type="RawData">
      <mem-data/>
    </out>
    <out id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldq, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>LDQU8</name>
    <description>Reads eight quarter words from memory with zero extension</description>
    <inputs>1</inputs>
    <outputs>8</outputs>
    <reads-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <out id="2" type="RawData">
      <mem-data/>
    </out>
    <out id="3" type="RawData">
      <mem-data/>
    </out>
    <out id="4" type="RawData">
      <mem-data/>
    </out>
    <out id="5" type="RawData">
      <mem-data/>
    </out>
    <out id="6" type="RawData">
      <mem-data/>
    </out>
    <out id="7" type="RawData">
      <mem-data/>
    </out>
    <out id="8" type="RawData">
      <mem-data/>
    </out>
    <out id="9" type="RawData">
      <mem-data/>
    </out>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(ldqu, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(ldqu, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH2</name>
    <description>Stores two half words to memory</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH4</name>
    <description>Stores four half words to memory</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <in id="4" type="RawData">
      <mem-data/>
    </in>
    <in id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STH8</name>
    <description>Stores eight half words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <in id="4" type="RawData">
      <mem-data/>
    </in>
    <in id="5" type="RawData">
      <mem-data/>
    </in>
    <in id="6" type="RawData">
      <mem-data/>
    </in>
    <in id="7" type="RawData">
      <mem-data/>
    </in>
    <in id="8" type="RawData">
      <mem-data/>
    </in>
    <in id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(sth, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 2, tmp);
EXEC_OPERATION(sth, tmp, IO(3));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(4));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(5));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(6));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(7));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(8));
EXEC_OPERATION(add, tmp, 2, tmp);
EXEC_OPERATION(sth, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ2</name>
    <description>Stores two quarter words to memory</description>
    <inputs>3</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ4</name>
    <description>Stores four quarter words to memory</description>
    <inputs>5</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <in id="4" type="RawData">
      <mem-data/>
    </in>
    <in id="5" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(5));
</trigger-semantics>
  </operation>

  <operation>
    <name>STQ8</name>
    <description>Stores eight quarter words to memory</description>
    <inputs>9</inputs>
    <outputs>0</outputs>
    <writes-memory/>
    <in id="1" type="UIntWord">
      <mem-address/>
    </in>
    <in id="2" type="RawData">
      <mem-data/>
    </in>
    <in id="3" type="RawData">
      <mem-data/>
    </in>
    <in id="4" type="RawData">
      <mem-data/>
    </in>
    <in id="5" type="RawData">
      <mem-data/>
    </in>
    <in id="6" type="RawData">
      <mem-data/>
    </in>
    <in id="7" type="RawData">
      <mem-data/>
    </in>
    <in id="8" type="RawData">
      <mem-data/>
    </in>
    <in id="9" type="RawData">
      <mem-data/>
    </in>
    <trigger-semantics>SimValue tmp;
EXEC_OPERATION(stq, IO(1), IO(2));
EXEC_OPERATION(add, IO(1), 1, tmp);
EXEC_OPERATION(stq, tmp, IO(3));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(4));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(5));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(6));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(7));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(8));
EXEC_OPERATION(add, tmp, 1, tmp);
EXEC_OPERATION(stq, tmp, IO(9));
</trigger-semantics>
  </operation>

  <operation>
    <name>ECC</name>
    <description>Execution cycle counter. Free running counter that counts execution cycles i.e. cycles when reset and global lock are not active. Handy for profiling hardware execution.
ISS behavior will return the current cycle count.
Input operand is discarded.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in id="1" type="UIntWord"/>
    <out id="2" type="UIntWord"/>
  </operation>

  <operation>
    <name>LCC</name>
    <description>Lock cycle counter. Free running counter that count global lock cycles. On hardware, reset most probably zeroes the counter. ISS behavior will always return zero. Handy for profiling hardware execution.
Input operand is discarded.</description>
    <inputs>1</inputs>
    <outputs>1</outputs>
    <side-effects/>
    <in id="1" type="UIntWord"/>
    <out id="2" type="UIntWord"/>
  </operation>

</osal>
