/**
 * @file CycleOptimizer.cc
 *
 * Implementation of the CycleOptimizer class.
 *
 * @author Jari Mäntyneva 2007 (jari.mantyneva@tut.fi)
 * @note rating: red
 */

#include <string>
#include <map>
#include "CycleOptimizer.hh"
#include "MachineResourceModifier.hh"
#include "DesignSpaceExplorer.hh"
#include "CostEstimates.hh"
#include "SimulatorConstants.hh"

using std::map;
using std::vector;
using std::pair;

/**
 * The constructor.
 *
 * @param dsdb DSDB where startID is searched and results are stored.
 * @param startConfID ID of the configuration where the CycleOptimizer should
 * begin.
 * @param superioty Percentage value of how much faster schedules are wanted
 * until the optimization is stopped. Value range: greater than zero.
 * @exception OutOfRange Throws if the superioty is smaller or equal to zero.
 */
CycleOptimizer::CycleOptimizer(
    DSDBManager& dsdb, RowID startConfID, int superioty)
    throw (OutOfRange):
    dsdb_(dsdb), startConfID_(startConfID), superioty_(superioty) {
    
    if (superioty <= 0) {
        std::string message = "Percentage value must be greater than zero.";
        throw OutOfRange(__FILE__, __LINE__, __func__, message);
    }
}

/**
 * The destructor.
 */
CycleOptimizer::~CycleOptimizer() {
}

/**
 * Optimizes the architecture.
 *
 * @return Configurations (including only adf) generated by CycleOptimizer.
 *         Best result is at the top of the list.
 * @exception KeyNotFound Throws if there is no architecture with startID in
 * dsdb.
 * @exception Unexpected error occured.
 */
std::vector<RowID>
CycleOptimizer::optimize() 
    throw (KeyNotFound, Exception) {
    
    map<ClockCycleCount, RowID> resultMap;

    ClockCycleCount prevMinCycles = 0;
    ClockCycleCount currentMinCycles = 0;
    TTAMachine::Machine* adf = NULL;
    DSDBManager::MachineConfiguration configuration;

    // get the architecture from the database
    try {
        configuration = dsdb_.configuration(startConfID_);
        adf = dsdb_.architecture(configuration.architectureID);
    } catch (const KeyNotFound& e) {
        throw e;
    }

    DesignSpaceExplorer explorer;
    explorer.setDSDB(dsdb_);
    CostEstimates estimates;
    if (!explorer.evaluate(configuration, estimates, false)) {
        throw Exception(
            __FILE__, __LINE__, __func__,
            "Couldn't evaluate the given configuration.");
    }
    for (int i = 0; i < estimates.cycleCounts(); i++) {
        if (i == 0) {
            currentMinCycles = estimates.cycleCount(i);
            continue;
        }
        if (estimates.cycleCount(i) < currentMinCycles) {
            currentMinCycles = estimates.cycleCount(i);
        }
    }
    MachineResourceModifier modifier;
    do {
        prevMinCycles = currentMinCycles;
        try {
            // These parameters passed to the modifier can be changed.
            // They tell how many units of same type are added each time.
            modifier.addBusesByAmount(4, *adf);
            modifier.increaseAllRFsThatDiffersByAmount(1, *adf);
            modifier.increaseAllFUsThatDiffersByAmount(1, *adf);
            // @todo immediate unit addition

            DSDBManager::MachineConfiguration newConfiguration;
            newConfiguration.architectureID = dsdb_.addArchitecture(*adf);
            newConfiguration.hasImplementation = false;
            RowID confID = dsdb_.addConfiguration(newConfiguration);
            CostEstimates newEstimates;
            if (explorer.evaluate(newConfiguration, newEstimates, false)) {
                for (int i = 0; i < newEstimates.cycleCounts(); i++) {
                    // resets the currentMinCycles 
                    if (i == 0) {
                        currentMinCycles = newEstimates.cycleCount(i);
                        continue;
                    }
                    if (newEstimates.cycleCount(i) < currentMinCycles) {
                        currentMinCycles = newEstimates.cycleCount(i);
                    }
                }
                resultIDs_.push_back(confID);
                resultMap[currentMinCycles] = confID;
            } else {
                // evaluating failed
                break;
            }
        } catch (const Exception& e) {
            throw e;
        }
    } while ((currentMinCycles < prevMinCycles) &&
             (((superioty_ / 100) * prevMinCycles) <
              (prevMinCycles - currentMinCycles)));

    vector<RowID> resultVector;
    map<ClockCycleCount, RowID>::const_iterator mapIter = resultMap.begin();
    for (; mapIter != resultMap.end(); mapIter++) {
        resultVector.push_back((*mapIter).second);
    }
    return resultVector;
}

/**
 * Reduces the number of register files in the machine as much as possible
 * to still achieve the application run time requirements.
 *
 * This function won't handle implementations.
 *
 * @param confToMinimize ID of the machine configuration which register files
 *                       are reduced.
 * @param maxCycles Max cycle count that the configuration may have.
 * @return ID of the new congiguration where register files are reduced.
 * @throw KeyNotFound If given machine configuration does not exist in dsdb.
 */
RowID
CycleOptimizer::minimizeRegisterFiles(
    RowID confToMinimize, ClockCycleCount maxCycles)
    throw (KeyNotFound) {
    
    RowID latestConfID = 0;

    MachineResourceModifier modifier;
    DesignSpaceExplorer explorer;
    explorer.setDSDB(dsdb_);

    DSDBManager::MachineConfiguration configuration =
        dsdb_.configuration(confToMinimize);
    const TTAMachine::Machine* origMach =
        dsdb_.architecture(configuration.architectureID);

    MachineResourceModifier::RegisterMap origRegisterMap;
    modifier.analyzeRegisters(*origMach, origRegisterMap);

    ClockCycleCount prevMaxCycles = 0;
    ClockCycleCount currentMaxCycles = 0;
    
    CostEstimates estimates;
    if (!explorer.evaluate(configuration, estimates, false)) {
        // can't evaluate the given configuration
        delete origMach;
        origMach = NULL;
        return 0;
    }

    // find out the biggest cycle count of applications before minimizing
    for (int i = 0; i < estimates.cycleCounts(); i++) {
        if (i == 0) {
            currentMaxCycles = estimates.cycleCount(i);
            continue;
        }
        if (estimates.cycleCount(i) > currentMaxCycles) {
                currentMaxCycles = estimates.cycleCount(i);
        }
    }
    
    if (currentMaxCycles > maxCycles) {
        // given configuration exceeds the given maximum of clock cycles
        delete origMach;
        origMach = NULL;
        return 0;
    }

    MachineResourceModifier::RegisterMap::const_iterator registerMapIter =
        origRegisterMap.begin();

    ObjectState* currentState = origMach->saveState();

    // go through all different register file types
    for (; registerMapIter != origRegisterMap.end(); registerMapIter++) {
        TTAMachine::Machine mach;
        mach.loadState(currentState);
        TTAMachine::Machine::RegisterFileNavigator rfNav =
            mach.registerFileNavigator();

        int i = 0;
        rfNav = mach.registerFileNavigator();
        // go through every register file in the machine to find matching RF
        while (i < rfNav.count()) {
             if (((*registerMapIter).second)->isArchitectureEqual(
                    *rfNav.item(i))) {
                mach.removeRegisterFile(*rfNav.item(i));
                std::list<std::string> socketList;
                modifier.removeNotConnectedSockets(mach, socketList);
                DSDBManager::MachineConfiguration newConfiguration;
                newConfiguration.architectureID = dsdb_.addArchitecture(mach);
                newConfiguration.hasImplementation = false;
                RowID confID = dsdb_.addConfiguration(newConfiguration);
                CostEstimates newEstimates;
                
                // if the evaluation fails the removed register is needed
                // and the old machine state is loaded
                if (!explorer.evaluate(
                        newConfiguration, newEstimates, false)) {
                    
                    // continue with old machine state and
                    // try with next register file type
                    break;
                }
                
                for (int i = 0; i < newEstimates.cycleCounts(); i++) {
                    // resets the currentMaxCycles
                    if (i == 0) {
                        currentMaxCycles = newEstimates.cycleCount(i);
                        continue;
                    }
                    if (newEstimates.cycleCount(i) > currentMaxCycles) {
                        currentMaxCycles = newEstimates.cycleCount(i);
                    }
               }
                if (currentMaxCycles > maxCycles && prevMaxCycles != 0) {
                    // continue with old machine state and
                    // try with next register file type
                    break;
                }
                latestConfID = confID;

                // save the new machine state
                delete currentState;
                currentState = mach.saveState();
                    
                // else continue removing same register types
                // no need to advance the rf navigator, 
                // because of the removal
                continue;
             }
            // if the registers did not match, try next one in the machine
            i++;
        }
    }
    

    delete origMach;
    origMach = NULL;
    return latestConfID;
}

/**
 * Reduces the number of function units in the machine as much as possible
 * to still achieve the application run time requirements.
 *
 * This function won't handle implementations.
 *
 * @param confToMinimize ID of the machine configuration which function units
 *                       are reduced.
 * @param maxCycles Max cycle count that the configuration may have.
 * @return ID of the new congiguration where function units are reduced.
 * @throw KeyNotFound If given machine configuration does not exist in dsdb.
 */
RowID
CycleOptimizer::minimizeFunctionUnits(
    RowID confToMinimize, ClockCycleCount maxCycles) 
    throw (KeyNotFound) {
    
    RowID latestConfID = 0;

    MachineResourceModifier modifier;
    DesignSpaceExplorer explorer;
    explorer.setDSDB(dsdb_);

    DSDBManager::MachineConfiguration configuration =
        dsdb_.configuration(confToMinimize);
    const TTAMachine::Machine* origMach =
        dsdb_.architecture(configuration.architectureID);

    MachineResourceModifier::FunctionUnitMap origFUMap;
    modifier.analyzeFunctionUnits(*origMach, origFUMap);

    ClockCycleCount prevMaxCycles = 0;
    ClockCycleCount currentMaxCycles = 0;
    
    CostEstimates estimates;
    if (!explorer.evaluate(configuration, estimates, false)) {
        // can't evaluate the given configuration
        delete origMach;
        origMach = NULL;
        return 0;
    }

    // find out the biggest cycle count of applications before minimizing
    for (int i = 0; i < estimates.cycleCounts(); i++) {
        if (i == 0) {
            currentMaxCycles = estimates.cycleCount(i);
            continue;
        }
        if (estimates.cycleCount(i) > currentMaxCycles) {
                currentMaxCycles = estimates.cycleCount(i);
        }
    }

    if (currentMaxCycles > maxCycles) {
        // given configuration exceeds the given maximum of clock cycles
        delete origMach;
        origMach = NULL;
        return 0;
    }

    MachineResourceModifier::FunctionUnitMap::const_iterator fuMapIter =
        origFUMap.begin();
    
    ObjectState* currentState = origMach->saveState();

    // go through all different function unit types
    for (; fuMapIter != origFUMap.end(); fuMapIter++) {
        TTAMachine::Machine mach;
        mach.loadState(currentState);
        TTAMachine::Machine::FunctionUnitNavigator fuNav =
            mach.functionUnitNavigator();
        int i = 0;
        // go through every function unit in the machine to find matching FU
        while (i < fuNav.count()) {
             if (((*fuMapIter).second)->isArchitectureEqual(
                     fuNav.item(i), true)) {
                mach.removeFunctionUnit(*fuNav.item(i));
                std::list<std::string> socketList;
                modifier.removeNotConnectedSockets(mach, socketList);
                DSDBManager::MachineConfiguration newConfiguration;
                newConfiguration.architectureID = dsdb_.addArchitecture(mach);
                newConfiguration.hasImplementation = false;
                RowID confID = dsdb_.addConfiguration(newConfiguration);
                CostEstimates newEstimates;
                
                // if the evaluation fails the removed FU is needed
                // and the old machine state is loaded
                if (!explorer.evaluate(
                        newConfiguration, newEstimates, false)) {
                    
                    // continue with old machine state and
                    // try with next FU type
                    break;
                }
                
                
                for (int i = 0; i < newEstimates.cycleCounts(); i++) {
                    // resets the currentMaxCycles
                    if (i == 0) {
                        currentMaxCycles = newEstimates.cycleCount(i);
                        continue;
                    }
                    if (newEstimates.cycleCount(i) > currentMaxCycles) {
                        currentMaxCycles = newEstimates.cycleCount(i);
                    }
                }
                if (currentMaxCycles > maxCycles && prevMaxCycles != 0) {
                    // continue with old machine state and
                    // try with next FU type
                    break;
                }
                latestConfID = confID;

                // save the new machine state
                delete currentState;
                currentState = mach.saveState();

                // continue removing same FU type
                // no need to advance the FU navigator, 
                // because of the removal
                continue;
             }
            // if the units did not match, try next one in the machine
            i++;
        }
    }
    delete origMach;
    origMach = NULL;
    return latestConfID;
}

/**
 * Reduces the number of buses in the machine as much as possible to still
 * achieve the application run time requirements.
 *
 * This function can handle implementations. Uses binary search to minimize
 * the buses.
 *
 * @param confToMinimize ID of the machine configuration which buses
 * are reduced.
 * @param maxCycles Max cycle count that the configuration may have.
 * @return ID of the new congiguration where buses are reduced.
 * @throw KeyNotFound If given machine configuration does not exist in dsdb.
 */
RowID
CycleOptimizer::minimizeBuses(
    RowID confToMinimize, ClockCycleCount maxCycles)
    throw (KeyNotFound) {
    
    DSDBManager::MachineConfiguration configuration = 
        dsdb_.configuration(confToMinimize);

    TTAMachine::Machine* mach = 
        dsdb_.architecture(configuration.architectureID);

    TTAMachine::Machine::BusNavigator busNav = mach->busNavigator();

    int origBusCount = busNav.count();
    // variables for binary search    
    int busHigh = busNav.count();
    int busLow = 1;
    int busMid = (busLow + busHigh) /2;

    DesignSpaceExplorer explorer;
    explorer.setDSDB(dsdb_);
    CostEstimates estimates;

    if (!explorer.evaluate(configuration, estimates, false)) {
        return confToMinimize;
    }

    ClockCycleCount prevMinCycles = 0;
    ClockCycleCount currentMinCycles = 0;

   for (int i = 0; i < estimates.cycleCounts(); i++) {
        if (i == 0) {
            currentMinCycles = estimates.cycleCount(i);
            continue;
        }
        if (estimates.cycleCount(i) < currentMinCycles) {
            currentMinCycles = estimates.cycleCount(i);
        }
    }
    MachineResourceModifier modifier;

    TTAMachine::Machine* newMach = NULL;
    RowID lastArchID = 0;
    RowID lastConfID = 0;

    std::list<std::string> removedBusNames;

    // use binary search to find out the bus count that can be removed
    while (busLow < busMid) {
        prevMinCycles = currentMinCycles;
        newMach = new TTAMachine::Machine(*mach);
        try {
            int amountOfBusesToReduce = (origBusCount - busMid);
            modifier.reduceBuses(
                amountOfBusesToReduce, *newMach, removedBusNames);
            DSDBManager::MachineConfiguration newConfiguration;
            lastArchID = dsdb_.addArchitecture(*newMach);
            newConfiguration.architectureID = lastArchID;
            newConfiguration.hasImplementation = false;
            lastConfID = dsdb_.addConfiguration(newConfiguration);
            CostEstimates newEstimates;
            if (explorer.evaluate(newConfiguration, newEstimates, false)) {
                for (int i = 0; i < newEstimates.cycleCounts(); i++) {
                    // resets the currentMinCycles 
                    if (i == 0) {
                        currentMinCycles = newEstimates.cycleCount(i);
                        continue;
                    }
                    if (newEstimates.cycleCount(i) < currentMinCycles) {
                        currentMinCycles = newEstimates.cycleCount(i);
                    }
                }
                if (currentMinCycles < maxCycles) {
                    busHigh = busMid - 1;
                    busMid = (busLow + busHigh) / 2;
                } else {
                    busLow = busMid + 1;
                    busMid = (busLow + busHigh) / 2;
                }
                
                if (busLow < busMid) {
                    delete newMach;
                    newMach = NULL;
                }
            } else {
                break;
            }
        } catch (const Exception& e) {            
            throw e;
        }
    }

    // create new idf for the new machine if needed
    if (configuration.hasImplementation && lastArchID != 0) {
        IDF::MachineImplementation* idf =
            dsdb_.implementation(configuration.implementationID);
        std::list<std::string>::const_iterator busNameIter = 
            removedBusNames.begin();
        while (busNameIter != removedBusNames.end()) {
            idf->removeBusImplementation(*busNameIter);
            busNameIter++;
        }
        DSDBManager::MachineConfiguration newConfiguration;
        newConfiguration.architectureID = lastArchID;
        newConfiguration.hasImplementation = true;
        CostEstimates newEstimates;
        if (explorer.evaluate(newConfiguration, newEstimates, false)) {
            newConfiguration.implementationID = 
                dsdb_.addImplementation(
                    *idf, newEstimates.longestPathDelay(),newEstimates.area());

            delete idf;
            idf = NULL;

            RowID confID = dsdb_.addConfiguration(newConfiguration);
            return confID;
        } else {
            return confToMinimize;
        }
    } else {
        delete newMach;
        newMach = NULL;
        return lastConfID;
    }
    
    assert(false);
    return 9999; 
}

/**
 * Minimizes the number of buses, function units and register files in the given
 * configuration in that order.
 *
 * This function minimizes the buses first, then function units and then 
 * register files.
 * Removes also the extra sockets after minimization. Won't handle
 * implementaions (IDF handling missing from fu and rf part).
 *
 * @param confToMinimize Configuration to be minimized.
 * @param maxCycles Maximum clock cycle count that won't be exceeded.
 * @return Minimized configuration id.
 */
RowID
CycleOptimizer::minimizeBusFURF(
    RowID confToMinimize, ClockCycleCount maxCycles) 
    throw (KeyNotFound) {

    RowID minBus = minimizeBuses(confToMinimize, maxCycles);
    RowID minFU = minimizeFunctionUnits(minBus, maxCycles);
    RowID minRF = minimizeRegisterFiles(minFU, maxCycles);

    return minRF;
}
