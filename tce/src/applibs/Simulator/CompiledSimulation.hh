/*
    Copyright 2002-2008 Tampere University of Technology.  All Rights
    Reserved.

    This file is part of TTA-Based Codesign Environment (TCE).

    TCE is free software; you can redistribute it and/or modify it under the
    terms of the GNU General Public License version 2 as published by the Free
    Software Foundation.

    TCE is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
    details.

    You should have received a copy of the GNU General Public License along
    with TCE; if not, write to the Free Software Foundation, Inc., 51 Franklin
    St, Fifth Floor, Boston, MA  02110-1301  USA

    As a special exception, you may use this file as part of a free software
    library without restriction.  Specifically, if other files instantiate
    templates or use macros or inline functions from this file, or you compile
    this file and link it with other files to produce an executable, this
    file does not by itself cause the resulting executable to be covered by
    the GNU General Public License.  This exception does not however
    invalidate any other reasons why the executable file might be covered by
    the GNU General Public License.
*/
/**
 * @file CompiledSimulation.hh
 *
 * Declaration of CompiledSimulation abstract class.
 *
 * @author Viljami Korhonen 2007 (viljami.korhonen-no.spam-tut.fi)
 * @note This file is used in compiled simulation. Keep dependencies *clean*
 * @note rating: red
 */

#ifndef COMPILED_SIMULATION_HH
#define COMPILED_SIMULATION_HH

#include "SimulatorConstants.hh"
#include "SimValue.hh"
#include "OperationPool.hh"

namespace TTAMachine {
    class Machine;
    class FunctionUnit;
}

namespace TTAProgram {
    class Program;
}

class SimulatorFrontend;
class CompiledSimController;
class DirectAccessMemory;
class MemorySystem;
class SimulatorFrontend;
class CompiledSimulationEngine;
class CompiledSimulationPimpl;
class CompiledSimulation;
struct ProcedureBBRelations;


/// Type for the simulateXXXXX basic block functions
typedef void (*SimulateFunction)(CompiledSimulationEngine& engine);

// Used to set export symbols visible
#define EXPORT __attribute__((visibility("default")))


/**
 * A struct that describes a single FU result type
 */
struct FUResultElementType {
    /// time when this result is ready
    ClockCycleCount cycles;
    
    /// FU Result value
    SimValue value;
    
    /// Is this result element used in the array or not
    bool used;
    
    FUResultElementType() : cycles(0), used(false) {}
};

/**
 * A struct for dynamic array containing the FU results
 */
struct FUResultType {
    /// size of the array
    const int size;
    /// array of result elements
    FUResultElementType* data;
    /// Number of active elements in the buffer
    int numberOfElements;
    
    /// A constructor that resets the variables
    FUResultType(int maxLatency) 
        : size(maxLatency), 
          data(new FUResultElementType[size]),
          numberOfElements(0) {}
    /// The destructor. Frees all memory
    ~FUResultType() { delete[] data; data = 0; }
};


/**
 * An abstract class that is used as a base for all the compiled simulations
 * 
 * The derived classes are generated by CompiledSimCodeGenerator and then
 * get loaded as plugins by the CompiledSimController.
 * 
 */
class CompiledSimulation {
public:    
    CompiledSimulation(
        const TTAMachine::Machine& machine,
        InstructionAddress entryAddress,
        InstructionAddress lastInstruction,
        SimulatorFrontend& frontend,
        CompiledSimController& controller,
        MemorySystem& memorySystem,
        bool dynamicCompilation,
        ProcedureBBRelations& procedureBBRelations);
    virtual ~CompiledSimulation();
    
    virtual void simulateCycle() = 0;
    virtual void cycleEnd();
    
    virtual void step(double count);
    virtual void next(int count);
    virtual void run();
    virtual void runUntil(UIntWord address);
            
    virtual InstructionAddress programCounter() const;
    virtual InstructionAddress lastExecutedInstruction() const;
    
    virtual ClockCycleCount cycleCount() const;
    
    virtual SimValue registerFileValue(
        const char* rfName, 
        int registerIndex);
    
    virtual SimValue immediateUnitRegisterValue(
        const char* iuName, int index);
    
    virtual SimValue FUPortValue(
        const char* fuName,
        const char* portName);
    
    virtual void requestToStop();
    virtual bool stopRequested() const;
    virtual bool isFinished() const;
    
    virtual ClockCycleCount moveExecutionCount(
        int moveNumber,
        InstructionAddress address) const;
    virtual InstructionAddress basicBlockStart(InstructionAddress address)
        const;
    
   
    // Variables are defined public because of external C functions...
    /// Number of cycles simulated so far
    ClockCycleCount cycleCount_;
    /// Number of basic blocks gone through
    int basicBlockCount_;
    /// The jump target. Allows jumping to different addresses in the code
    InstructionAddress jumpTarget_;
    /// The program counter. i.e. which address the simulation is currently at
    InstructionAddress programCounter_;
    /// Last executed instruction
    InstructionAddress lastExecutedInstruction_;    
    /// Number of cycles left to simulate until the execution returns
    ClockCycleCount cyclesToSimulate_;
    /// Should the simulation stop or not?
    bool stopRequested_;  
    /// Is the simulation finished?
    bool isFinished_;
    
    /// The operation pool
    OperationPool operationPool_;
    /// Next jump target as a function pointer" << endl
    SimulateFunction jumpTargetFunc_;

    /// A flag for FU conflict detection
    bool conflictDetected_;
    
    /// Move execution counts in a C style table
    // Moves must be ordered in the same way as in POM!
    // Also, only guarded move executions are stored here.
    ClockCycleCount* moveExecCounts_;
    /// Basic block execution counts in a C style table
    // Basic blocks are referred by their start addresses. 
    ClockCycleCount* bbExecCounts_;
    
    static void inline clearFUResults(
        FUResultType& results);
    
    static void inline addFUResult(
        FUResultType& results,
        ClockCycleCount cycleCount,
        const SimValue& value,
        int latency);
    
    static void inline addFUResult(
        FUResultType& results,
        ClockCycleCount cycleCount,
        const UIntWord& value,
        int latency);
    
    static void inline FUResult(
        SimValue& target,
        FUResultType& results,
        ClockCycleCount cycles);
        
protected:
    TTAMachine::FunctionUnit& functionUnit(const char* name) const;
    
    DirectAccessMemory& FUMemory(const char* FUName) const;
    MemorySystem* memorySystem() const;
    SimulatorFrontend& frontend() const;
    void msg(const char* message) const;
    void haltSimulation(
        const char* file,
        int line,
        const char* procedure,
        const char* message) const;    
    
    void resizeJumpTable(int newSize);
    SimulateFunction getSimulateFunction(InstructionAddress address);
    void setJumpTargetFunction(InstructionAddress address, SimulateFunction fp);
    void compileAndLoadFunction(InstructionAddress address);
    
    SimValue* getSymbolValue(const char* symbolName);
    void addSymbol(const char* symbolName, SimValue& value);

    /// Is this a dynamic compiled simulation?
    bool dynamicCompilation_;
    
    /// A struct for finding out procedure begins from procedure's basic blocks
    ProcedureBBRelations& procedureBBRelations_;

    /// The simulated machine
    const TTAMachine::Machine& machine_;
    
    /// Entry address of the program
    const InstructionAddress entryAddress_;
    /// Last instruction of the program
    const InstructionAddress lastInstruction_;

private:
    /// Copying not allowed.
    CompiledSimulation(const CompiledSimulation&);
    /// Assignment not allowed.
    CompiledSimulation& operator=(const CompiledSimulation&);
    
    /// Private implementation in a separate source file
    CompiledSimulationPimpl* pimpl_;
};


#include "CompiledSimulation.icc"

#endif
