/*
    Copyright 2002-2008 Tampere University of Technology.  All Rights
    Reserved.

    This file is part of TTA-Based Codesign Environment (TCE).

    TCE is free software; you can redistribute it and/or modify it under the
    terms of the GNU General Public License version 2 as published by the Free
    Software Foundation.

    TCE is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
    details.

    You should have received a copy of the GNU General Public License along
    with TCE; if not, write to the Free Software Foundation, Inc., 51 Franklin
    St, Fifth Floor, Boston, MA  02110-1301  USA

    As a special exception, you may use this file as part of a free software
    library without restriction.  Specifically, if other files instantiate
    templates or use macros or inline functions from this file, or you compile
    this file and link it with other files to produce an executable, this
    file does not by itself cause the resulting executable to be covered by
    the GNU General Public License.  This exception does not however
    invalidate any other reasons why the executable file might be covered by
    the GNU General Public License.
*/
/**
 * @file ExecutableInstruction.icc
 *
 * Inline method definitions of ExecutableInstruction class.
 *
 * @author Pekka J‰‰skel‰inen 2005 (pjaaskel-no.spam-cs.tut.fi)
 * @note rating: red
 */

#include "ExecutableInstruction.hh"
#include "ExecutableMove.hh"
#include "LongImmUpdateAction.hh"
#include "SequenceTools.hh"

/**
 * Executes the instruction.
 *
 * First all long immediate update actions are executed. 
 * Next, guards are evaluated to decide which moves will be squashed and
 * which not. Finally, data transports of the unsquashed moves are 
 * executed.
 */
inline void
ExecutableInstruction::execute() {

    // have to evaluate the guards before either a long immediate
    // or a register transport overwrites it
    for (std::size_t i = 0; i < moves_.size(); ++i) {
        moves_[i]->evaluateGuard();
    }
    for (std::size_t i = 0; i < moves_.size(); ++i) {
        moves_[i]->executeRead();
    }
    for (std::size_t i = 0; i < moves_.size(); ++i) {
        moves_[i]->executeWrite();
    }
    // long immediate latency is fixed to 1, zero latency is not
    // supported, thus the updates are not visible to the moves
    // in the same instruction
    for (std::size_t i = 0; i < updateActions_.size(); ++i) {
        updateActions_[i]->execute();
    }
    executionCount_++;
}

/**
 * Returns true in case the move with the given index was squashed the last 
 * time the instruction was executed.
 *
 * Being squashed means that the move is guarded and the guard expression
 * evaluated to false.
 *
 * @param moveIndex Index of the move to query.
 * @return True in case move was squashed.
 */
inline bool 
ExecutableInstruction::moveSquashed(std::size_t moveIndex) const {
    return moves_[moveIndex]->squashed();
}

/**
 * Returns true in case this instruction is considered a program
 * exit point: the simulation should stop *after* executing this instruction.
 */
inline bool
ExecutableInstruction::isExitPoint() const {
    return exitPoint_;
}

/**
 * Sets the instruction's exit point status.
 *
 * @see isExitPoint()
 */
inline void
ExecutableInstruction::setExitPoint(bool b) {
    exitPoint_ = b;
}
