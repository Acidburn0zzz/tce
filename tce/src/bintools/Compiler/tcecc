#!/usr/bin/python
#
# Compiler driver for tce-llvm-gcc toolset
#

import os, sys, commands, optparse, shutil, glob
import os.path

from tempfile import mkdtemp
from optparse import OptionParser
from shutil import rmtree

debugMode = False
tempDir = mkdtemp("","tcecc-")

def cleanup(tmpDir):
    """Removes temporary files created during build."""
    if options.leave_dirty == False:
        rmtree(tmpDir, ignore_errors=True)
    else:
        sys.stdout.write("Intermediate files left in build dir " +\
                         tmpDir + "\n")

def tryRemove(filename):
    """Tries to remove a file."""
    try:
        os.remove(filename)
    except:
        pass

def runCommand(command, echoOutput):
    """Runs a command and prints everything if requested."""

    if echoOutput:
        print command

    (exitCode, output) = commands.getstatusoutput(command)

    if echoOutput:
        print output

    return (exitCode, output)
    

# TODO: add support for ll and check if file is .bc object from magic number...
def processInputFiles(inFiles, tmpDir, verbose):
    
    """ Compiles input files to .bc files and returns list
    cotaining all the files to link together.
    """

    compileFlags=""

    if options.compile_only:
        compileFlags += "-c "

    for i in options.defines:
        compileFlags += "-D" + i + " "

    for i in options.include_dirs:
        compileFlags += "-I" + i + " "

    # list of valid suffixes
    knownSuffices = [".cpp", ".cc", ".c", ".bc", ".o", ".a"]

    linkList = []

    # Compile input files if needed
    if len(inFiles) == 0:
        exitWithError(
            1, verbose,
            "There must be at least one .bc, .c, .cc or .cpp file given.\n")
    else: 
        for fName in inFiles:
            # check file type based on knownSuffices
            baseName = ""
            suffix = ""
            for i in range(len(knownSuffices)):
                testSuffix = knownSuffices[i]
                suffixStart = fName.rfind(testSuffix)

                if suffixStart != -1:
                    suffix = fName[suffixStart:len(fName)]
                    baseName = fName[0:suffixStart]

                    if suffix == testSuffix:
                        break
                    else:
                        baseName = ""
                        suffix = ""
            
            if baseName != "" and suffix != "":
                # gen command for compiling, for files that need to
                # be compiled first
                command = ""
                
                # After compilation all malloc instructions are lowered
                # to function calls... if malloc function
                # is implemented as a instruction in llvm assembler,
                # it won't be linked to final binary from libc.a
                # (ld knows how to select only needed parts from libc.a,
                # even thoug it does it very bad, it shorten optimizetime)
                outFileName = tmpDir + "/" + os.path.basename(baseName) + ".o"
                if suffix == ".c":                    
                    command = "tce-llvm-gcc --emit-llvm -O2 -ffreestanding "\
                              "-fno-unit-at-a-time -fno-inline -c -I" + tmpDir +\
                              " " + compileFlags + baseName + suffix + " -o " +\
                              outFileName + ".tobelowered;"  

                    command += lowerMemIntrinsicCommand(outFileName + ".tobelowered", outFileName)
                    
                   
                elif suffix == ".cpp" or suffix == ".cc":
                    command = "tce-llvm-g++ --emit-llvm -O2 -ffreestanding "\
                              "-fno-unit-at-a-time -fno-inline -c -I" + tmpDir +\
                              " " + compileFlags + baseName + suffix + " -o " +\
                              outFileName + ".tobelowered;" 

                    command += lowerMemIntrinsicCommand(outFileName + ".tobelowered", outFileName)

                elif suffix == ".bc":
                    exitWithError(
                        1, verbose,
                        "Bytecode files can't be relinked. "
                        "Use .o suffix for unlinked bytecode files.\n")

                elif suffix == ".o":
                    outFileName =  fName

                elif suffix == ".a":
                    outFileName = fName

                # add all files to list for linkage
                linkList += [outFileName]

                if command != "":                    
                    (exitCode, output) = runCommand(command, verbose)
                    if exitCode != 0:
                        exitWithError(
                            1, verbose,
                            "Error while compiling file: " +\
                            baseName + suffix + "\n" + output + "\n")
            else:
                exitWithError(
                    1, verbose,\
                    "Unknown input file type: " +\
                    fName + ". Supported file types " +\
                    str(knownSuffices) + "\n")
    return linkList

def exitWithError(status, alreadyVerbose, output):
    if not alreadyVerbose:
        sys.stderr.write(output + "\n")
    cleanup(tempDir)
    sys.exit(status)


def lowerMemIntrinsicCommand(srcFile, dstFile):
    global lowerintrinsicsplugin
    commandp = "opt -load=" + lowerintrinsicsplugin + " -lowerintrinsics "
    command = commandp + " -o " + dstFile + " " + srcFile
    return command
    
###
# Links bytecode files and returns name of the linked file.
##
def linkBytecode(linkFiles, fileNamePrefix, verbose):

    global llvmGccPrefix
    
    llvmGccStartFiles = llvmGccPrefix + "/tce-llvm/lib/crt0.o "

    llvmGccEndFiles = (llvmGccPrefix + "/tce-llvm/lib/libc.a " +
                       llvmGccPrefix + "/tce-llvm/lib/libnosys.a " +
                       llvmGccPrefix + "/tce-llvm/lib/libm.a " +
                       llvmGccPrefix + "/tce-llvm/lib/crtend.o ")


    linkedFileName = fileNamePrefix + "_linked"
    #### Link all binary code together
    command = "llvm-ld -disable-opt -o " + linkedFileName + " " + llvmGccStartFiles
    for name in linkFiles:
        command += " " + name

    command += " " + llvmGccEndFiles

    (exitCode, output) = runCommand(command, options.verbose)
    if exitCode != 0:
        sys.stderr.write("Error while linking bytecode: " + command + "\n")
        exitWithError(1, verbose, output)

    # remove annoying autogenerated script.
    tryRemove(linkedFileName)

    return linkedFileName + ".bc"

####
# Optimizes linked bc. Returns name of the optimized file.
###
def optimizeBytecode(inFile, fileNamePrefix):

    global options

    verbose = options.verbose

    loop_unroll_switches = " -loop-unroll -unroll-threshold=1000 "

    tce_std_compile_opts = (" " +
        "-preverify -domtree -verify -lowersetjmp -raiseallocs -simplifycfg -domtree " + 
        "-domfrontier -mem2reg -globalopt -globaldce " + 
        "-ipconstprop -deadargelim -instcombine " +
        "-simplifycfg -basiccg -prune-eh -inline " +
        "-argpromotion -tailduplicate -simplify-libcalls " + 
        "-instcombine -jump-threading -simplifycfg -domtree -domfrontier -scalarrepl " + 
        "-instcombine -break-crit-edges -condprop -tailcallelim -simplifycfg -reassociate " + 
        "-domtree -loops -loopsimplify -domfrontier -scalar-evolution -lcssa -loop-rotate " + 
        "-licm -lcssa -loop-unswitch -scalar-evolution -lcssa -loop-index-split -instcombine " + 
        "-scalar-evolution -domfrontier -lcssa " + 
        "-indvars -domfrontier -scalar-evolution " +
        "-lcssa " +
        loop_unroll_switches +
        "-instcombine -domtree " +
        "-memdep -gvn " + 
#        "-memcpyopt " +
        "-sccp " + 
        "-instcombine -break-crit-edges -condprop -memdep -dse -mergereturn -postdomtree " + 
        "-postdomfrontier -adce -simplifycfg -strip-dead-prototypes -printusedtypes " + 
        "-deadtypeelim -constmerge -preverify -domtree -verify" + 
        "")
    
    defOptimization = ""

    if options.optimization_level == 0:
        optSwitches = defOptimization
        options.sequential_schedule = True

    elif options.optimization_level == 1:
        optSwitches = defOptimization + tce_std_compile_opts

    elif options.optimization_level == 2 or options.optimization_level == 3:
        optSwitches = defOptimization + " -internalize " + tce_std_compile_opts
    else:
        exitWithError(
            1, verbose,\
            "Optimization level " +\
            str(options.optimization_level) + " not defined.\n")

    internalize_api_list = " -internalize-public-api-list=_start"
    if options.keep_symbols != "":
        internalize_api_list += "," + options.keep_symbols
    optSwitches += internalize_api_list

    if options.noinline:
        optSwitches += " -disable-inlining"

    outputName = fileNamePrefix + "_optimized.bc"
        
    command = "opt -f " + inFile + " -o " +\
              outputName +\
              optSwitches

    (exitCode, output) = runCommand(command, verbose)
    if exitCode != 0:
        sys.stderr.write("Error while optimizing bytecode: " + command + "\n")
        exitWithError(1, verbose, output)

    return outputName

####
# Link emulation function bytecode to program.
###
def linkEmulationFuncs(inFile, fileNamePrefix):

    global llvmGccPrefix, llvmprefix, tceprefix, options

    verbose = options.verbose

    # if software floatingpoint should be lowered, link the emulation functions in
    emulationLib = llvmGccPrefix + "/tce-llvm/lib/emulation_functions.o "
    linkedName = fileNamePrefix + "_libemul.bc"
        
    command = ("llvm-link -f " + inFile + " " + emulationLib + " -o " + linkedName)

    (exitCode, output) = runCommand(command, verbose)

    if exitCode != 0:
        sys.stderr.write("Error while linking emulation lib: " + command + "\n")
        exitWithError(1, verbose, output)

    outputName = fileNamePrefix + "_emul_internalized.bc"


    internalize_api_list = " -internalize-public-api-list=_start"
    if options.keep_symbols != "":
        internalize_api_list += "," + options.keep_symbols
    
    command = ("opt " + linkedName +
               " -f -internalize " + internalize_api_list + " -o " + outputName)

    if options.noinline:
        command += " -disable-inlining"

    (exitCode, output) = runCommand(command, verbose)

    if exitCode != 0:
        sys.stderr.write("Error while internalizing emulation functions: " + command + "\n")
        exitWithError(1, verbose, output)

    return outputName

#############################################
# Main program
#############################################

# Options..
usage = "usage: %prog [options] source-or-bc-file1 source-or-bc-file2 ..."

p = optparse.OptionParser(usage)

p.add_option('-a', '--adf-file',
             type="string", action="store", metavar='file',
             dest="adf_file", default="",
             help="Architecture which for program is scheduled after "
             "the compilation. Note that 'schedule' must be installed.")

p.add_option('-s', '--scheduler-config',
             type="string", action="store", metavar='file',
             dest="scheduler_config", default=None,
             help="Configure file for scheduling command.")

p.add_option('-O', '--optimization-level',
             type="int", action="store", metavar='level',
             dest='optimization_level', default=0,
             help="Optimization level. 0=no optimizations, "
             "1=preserve program API, 2=don't respect original API, "
             "3 = same that 2. NOTE: For optimal floating point performance,"
             "this switch must be given also when compiling bc files to tpef.")

p.add_option('-k', '--keep-symbols',
             type="string", action="store",
             metavar='sym1,sym2,sym3', dest='keep_symbols', default="",
             help="List of symbols whose optimization away is prevented. "
             "If you are using this, remember to define "
             "at least 'main' symbol.")

p.add_option('-o', '--output-name',
             type="string", action="store", metavar='file',
             dest="output_name", default="",
             help="File name for output binary.")

p.add_option('-d', '--leave-dirty', action="store_true",
             dest='leave_dirty', default=False,
             help="Do not delete files from each compilation phase.")

p.add_option('-c', '--compile-only', action="store_true",
             dest='compile_only', default=False,
             help="Compile only do not link or optimize.")

p.add_option('-v', '--verbose', action="store_true",
             dest='verbose', default=False,
             help="Print out commands and outputs for each phase.")

p.add_option('-D', '--preprocessor-define', 
             type="string", action="append", metavar='string',
             dest="defines", default=[],
             help="Passed to gcc.")

p.add_option('-I', '--include-directory', 
             type="string", action="append", metavar='directory',
             dest="include_dirs", default=[],
             help="Passed to gcc.")

p.add_option('-L', '--library-directory', 
             type="string", action="append", metavar='directory',
             dest="lib_dirs", default=[],
             help="Passed to gcc.")

p.add_option('-l', '--library-link', 
             type="string", action="append", metavar='libname',
             dest="libs", default=[],
             help="Converted to static link command. i.e. -lpthread  => /llvm-install/tce-llvm/lib/libpthread.a")

p.add_option('-W', '--warning', 
             type="string", action="append", metavar='type',
             dest="warnings", default=[],
             help="Ignored.")

p.add_option('--plugin-cache-dir',
             type="string", action="store", metavar='directory',
             dest="plugin_cache_dir",
             default=os.path.expanduser("~/.tce/tcecc/cache"),
             help="Directory for cached llvm target plugins.")

p.add_option('--no-plugin-cache', action="store_true",
             dest="no_cache", default=False,
             help="Do not cache generated llvm target plugins.")

p.add_option('--no-schedule', action="store_true",
             dest="no_schedule", default=False,
             help="Do not call scheduler.")

p.add_option('--clear-plugin-cache', action="store_true",
             dest="clear_cache", default=False,
             help="Clear plugin cache completely.")

p.add_option('--disable-inlining', action="store_true",
             dest="noinline", default=False,
             help="Disable function inlining.")

p.add_option('--sequential-schedule', action="store_true",
             dest="sequential_schedule", default=False,
             help="Runs sequential scheduler for compiled code.")

p.add_option('--debug', action="store_true",
             dest="debug", default=False,
             help="Print LLVM debug data.")

p.add_option('--max-thread-latency',
             type="int", action="store", metavar='usec',
             dest='max_thread_latency',
	     default=None,
             help=\
"""Emit sched_yield() calls to the program to produce given maximum thread
switch latency (in microseconds). In case the target does not have the RTIMER
operation, sched_yield() is called in every basic block unconditionally, 
producing considerable additional overhead to the program exectuion.""")

# get commandline arguments
options, inFiles = p.parse_args()

# clear plugin cache and do nothing else if the --clear-plugin-cache
# option is given
if options.clear_cache:
    pluginFiles = glob.glob(options.plugin_cache_dir + '/*.so')
    for fName in pluginFiles:
        tryRemove(fName)

    sys.stdout.write("Cleared plugin cache.\n")
    sys.exit(0)

if len(inFiles) == 0:
    p.print_help()
    sys.exit(1)

if options.output_name == "":
    outputName = "llvm_output"
else:
    outputName = options.output_name

### llvm-gcc install prefix
(exitCode, output) = runCommand("dirname `which tce-llvm-gcc`", False)
if exitCode != 0:
    sys.stderr.write("Could not find 'tce-llvm-gcc'. Have you installed it in PATH?\n")
    exitWithError(1, options.verbose, output)
llvmGccPrefix = output + "/.."

### tce install prefix
(exitCode, output) = runCommand("tce-config --prefix", False)
if exitCode != 0:
    tceInstalled = False
else:
    tceInstalled = True
    tceprefix = output

## check if we are running from the TCE source tree in which case use only
## source tree libraries and binaries
scriptDir = os.path.abspath(os.path.dirname(sys.argv[0]))
runningInstalled = 'src/bintools/Compiler' not in scriptDir

if not runningInstalled:
    srcRoot = scriptDir.split('bintools/Compiler')[0]
else:
    srcRoot = None

if options.verbose:
    if not runningInstalled:
        print "Running from a TCE source tree rooted at '%s'." % srcRoot
    else:
        print "Running installed TCE from PATH."    
    
if not runningInstalled:
    lowerintrinsicsplugin = srcRoot + "/applibs/LLVMBackend/passes/LowerIntrinsics.so"
else:
    lowerintrinsicsplugin = tceprefix + "/share/tce/llvm/passes/LowerIntrinsics.so"
    
namePrefix = tempDir + "/" + os.path.basename(outputName)

if options.compile_only and options.output_name != "" and len(inFiles) > 1:
    sys.stdout.write("Cannot specify -o  with -c and multiple input files.\n")
    sys.exit(1)

elif len(inFiles) == 1 and inFiles[0][-3:] == ".bc":
    # Only one .bc inputfile given. No need to compile, link or optimize anything.
    # Note: Already linked bytecode can't be linked or optimized
    # with -lowermissing again anyway!
    optimizedFileName = inFiles[0]
else:
    # Compile, link and optimize input files.
    
    # generate tceops.h
    if runningInstalled:
        tceopgen = "tceopgen"
    else:
        tceopgen = srcRoot + "/bintools/Compiler/tceopgen/tceopgen"
        
    (exitCode, output) = runCommand(
        tceopgen + " -o " + tempDir + "/tceops.h" , options.verbose)
    
    if exitCode != 0:
        sys.stderr.write("Error while generating custom operation macros:\n")
        exitWithError(1, options.verbose, output)
    
    linkList = processInputFiles(inFiles, tempDir, options.verbose)

    # if only compiling
    if options.compile_only:
        if options.output_name != "":
            (exitCode, output) = runCommand(
                "mv " + linkList[0] + " " + options.output_name,
                options.verbose)

        else:
            cmd = "mv "
            for fName in linkList:
                cmd += fName + " "
            cmd += "."
            (exitCode, output) = runCommand(cmd, options.verbose)

        cleanup(tempDir)
        sys.exit(0)

    # lower memset intrinsics
    # loweredList = lowerMemIntrinsics(linkList, options.verbose)
    # linkedFileName = linkBytecode(loweredList, namePrefix, options.verbose)

    # convert -l switches to static library link commands.
    for i in options.libs:
        linkList.append(llvmGccPrefix + "/tce-llvm/lib/lib%s.a" % i)
    
    linkedFileName = linkBytecode(linkList, namePrefix, options.verbose)

    # optimize
    optimizedFileName = optimizeBytecode(linkedFileName, namePrefix)

    if (options.adf_file == ""):
        (exitCode, output) = runCommand(
            "mv " +  optimizedFileName + " " + outputName,
            options.verbose)
        
#### Schedule compiled sequential code for machines
if options.adf_file != "":

    outFile = outputName
    seqFile = tempDir + "/" + os.path.basename(outFile) + ".seq"

    # optimize and lower flaotingpoint
    emulationLinkedFileName = linkEmulationFuncs(optimizedFileName, namePrefix)

    if options.sequential_schedule:
        scheduler_config_file_name = "sequential_tcecc_scheduler.conf"
    else:
        scheduler_config_file_name = "default_scheduler.conf"        
        
    if options.no_schedule is False and options.scheduler_config is None:
        if runningInstalled:
            options.scheduler_config = (tceprefix +
                                        "/share/tce/scheduler/passes/" +
                                        scheduler_config_file_name)
        else:
            options.scheduler_config = os.path.normpath(srcRoot +
                                                        "../scheduler/passes/" +
                                                        scheduler_config_file_name)

    #### Compile to unscheduled mixed code for the target architecture
    if not runningInstalled:
        command = srcRoot + "/bintools/Compiler/llvm-tce/llvm-tce"
    else:
        command = "llvm-tce"

    if options.verbose:
        command += " -v"
        
    if options.debug:
        command += " --debug"

    if options.no_schedule is False:
        command += " -c " + options.scheduler_config

    command += (" -a " + options.adf_file +
                " -o " + outFile +\
                " -O" + str(options.optimization_level) +\
                " " + emulationLinkedFileName)
    
    if options.max_thread_latency is not None:
	    # Temporary hack until 'schedule' supports passing cmdline
	    # options to passes.
	    import os
	    os.environ['MAX_THREAD_SWITCH_LATENCY'] = \
		str(options.max_thread_latency)
    
    (exitCode, output) = runCommand(command, options.verbose)
    if exitCode != 0:
        sys.stderr.write("Error while compiling " + command + "\n")
        exitWithError(1, options.verbose, output)


#### Cleanup trashes
cleanup(tempDir)
