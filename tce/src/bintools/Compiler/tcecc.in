#!/usr/bin/env python
# -*- coding: utf-8 -*-
# 
# Copyright (c) 2002-2010 Tampere University of Technology.
#
# This file is part of TTA-Based Codesign Environment (TCE).
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.
#
# @author 2006-2010 Pekka Jääskeläinen
# @author 2006-2009 Veli-Pekka Jääskeläinen
#
#
# Compiler driver for tce-llvm-gcc toolset
#

import os, sys, commands, optparse, shutil, glob, signal
import os.path

from tempfile import mkdtemp
from optparse import OptionParser
from shutil import rmtree
from subprocess import Popen, PIPE

def runCommandBuffered(command, echoOutput):
    """Runs a command and prints everything if requested."""

    if echoOutput:
        print command

    (exitCode, output) = commands.getstatusoutput(command)

    if echoOutput:
        print output

    return (exitCode, output)

# global variables...
debugMode = False
options = None
newlib_libdir = ""
newlib_includes = ""
lowerintrinsicsplugin=""

def handler(signum, frame):
    cleanup(tempDir)
    sys.exit(2)

def cleanup(tmpDir):
    """Removes temporary files created during build."""
    if options.leave_dirty == False:
        rmtree(tmpDir, ignore_errors=True)
    else:
        sys.stdout.write("Intermediate files left in build dir " +\
                         tmpDir + "\n")

def tryRemove(filename):
    """Tries to remove a file."""
    try:
        os.remove(filename)
    except:
        pass

def runCommand(command, echoOutput=True, echoStderr=False, stdoutFD=None):
    """Runs the given shell command and returns its exit code.

    If echoOutput is False, stdout and stderr are redirected to /dev/null."""
       
    if echoOutput:
        print command
        stderrFD = None
    else:
        if stdoutFD is None:
            stdoutRedir = open('/dev/null', 'w')
            stdoutFD = stdoutRedir.fileno()
        if not echoStderr:
            stderrRedir = open('/dev/null', 'w')
            stderrFD = stderrRedir.fileno()
        else:
            stderrFD = None

    process = \
       Popen(command, shell=True, stdin=PIPE, stdout=stdoutFD,
             stderr=stderrFD, close_fds=False)
    return process.wait()
    

# TODO: add support for ll and check if file is .bc object from magic number...
def processInputFiles(inFiles, tmpDir, verbose):
    
    """ Compiles input files to .bc files and returns list
    cotaining all the files to link together.
    """

    compileFlags=newlib_includes

    if options.compile_only and not options.use_clang:
        compileFlags += "-c "

    if options.g_cc_switch:
        compileFlags += "-g "

    for i in options.defines:
        compileFlags += "-D" + i + " "

    for i in options.include_dirs:
        compileFlags += "-I" + i + " "

    for w in options.warnings:
        # Types of warnings supported by the compiler:
        white_list = []
        if options.use_clang:
            white_list = ['no-unknown-warning-option',
                          'no-bad-literal',
                          'no-literal-range',
                          'no-pointer-sign',
                          'no-return-type', 
                          'no-unused-value',
                          'no-implicit-function-declaration']
        if w in white_list:
            compileFlags += "-W" + w + " "

    if not options.use_clang: # Clang 1.0 does not support -B
        for i in options.B_cc_switches:
            compileFlags += "-B" + i + " "
        
    for i in options.f_cc_switches:
        if options.use_clang:
            # Some of the gcc -f flags not supported by clang,
            # just skip them silently for now for gcc compatibility.
            if i == "short-enums": continue
        compileFlags += "-f" + i + " "

    for i in options.isystem_cc_switches:
        compileFlags += "-isystem" + i + " "

    # list of valid suffixes
    knownSuffices = [".cpp", ".cc", ".c", ".bc", ".o", ".a"]

    linkList = []

    # Compile input files if needed
    if len(inFiles) == 0:
        exitWithError(
            1, 
            "There must be at least one .bc, .c, .cc or .cpp file given.\n")
    else: 
        for fName in inFiles:
            # check file type based on knownSuffices
            baseName = ""
            suffix = ""
            for i in range(len(knownSuffices)):
                testSuffix = knownSuffices[i]
                suffixStart = fName.rfind(testSuffix)

                if suffixStart != -1:
                    suffix = fName[suffixStart:len(fName)]
                    baseName = fName[0:suffixStart]

                    if suffix == testSuffix:
                        break
                    else:
                        baseName = ""
                        suffix = ""
            
            if baseName != "" and suffix != "":
                # gen command for compiling, for files that need to
                # be compiled first
                command = ""
                
                # After compilation all malloc instructions are lowered
                # to function calls... if malloc function
                # is implemented as a instruction in llvm assembler,
                # it won't be linked to final binary from libc.a
                # (ld knows how to select only needed parts from libc.a,
                # even thoug it does it very bad, it shorten optimizetime)
                outFileName = tmpDir + "/" + os.path.basename(baseName) + ".o"
                if suffix == ".c":
                    if options.use_clang:
                        command =  ("clang -O%d -ccc-host-triple tce-tut-llvm -emit-llvm -c "\
                                       "-I" + tmpDir +\
                                       " " + compileFlags + baseName + suffix + " -o " +\
                                       outFileName + ".tobelowered;" ) % options.optimization_level
                    else:
                        command = ("tce-llvm-gcc --emit-llvm -O%d -ffreestanding "\
                                       "-fno-unit-at-a-time -fno-inline -c -I" + tmpDir +\
                                       " " + compileFlags + baseName + suffix + " -o " +\
                                       outFileName + ".tobelowered;") % options.gcc_optlevel

                    command += lowerMemIntrinsicCommand(outFileName + ".tobelowered", outFileName)
                    
                   
                elif suffix == ".cpp" or suffix == ".cc":
                    command = ("tce-llvm-g++ --emit-llvm -O%d -ffreestanding "\
                              "-fno-unit-at-a-time -fno-inline -c -I" + tmpDir +\
                              " " + compileFlags + baseName + suffix + " -o " +\
                              outFileName + ".tobelowered;") % options.gcc_optlevel

                    command += lowerMemIntrinsicCommand(outFileName + ".tobelowered", outFileName)

                elif suffix == ".bc":
                    exitWithError(
                        1, 
                        "Bytecode files can't be relinked. "
                        "Use .o suffix for unlinked bytecode files.\n")

                elif suffix == ".o":
                    outFileName =  fName

                elif suffix == ".a":
                    outFileName = fName

                # add all files to list for linkage
                linkList += [outFileName]

                if command != "":                    
                    exitCode = runCommand(command, verbose, echoStderr=True)
                    if exitCode != 0:
                        exitWithError(
                            1, 
                            "Error while compiling file: " +\
                            baseName + suffix + "\n")
            else:
                exitWithError(
                    1, 
                    "Unknown input file type: " +\
                    fName + ". Supported file types " +\
                    str(knownSuffices) + "\n")
    return linkList

def exitWithError(status, errorMessage=None):
    if errorMessage is not None:
        print >>sys.stderr, errorMessage
    cleanup(tempDir)
    sys.exit(status)

def lowerMemIntrinsicCommand(srcFile, dstFile):
    commandp = "opt -load=" + lowerintrinsicsplugin + " -lowerintrinsics "
    command = commandp + " -o " + dstFile + " " + srcFile
    return command
    
###
# Links bytecode files and returns name of the linked file.
##
def linkBytecode(linkFiles, fileNamePrefix, verbose):

    startFiles = os.path.join(newlib_libdir,"crt0.o ")

    libNoSys = os.path.join(newlib_libdir,"libnosys.a")
    if not os.path.exists(libNoSys):
        libNoSys = ""

    # libm must be linked first to make sure that necessary parts of libc will be linkend in (e.g. errno)
    endFiles = (os.path.join(newlib_libdir,"libm.a") + " " +
                os.path.join(newlib_libdir,"libc.a") + " " +
                libNoSys + " " +
                os.path.join(newlib_libdir,"crtend.o") + " ")


    linkedFileName = fileNamePrefix + "_linked"
    #### Link all binary code together
    command = "llvm-ld -disable-opt -o " + linkedFileName + " " + startFiles
    for name in linkFiles:
        command += " " + name

    command += " " + endFiles

    exitCode = runCommand(command, options.verbose, echoStderr=True)
    if exitCode != 0:
        exitWithError(1, "Error while linking bytecode: " + command + "\n")

    # remove annoying autogenerated script.
    tryRemove(linkedFileName)

    return linkedFileName + ".bc"

####
# Optimizes linked bc. Returns name of the optimized file.
#
# You can check default switches with command:
# opt -O3 -debug-pass=Arguments systemtest/bintools/Scheduler/tests/QuickTests/HelloWorld/program.bc
###
def optimizeBytecode(inFile, fileNamePrefix):

    verbose = options.verbose

    # lets trust llvm team that they know which is the best
    # optimization set for overall performance... since when separately
    # adding own set we just end up tuning denbench / fft optimed switches
    # (its practically impossible to know how switches effect on any other case)
    default_opts = " -O3 "

    # no inline 
    default_opts += options.noinline and "-disable-inlining " or "-inline-threshold=%d " % options.inline_threshold

    # no need to run this, since intrinsics are lowered in isel...

    # hower if it's run before some optimizations is might be still
    # possible before isel in that case later optimization passes
    # must be selected very carefully in TCETargetMachine::addPreISel()
    
    #lowerIntrinsicsPass = " -load=" + lowerintrinsicsplugin + " -lowerintrinsics "
    #default_opts += lowerIntrinsicsPass

    # unroll swithes and disabling (threshold 0 should work as disable in opt)
    default_opts += "-unroll-allow-partial -unroll-threshold=%d " % options.unroll_threshold
       
    # -O0 optimization doesn't exist in opt
    optSwitches = ""

    if options.optimization_level == 0:
        options.sequential_schedule = True
    elif options.optimization_level == 1:
        optSwitches = (default_opts + "-disable-internalize ") 
    elif options.optimization_level > 1:
        optSwitches = (" -internalize "+ default_opts)

    if options.extra_llvm_opts != "":
        extra_opts = options.extra_llvm_opts.split(',')
        optSwitches += ' -' + ' -'.join(extra_opts)
    
    internalize_api_list = " -internalize-public-api-list=_start,_pthread_start"
    if options.keep_symbols != "":
        internalize_api_list += "," + options.keep_symbols
        
    optSwitches += internalize_api_list

    outputName = fileNamePrefix + "_optimized.bc"
        
    command = "opt -f " + inFile + " -o " + outputName + " " + optSwitches

    exitCode = runCommand(command, verbose)

    if exitCode != 0:
        exitWithError(1, "Error while optimizing bytecode: " + command + "\n")

    return outputName

####
# Link emulation function bytecode to program.
###
def linkEmulationFuncs(inFile, fileNamePrefix):

    verbose = options.verbose

    # if software floatingpoint should be lowered, link the emulation functions in
    emulationLib = os.path.join(newlib_libdir,"float_emulation.o") + " "
    linkedName = fileNamePrefix + "_libemul.bc"
        
    command = ("llvm-link -f " + inFile + " " + emulationLib + " -o " + linkedName)

    (exitCode, output) = runCommandBuffered(command, verbose)

    if exitCode != 0:
        exitWithError(1, "Error while linking emulation lib: " + command + "\n")

    outputName = fileNamePrefix + "_emul_internalized.bc"

    internalize_api_list = " -internalize-public-api-list=_start"
    if options.keep_symbols != "":
        internalize_api_list += "," + options.keep_symbols
    
    no_inline = ""
    if options.noinline:
        no_inline = " -disable-inlining"

    command = ("opt " + linkedName + no_inline +
               " -f -internalize " + internalize_api_list + " -o " + outputName)

    (exitCode, output) = runCommandBuffered(command, verbose)

    if exitCode != 0:
        sys.stderr.write("Error while internalizing emulation functions: " + command + "\n")
        exitWithError(1, output)

    return outputName

#############################################
# Main program
#############################################

# Options..
usage = "usage: %prog [options] source-or-bc-file1 source-or-bc-file2 ..."

p = optparse.OptionParser(usage)

p.add_option('-a', '--adf-file',
             type="string", action="store", metavar='file',
             dest="adf_file", default="",
             help="Architecture which for program is scheduled after "
             "the compilation. Note that 'schedule' must be installed.")

p.add_option('-s', '--scheduler-config',
             type="string", action="store", metavar='file',
             dest="scheduler_config", default=None,
             help="Configure file for scheduling command.")

p.add_option('-O', '--optimization-level',
             type="int", action="store", metavar='level',
             dest='optimization_level', default=3,
             help="Optimization level. 0=no optimizations, "
             "1=preserve program API, 2=don't respect original API, "
             "3 = same that 2. NOTE: For optimal floating point performance,"
             "this switch must be given also when compiling bc files to tpef.")

p.add_option('-k', '--keep-symbols',
             type="string", action="store",
             metavar='sym1,sym2,sym3', dest='keep_symbols', default="",
             help="List of symbols whose optimization away is prevented. "
             "If you are using this, remember to define "
             "at least 'main' symbol.")

p.add_option('-o', '--output-name',
             type="string", action="store", metavar='file',
             dest="output_name", default="",
             help="File name for output binary.")

p.add_option('-d', '--leave-dirty', action="store_true",
             dest='leave_dirty', default=False,
             help="Do not delete files from each compilation phase.")

p.add_option('-c', '--compile-only', action="store_true",
             dest='compile_only', default=False,
             help="Compile only do not link or optimize.")

p.add_option('-v', '--verbose', action="store_true",
             dest='verbose', default=False,
             help="Print out commands and outputs for each phase.")

p.add_option('-D', '--preprocessor-define', 
             type="string", action="append", metavar='string',
             dest="defines", default=[],
             help="Passed to gcc.")

p.add_option('-I', '--include-directory', 
             type="string", action="append", metavar='directory',
             dest="include_dirs", default=[],
             help="Passed to gcc.")

p.add_option('-L', '--library-directory', 
             type="string", action="append", metavar='directory',
             dest="lib_dirs", default=[],
             help="Passed to gcc.")

p.add_option('-l', '--library-link', 
             type="string", action="append", metavar='libname',
             dest="libs", default=[],
             help="Converted to static link command. i.e. -lpthread  => /llvm-install/tce-llvm/lib/libpthread.a")

p.add_option('-W', '--warning', 
             type="string", action="append", metavar='type',
             dest="warnings", default=[],
             help="Ignored.")

p.add_option('--plugin-cache-dir',
             type="string", action="store", metavar='directory',
             dest="plugin_cache_dir",
             default=os.path.expanduser("~/.tce/tcecc/cache"),
             help="Directory for cached llvm target plugins.")

p.add_option('--no-plugin-cache', action="store_true",
             dest="no_cache", default=False,
             help="Do not cache generated llvm target plugins.")

p.add_option('--no-schedule', action="store_true",
             dest="no_schedule", default=False,
             help="Do not call scheduler.")

p.add_option('--clear-plugin-cache', action="store_true",
             dest="clear_cache", default=False,
             help="Clear plugin cache completely.")

p.add_option('--disable-inlining', action="store_true",
             dest="noinline", default=False,
             help="Disable function inlining.")

p.add_option('--no-fp-emu', action="store_true",
             dest="disable_fp_emu", default=False,
             help="Disable floating point emulation. May cause programs"
             + " which use floating point code or printf to not to compile."
             + " Disabling floating point emulation may reduce memory usage"
             + " and binary size of compiled programs.")

p.add_option('--conservative-pre-ra-scheduler', action="store_true",
             dest="conservative_pre_ra_scheduler", default=False,
             help="Use pre-regalloc-scheduler which tries to minimize"
             + " register usage instead of maximizing ILP."
             + " Should improve performance with machines with"
             + " low amount of registers, decrease peformance with machines"
             + " which have big number of registers.")

p.add_option('--unroll-threshold',
             type="int", action="store", metavar='LLVM_INSTRUCTION_COUNT',
             dest='unroll_threshold', default=100,
             help="Unroll loops in case the unrolled loop body size will be less " + \
             "than the given number of LLVM instructions. Use 0 to disable " + \
             "loop unrolling.")

p.add_option('--inline-threshold',
             type="int", action="store",
             dest='inline_threshold', default=200,
             help="Control the amount of inlining.")

p.add_option('--sequential-schedule', action="store_true",
             dest="sequential_schedule", default=False,
             help="Runs sequential scheduler for compiled code.")

p.add_option('--debug', action="store_true",
             dest="debug", default=False,
             help="Print LLVM debug data.")

p.add_option('--isystem', 
             type="string", action="append", metavar='directory',
             dest="isystem_cc_switches", default=[],
             help="Passed to gcc as -system switch. Also -isystem is supported.")

p.add_option('-B', 
             type="string", action="append", metavar='directory',
             dest="B_cc_switches", default=[],
             help="Passed to gcc.")

p.add_option('-f', 
             type="string", action="append", metavar='opt_var',
             dest="f_cc_switches", default=[],
             help="Passed to gcc.")

p.add_option('-g', 
             type="string", action="store", metavar='store_true',
             dest="g_cc_switch", default=False,
             help="Passed to gcc.")

p.add_option('--max-thread-latency',
             type="int", action="store", metavar='usec',
             dest='max_thread_latency',
	     default=None,
             help=\
"""Emit sched_yield() calls to the program to produce given maximum thread
switch latency (in microseconds). In case the target does not have the RTIMER
operation, sched_yield() is called in every basic block unconditionally, 
producing considerable additional overhead to the program exectuion.""")

p.add_option('--default-regalloc',
             action='store_true', dest='default_regalloc', default=False,
             help=\
"""Use the default register allocator of LLVM instead of the register allocator
that aims to maximize the instruction level parallelism available for
the post-pass scheduler.""")

p.add_option('--extra-llvm-opts',
             type="string", action="store",
             metavar='opt1,opt2,opt3', dest='extra_llvm_opts', default="",
             help="List of additional LLVM passes to run after the regular ones.")

p.add_option('--gcc-optlevel',
             type="int", action="store", dest="gcc_optlevel",
             default=2,
             help=\
"""The level of optimization done by the llvm-gcc frontend,
if applicable.""")             

if @CLANG_AS_DEFAULT@:
    p.add_option('--llvm-gcc', action='store_false', dest='use_clang', default=True,
                 help=\
"Use llvm-gcc for C compilation instead of Clang.")
else:
    p.add_option('--clang', action='store_true', dest='use_clang', default=False,
                 help=\
"Use Clang for C compilation instead of llvm-gcc.")

# Commandline argument parsing

# fix gcc switches, which cannot be represented in OptionParser format by adding extra "-" before switch
args = []
for opt in sys.argv[1:]:
    if opt.startswith("-isystem"): opt = "-" + opt
    args.append(opt)

# parse valid args
options, inFiles = p.parse_args(args)

# create temp dir
tempDir = mkdtemp("","tcecc-")

# assign signal handlers to exit cleanly
signal.signal(signal.SIGHUP, handler)
signal.signal(signal.SIGTSTP, handler)

# clear plugin cache and do nothing else if the --clear-plugin-cache
# option is given
if options.clear_cache:
    pluginFiles = glob.glob(options.plugin_cache_dir + '/*.so')
    for fName in pluginFiles:
        tryRemove(fName)

    sys.stdout.write("Cleared plugin cache.\n")
    cleanup(tempDir)
    sys.exit(0)

if len(inFiles) == 0:
    p.print_help()
    cleanup(tempDir)
    sys.exit(1)

if options.output_name == "":
    # configure checks sometimes check if a.out is created by default..
    # (pth lib at least)
    outputName = "a.out"
else:
    outputName = options.output_name

### llvm-gcc install prefix
(exitCode1, output) = runCommandBuffered("dirname `which tce-llvm-gcc`", False)
(exitCode2, output) = runCommandBuffered("dirname `which clang`", False)
if exitCode1 != 0 and exitCode2 != 0:
    sys.stderr.write("Could not find 'tce-llvm-gcc' nor 'clang'. Have you installed one of them in PATH?\n")
    exitWithError(1, output)

### tce install prefix
(exitCode, output) = runCommandBuffered("tce-config --prefix", False)
if exitCode != 0:
    tceInstalled = False
else:
    tceInstalled = True
    tceprefix = output
    
## check if we are running from the TCE source tree in which case use only
## source tree libraries and binaries
scriptDir = os.path.abspath(os.path.dirname(sys.argv[0]))
runningInstalled = 'src/bintools/Compiler' not in scriptDir

if runningInstalled:
    lowerintrinsicsplugin = os.path.join(tceprefix,"lib/tce/LowerIntrinsics.so")
    newlib_libdir = os.path.join(tceprefix,"tce-llvm/lib")
    newlib_includes = "-isystem " + os.path.join(tceprefix,"tce-llvm/include") + " "
    #srcRoot = None
else:
    #srcRoot = scriptDir.split('bintools/Compiler')[0]
    lowerintrinsicsplugin = os.path.join("@abs_top_builddir@", "src/applibs/LLVMBackend/passes/.libs/LowerIntrinsics.so")
    newlib_libdir = os.path.join("@abs_top_builddir@","newlib-1.17.0/tce-llvm/newlib")
    newlib_includes = ("-isystem " + os.path.join("@abs_top_srcdir@","newlib-1.17.0/tce-llvm/newlib/targ-include") +
                       " -isystem " + os.path.join("@abs_top_srcdir@","newlib-1.17.0/newlib/libc/include") +
                       " -isystem " + os.path.join("@abs_top_srcdir@","newlib-1.17.0/newlib/libm/include") + " ")

if options.verbose:
    if runningInstalled:
        print "Running installed TCE from PATH."    
    else:
        print "Running from a TCE build tree rooted at '%s'." % "@abs_top_builddir@"
    
    
namePrefix = tempDir + "/" + os.path.basename(outputName)

if options.compile_only and options.output_name != "" and len(inFiles) > 1:
    sys.stdout.write("Cannot specify -o  with -c and multiple input files.\n")
    cleanup(tempDir)
    sys.exit(1)

elif len(inFiles) == 1 and inFiles[0][-3:] == ".bc":
    # Only one .bc inputfile given. No need to compile, link or optimize anything.
    # Note: Already linked bytecode can't be linked or optimized
    # with -lowermissing again anyway!
    optimizedFileName = inFiles[0]
else:
    # Compile, link and optimize input files.
    
    # generate tceops.h
    if runningInstalled:
        tceopgen = "tceopgen"
    else:
        tceopgen = "@abs_top_builddir@" + "/src/bintools/Compiler/tceopgen/tceopgen"
        
    (exitCode, output) = runCommandBuffered(
        tceopgen + " -o " + tempDir + "/tceops.h" , options.verbose)
    
    if exitCode != 0:
        sys.stderr.write("Error while generating custom operation macros:\n")
        exitWithError(1, output)
    
    linkList = processInputFiles(inFiles, tempDir, options.verbose)

    # if only compiling
    if options.compile_only:
        if options.output_name != "":
            (exitCode, output) = runCommandBuffered(
                "mv " + linkList[0] + " " + options.output_name,
                options.verbose)

        else:
            cmd = "mv "
            for fName in linkList:
                cmd += fName + " "
            cmd += "."
            (exitCode, output) = runCommandBuffered(cmd, options.verbose)

        cleanup(tempDir)
        sys.exit(0)

    # convert -l switches to static library link commands.
    for i in options.libs:
        linkList.append(newlib_libdir + "/lib%s.a" % i)
    
    linkedFileName = linkBytecode(linkList, namePrefix, options.verbose)

    # optimize the fully linked program also
    optimizedFileName = optimizeBytecode(linkedFileName, namePrefix)

    if (options.adf_file == ""):
        (exitCode, output) = runCommandBuffered(
            "mv " +  optimizedFileName + " " + outputName,
            options.verbose)
        
#### Schedule compiled sequential code for machines
if options.adf_file != "":

    outFile = outputName
    seqFile = tempDir + "/" + os.path.basename(outFile) + ".seq"

    # optimize and lower floatingpoint
    if options.disable_fp_emu is False:
        emulationLinkedFileName = linkEmulationFuncs(optimizedFileName, namePrefix)
    else:
        emulationLinkedFileName = optimizedFileName

    if options.sequential_schedule or options.optimization_level == 0:
        scheduler_config_file_name = "sequential_tcecc_scheduler.conf"
    else:
        scheduler_config_file_name = "default_scheduler.conf"        
        
    if options.no_schedule is False and options.scheduler_config is None:
        if runningInstalled:
            options.scheduler_config = (tceprefix +
                                        "/share/tce/scheduler/passes/" +
                                        scheduler_config_file_name)
        else:
            options.scheduler_config = os.path.normpath("@abs_top_srcdir@" +
                                                        "/scheduler/passes/" +
                                                        scheduler_config_file_name)

    #### Compile to unscheduled mixed code for the target architecture
    if not runningInstalled:
        command = "@abs_top_builddir@" + "/src/bintools/Compiler/llvm-tce/llvm-tce"
    else:
        command = "llvm-tce"

    if options.verbose:
        command += " -v"
        
    if options.debug:
        command += " --debug"

    if options.conservative_pre_ra_scheduler:
        command += " --conservative-pre-ra-scheduler"

    if not options.default_regalloc:
        command += " --experimental-ra"
        
    if options.no_schedule is False:
        command += " -c " + options.scheduler_config

    stdEmulationLib = os.path.join(newlib_libdir, "standard_emulation.o ")

    command += (" -a " + options.adf_file +
                " -o " + outFile +
                " -O" + str(options.optimization_level) +
                " -e" + stdEmulationLib +
                " " + emulationLinkedFileName)
    
    if options.max_thread_latency is not None:
	    # Temporary hack until 'schedule' supports passing cmdline
	    # options to passes.
	    import os
	    os.environ['MAX_THREAD_SWITCH_LATENCY'] = \
            str(options.max_thread_latency)
    
    exitCode = runCommand(command, options.verbose, True)
    if exitCode != 0:
        exitWithError(1, "Error while compiling " + command + "\n")

#### Cleanup trashes
cleanup(tempDir)
