Index: llvm/lib/Analysis/InlineCost.cpp
===================================================================
--- llvm.orig/lib/Analysis/InlineCost.cpp	2010-05-25 17:02:48.000000000 +0300
+++ llvm/lib/Analysis/InlineCost.cpp	2010-05-25 19:32:49.000000000 +0300
@@ -15,6 +15,7 @@
 #include "llvm/Support/CallSite.h"
 #include "llvm/CallingConv.h"
 #include "llvm/IntrinsicInst.h"
+#include "llvm/InlineAsm.h"
 #include "llvm/ADT/SmallPtrSet.h"
 using namespace llvm;
 
@@ -154,7 +155,6 @@
         continue;  // Debug intrinsics don't count as size.
       
       CallSite CS = CallSite::get(const_cast<Instruction*>(&*II));
-      
       // If this function contains a call to setjmp or _setjmp, never inline
       // it.  This is a hack because we depend on the user marking their local
       // variables as volatile if they are live across a setjmp call, and they
@@ -172,7 +172,8 @@
           NeverInline = true;
       }
 
-      if (!isa<IntrinsicInst>(II) && !callIsSmall(CS.getCalledFunction())) {
+      if (!isa<IntrinsicInst>(II) && !callIsSmall(CS.getCalledFunction()) &&
+          !isa<InlineAsm>(CS.getCalledValue())) {
         // Each argument to a call takes on average one instruction to set up.
         NumInsts += CS.arg_size();
         ++NumCalls;
